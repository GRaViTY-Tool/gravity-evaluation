/*
Copyright (C) 2003 David Weitzman, Morten O. Alver

All programs in this directory and
subdirectories are published under the GNU General Public License as
described below.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA

Further information about the GNU GPL is available at:
http://www.gnu.org/copyleft/gpl.ja.html

Note:
Modified for use in JabRef.

*/
package net.sf.jabref;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import com.jgoodies.forms.builder.DefaultFormBuilder;
import com.jgoodies.forms.layout.FormLayout;

import net.sf.jabref.TabLabelPattern.buttonHandler;
import net.sf.jabref.export.layout.LayoutFormatter;
import net.sf.jabref.export.layout.LayoutHelper;
import net.sf.jabref.export.layout.format.XMLChars;
import net.sf.jabref.mods.MODSEntry;
import net.sf.jabref.mods.PageNumbers;

import java.util.Locale;
import java.util.Set;

public abstract class BibtexEntryType implements Comparable<BibtexEntryType>
{

    public static final BibtexEntryType OTHER =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Other";
            }

            public String[] getOptionalFields()
            {
                return new String[0];
            }

            public String[] getRequiredFields()
            {
                return new String[0];
            }


            public String describeRequiredFields()
            {
                return "";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return true;
            }
        };


    public static final BibtexEntryType ARTICLE =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Article";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "number", "month", "part", "eid", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "journal", "year", "volume", "pages"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE, JOURNAL and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "author", "title", "journal", "year", "bibtexkey", "volume", "pages"
                    }, database);
            }
        };

    public static final BibtexEntryType BOOKLET =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Booklet";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "author", "howpublished", "lastchecked", "address", "month", "year", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "title"
                };
            }

            public String describeRequiredFields()
            {
                return "TITLE";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "title", "bibtexkey"
                    }, database);
            }
        };


   public static final BibtexEntryType INBOOK =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Inbook";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "volume", "number", "pages", "series", "type", "address", "edition",
		    "month", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "chapter", "pages", "title", "publisher", "year", "editor",
		    "author"
                };
            }

            @Override
            public String[] getRequiredFieldsForCustomization() {
                return new String[] {"author/editor", "title", "chapter/pages", "year", "publisher"};
            }

            public String describeRequiredFields()
            {
                return "TITLE, CHAPTER and/or PAGES, PUBLISHER, YEAR, and an "
		    +"EDITOR and/or AUTHOR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "title", "publisher", "year", "bibtexkey"
                    }, database) &&
		    (((entry.getField("author") != null) ||
		      (entry.getField("editor") != null)) &&
		     ((entry.getField("chapter") != null) ||
		      (entry.getField("pages") != null)));
            }
        };

    public static final BibtexEntryType BOOK =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Book";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "volume", "number", "pages", "series", "address", "edition", "month",
                    "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "title", "publisher", "year", "editor", "author"
                };
            }

            public String[] getRequiredFieldsForCustomization()
            {
                return new String[]
                {
                    "title", "publisher", "year", "author/editor"
                };
            }

            public String describeRequiredFields()
            {
                return "TITLE, PUBLISHER, YEAR, and an EDITOR and/or AUTHOR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "title", "publisher", "year", "bibtexkey"
                    }, database) &&
                ((entry.getField("author") != null) ||
                (entry.getField("editor") != null));
            }
        };


    public static final BibtexEntryType INCOLLECTION =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Incollection";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "editor", "volume", "number", "series", "type", "chapter",
		    "pages", "address", "edition", "month", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "booktitle", "publisher", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE, BOOKTITLE, PUBLISHER and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
			"author", "title", "booktitle", "publisher", "year",
			"bibtexkey"

                    }, database);
            }
        };

    public static final BibtexEntryType CONFERENCE =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Conference";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "editor", "volume", "number", "series", "pages",
		    "address", "month", "organization", "publisher", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "booktitle", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE, BOOKTITLE and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
			"author", "title", "booktitle", "year" , "bibtexkey"
                    }, database);
            }
        };

    public static final BibtexEntryType INPROCEEDINGS =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Inproceedings";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "editor", "volume", "number", "series", "pages",
		    "address", "month", "organization", "publisher", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "booktitle", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE, BOOKTITLE and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
			"author", "title", "booktitle", "year" , "bibtexkey"
                    }, database);
            }
        };

    public static final BibtexEntryType PROCEEDINGS =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Proceedings";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "editor", "volume", "number", "series", "address",
		    "publisher", "note", "month", "organization"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "title", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "TITLE and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
			"title", "year", "bibtexkey"
                    }, database);
            }
        };


    public static final BibtexEntryType MANUAL =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Manual";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "author", "organization", "address", "edition",
		    "month", "year", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "title"
                };
            }

            public String describeRequiredFields()
            {
                return "TITLE";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "title", "bibtexkey"
                    }, database);
            }
        };

    public static final BibtexEntryType TECHREPORT =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Techreport";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "type", "number", "address", "month", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "institution", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE, INSTITUTION and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
			"author", "title", "institution", "year",
			"bibtexkey"
                    }, database);
            }
        };


    public static final BibtexEntryType MASTERSTHESIS =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Mastersthesis";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "type", "address", "month", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "school", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE, SCHOOL and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "author", "title", "school", "year", "bibtexkey"
                    }, database);
            }
        };


    public static final BibtexEntryType PHDTHESIS =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Phdthesis";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "type", "address", "month", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "school", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE, SCHOOL and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "author", "title", "school", "year", "bibtexkey"
                    }, database);
            }
        };

    public static final BibtexEntryType UNPUBLISHED =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Unpublished";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "month", "year"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "note"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE and NOTE";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
			"author", "title", "note", "bibtexkey"
                    }, database);
            }
        };

     public static final BibtexEntryType PERIODICAL =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Periodical";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "editor", "language", "series", "volume", "number", "organization", "month", "note", "url"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "title", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "TITLE and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "title", "year", "bibtexkey"
                    }, database);
            }
        };

     public static final BibtexEntryType PATENT =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Patent";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "author", "title", "language", "assignee", "address", "type", "number", "day", "dayfiled", "month", "monthfiled", "note", "url"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "nationality", "number", "year", "yearfiled"
                };
            }

            public String describeRequiredFields()
            {
                return "NATIONALITY, NUMBER, YEAR or YEARFILED";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "number", "bibtexkey"
                    }, database) &&
                ((entry.getField("year") != null) ||
                (entry.getField("yearfiled") != null));
            }
        };

   public static final BibtexEntryType STANDARD =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Standard";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "author", "language", "howpublished", "type", "number", "revision", "address", "month", "year", "note", "url"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "title", "organization", "institution"
                };
            }

            @Override
            public String[] getRequiredFieldsForCustomization() {
                return new String[] {"title", "organization/institution"};
            }

            public String describeRequiredFields()
            {
                return "TITLE, ORGANIZATION or INSTITUTION";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "title", "bibtexkey"
                    }, database) &&
                ((entry.getField("organization") != null) ||
                (entry.getField("institution") != null));
            }
        };

    public static final BibtexEntryType ELECTRONIC =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Electronic";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "author", "month", "year", "title", "language", "howpublished", "organization", "address", "note", "url"
                };
            }

            public String[] getRequiredFields()
            {
                return null;
            }

            public String describeRequiredFields()
            {
                return "None";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "bibtexkey"
                    }, database);
            }
        };

    public static final BibtexEntryType MISC =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Misc";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "author", "title", "howpublished", "month", "year", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return null;
            }

            public String describeRequiredFields()
            {
                return "None";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
		return entry.allFieldsPresent(new String[]
                    {
			"bibtexkey"
                    }, database);
            }
        };

    /**
     * This type is provided as an emergency choice if the user makes
     * customization changes that remove the type of an entry.
     */
    public static final BibtexEntryType TYPELESS =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Typeless";
            }

            public String[] getOptionalFields()
            {
                return null;
            }

            public String[] getRequiredFields()
            {
                return null;
            }

            public String describeRequiredFields()
            {
                return "None";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
		return false;
           }
        };


    public abstract String getName();

    public int compareTo(BibtexEntryType o) {
	return getName().compareTo(o.getName());
    }

    public abstract String[] getOptionalFields();

    public abstract String[] getRequiredFields();

    public String[] getGeneralFields() {
        return new String[]
	    {"crossref", "keywords", "doi", "url", "file",
	     "citeseerurl", "pdf", "abstract", "comment",
         "owner", "timestamp", "review", };
    }

    public String[] getPrimaryOptionalFields() {
        return null;
    }

    public abstract String describeRequiredFields();

    public abstract boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database);


    public String[] getUtilityFields(){
        return new String[] {"search" } ;
    }


    public boolean isRequired(String field) {
	String[] req = getRequiredFields();
	if (req == null) return false;
	for (int i=0; i<req.length; i++)
	    if (req[i].equals(field)) return true;
	return false;
    }

    public boolean isOptional(String field) {
	String[] opt = getOptionalFields();
	if (opt == null) return false;
	for (int i=0; i<opt.length; i++)
	    if (opt[i].equals(field)) return true;
	return false;
    }

    public static TreeMap<String, BibtexEntryType> ALL_TYPES = new TreeMap<String, BibtexEntryType>();
    public static TreeMap<String, BibtexEntryType> STANDARD_TYPES = new TreeMap<String, BibtexEntryType>();
    static {
        // Put the standard entry types into the type map.
        if (!Globals.prefs.getBoolean("biblatexMode")) {
            ALL_TYPES.put("article", ARTICLE);
            ALL_TYPES.put("inbook", INBOOK);
            ALL_TYPES.put("book", BOOK);
            ALL_TYPES.put("booklet", BOOKLET);
            ALL_TYPES.put("incollection", INCOLLECTION);
            ALL_TYPES.put("conference", CONFERENCE);
            ALL_TYPES.put("inproceedings", INPROCEEDINGS);
            ALL_TYPES.put("proceedings", PROCEEDINGS);
            ALL_TYPES.put("manual", MANUAL);
            ALL_TYPES.put("mastersthesis", MASTERSTHESIS);
            ALL_TYPES.put("phdthesis", PHDTHESIS);
            ALL_TYPES.put("techreport", TECHREPORT);
            ALL_TYPES.put("unpublished", UNPUBLISHED);
            ALL_TYPES.put("patent", PATENT);
            ALL_TYPES.put("standard", STANDARD);
            ALL_TYPES.put("electronic", ELECTRONIC);
            ALL_TYPES.put("periodical", PERIODICAL);
            ALL_TYPES.put("misc", MISC);
            ALL_TYPES.put("other", OTHER);
        }
        else {
            ALL_TYPES.put("article", BibLatexEntryTypes.ARTICLE);
	    ALL_TYPES.put("book", BibLatexEntryTypes.BOOK);
	    ALL_TYPES.put("inbook", BibLatexEntryTypes.INBOOK);
	    ALL_TYPES.put("bookinbook", BibLatexEntryTypes.BOOKINBOOK);
	    ALL_TYPES.put("suppbook", BibLatexEntryTypes.SUPPBOOK);
	    ALL_TYPES.put("booklet", BibLatexEntryTypes.BOOKLET);
	    ALL_TYPES.put("collection", BibLatexEntryTypes.COLLECTION);
	    ALL_TYPES.put("incollection", BibLatexEntryTypes.INCOLLECTION);
	    ALL_TYPES.put("suppcollection", BibLatexEntryTypes.SUPPCOLLECTION);
	    ALL_TYPES.put("manual", BibLatexEntryTypes.MANUAL);
	    ALL_TYPES.put("misc", BibLatexEntryTypes.MISC);
	    ALL_TYPES.put("online", BibLatexEntryTypes.ONLINE);
	    ALL_TYPES.put("patent", BibLatexEntryTypes.PATENT);
	    ALL_TYPES.put("periodical", BibLatexEntryTypes.PERIODICAL);
	    ALL_TYPES.put("suppperiodical", BibLatexEntryTypes.SUPPPERIODICAL);
	    ALL_TYPES.put("proceedings", BibLatexEntryTypes.PROCEEDINGS);
	    ALL_TYPES.put("inproceedings", BibLatexEntryTypes.INPROCEEDINGS);
	    ALL_TYPES.put("reference", BibLatexEntryTypes.REFERENCE);
	    ALL_TYPES.put("inreference", BibLatexEntryTypes.INREFERENCE);
	    ALL_TYPES.put("report", BibLatexEntryTypes.REPORT);
	    ALL_TYPES.put("set", BibLatexEntryTypes.SET);
	    ALL_TYPES.put("thesis", BibLatexEntryTypes.THESIS);
	    ALL_TYPES.put("unpublished", BibLatexEntryTypes.UNPUBLISHED);
	    ALL_TYPES.put("conference", BibLatexEntryTypes.CONFERENCE);
	    ALL_TYPES.put("electronic", BibLatexEntryTypes.ELECTRONIC);
	    ALL_TYPES.put("mastersthesis", BibLatexEntryTypes.MASTERSTHESIS);
	    ALL_TYPES.put("phdthesis", BibLatexEntryTypes.PHDTHESIS);
	    ALL_TYPES.put("techreport", BibLatexEntryTypes.TECHREPORT);
	    ALL_TYPES.put("www", BibLatexEntryTypes.WWW);
        }

        // We need a record of the standard types, in case the user wants
        // to remove a customized version. Therefore we clone the map.
        STANDARD_TYPES = new TreeMap<String, BibtexEntryType>(ALL_TYPES);
    }

    /**
     * This method returns the BibtexEntryType for the name of a type,
     * or null if it does not exist.
     */
    public static BibtexEntryType getType(String name) {
	//Util.pr("'"+name+"'");
	Object o = ALL_TYPES.get(name.toLowerCase(Locale.US));
	if (o == null)
	    return null;
	else return (BibtexEntryType)o;
    }

    /**
     * This method returns the standard BibtexEntryType for the
     * name of a type, or null if it does not exist.
     */
    public static BibtexEntryType getStandardType(String name) {
	//Util.pr("'"+name+"'");
	Object o = STANDARD_TYPES.get(name.toLowerCase());
	if (o == null)
	    return null;
	else return (BibtexEntryType)o;
    }

    /**
     * Removes a customized entry type from the type map. If this type
     * overrode a standard type, we reinstate the standard one.
     *
     * @param name The customized entry type to remove.
     */
    public static void removeType(String name) {
	//BibtexEntryType type = getType(name);
	String nm = name.toLowerCase();
        //System.out.println(ALL_TYPES.size());
	ALL_TYPES.remove(nm);
        //System.out.println(ALL_TYPES.size());
	if (STANDARD_TYPES.get(nm) != null) {
	    // In this case the user has removed a customized version
	    // of a standard type. We reinstate the standard type.
	    ALL_TYPES.put(nm, STANDARD_TYPES.get(nm));
	}

    }

    /**
     * Load all custom entry types from preferences. This method is
     * called from JabRef when the program starts.
     */
    public static void loadCustomEntryTypes(JabRefPreferences prefs) {
	int number = 0;
	CustomEntryType type;
	while ((type = prefs.getCustomEntryType(number)) != null) {
	    ALL_TYPES.put(type.getName().toLowerCase(), type);
	    number++;
	}
    }

    /**
     * Iterate through all entry types, and store those that are
     * custom defined to preferences. This method is called from
     * JabRefFrame when the program closes.
     */
    public static void saveCustomEntryTypes(JabRefPreferences prefs) {
	Iterator<String> i=ALL_TYPES.keySet().iterator();
	int number = 0;
	//Vector customTypes = new Vector(10, 10);
	while (i.hasNext()) {
	    Object o=ALL_TYPES.get(i.next());
	    if (o instanceof CustomEntryType) {
		// Store this entry type.
		prefs.storeCustomEntryType((CustomEntryType)o, number);
		number++;
	    }
	}
	// Then, if there are more 'old' custom types defined, remove these
	// from preferences. This is necessary if the number of custom types
	// has decreased.
	prefs.purgeCustomEntryTypes(number);
    }

    /**
     * Get an array of the required fields in a form appropriate for the entry customization
     * dialog - that is, thie either-or fields together and separated by slashes.
     * @return Array of the required fields in a form appropriate for the entry customization dialog.
     */
    public String[] getRequiredFieldsForCustomization() {
        return getRequiredFields();
    }

	/**
	 * Method to build GUI
	 *
	 */
	private void buildGUI(){
	
	    ButtonGroup bg = new ButtonGroup();
	    bg.add(letterStartA);
	    bg.add(letterStartB);
	    bg.add(alwaysAddLetter);
	
	    JPanel pan = new JPanel();
	    JScrollPane sp = new JScrollPane(pan);
	    sp.setPreferredSize(new Dimension(100,100));
	    sp.setBorder(BorderFactory.createEmptyBorder());
	    pan.setLayout(gbl);
	    setLayout(gbl);	    
	    // The header - can be removed
	    lblEntryType = new JLabel(Globals.lang("Entry type"));
	    Font f = new Font("plain", Font.BOLD, 12);
	    lblEntryType.setFont(f);
	    con.gridx = 0;
	    con.gridy = 0;
	    con.gridwidth = 1;
	    con.gridheight = 1;
	    con.fill = GridBagConstraints.VERTICAL;
	    con.anchor = GridBagConstraints.WEST;
	    con.insets = new Insets( 5,5,10,0 );
	    gbl.setConstraints( lblEntryType, con );
	    pan. add( lblEntryType );
	    
	    lblKeyPattern = new JLabel(Globals.lang("Key pattern"));
	    lblKeyPattern.setFont(f);
	    con.gridx = 1;
	    con.gridy = 0;
	    //con.gridwidth = 2;
	    con.gridheight = 1;
	    con.fill = GridBagConstraints.HORIZONTAL;
	    con.anchor = GridBagConstraints.WEST;
	    con.insets = new Insets( 5,5,10,5 );
	    gbl.setConstraints( lblKeyPattern, con );
	    pan.add( lblKeyPattern );
	
	
	        con.gridy = 1;
	        con.gridx = 0;
	        JLabel lab = new JLabel(Globals.lang("Default pattern"));
	        gbl.setConstraints(lab, con);
	        pan.add(lab);
	        con.gridx = 1;
	        gbl.setConstraints(defaultPat, con);
	        pan.add(defaultPat);
	    con.insets = new Insets( 5,5,10,5 );
	    btnDefault = new JButton(Globals.lang("Default"));
	    btnDefault.addActionListener(new ActionListener() {
	        public void actionPerformed(ActionEvent event) {
	            defaultPat.setText((String)Globals.prefs.defaults.get("defaultLabelPattern"));
	        }
	    });
	    con.gridx = 2;
	    int y = 2;
	    gbl.setConstraints(btnDefault, con);
	    pan.add(btnDefault);
	
	    for (String s : BibtexEntryType.ALL_TYPES.keySet()) {
			textFields.put(s, addEntryType(pan, s, y));
			y++;
		}
	
	    con.fill = GridBagConstraints.BOTH;
	    con.gridx = 0;
	    con.gridy = 1;
	    con.gridwidth = 3;
	    con.weightx = 1;
	    con.weighty = 1;
	    gbl.setConstraints(sp, con );
	    add(sp);
	
	    // A help button
	    con.gridwidth = 1;
	    con.gridx = 1;
	    con.gridy = 2;
	    con.fill = GridBagConstraints.HORIZONTAL;
	    //
	    con.weightx = 0;
	    con.weighty = 0;
	    con.anchor = GridBagConstraints.SOUTHEAST;
	    con.insets = new Insets( 0,5,0,5 );
	    JButton hlb = new JButton(GUIGlobals.getImage("helpSmall"));
	    hlb.setToolTipText(Globals.lang("Help on key patterns"));
	    gbl.setConstraints( hlb, con );
	    add(hlb);
	    hlb.addActionListener(help);
	    
	    // And finally a button to reset everything
	    btnDefaultAll = new JButton(Globals.lang("Reset all"));
	    con.gridx = 2;
	    con.gridy = 2;
	
	    //con.fill = GridBagConstraints.BOTH;
	    con.weightx = 1;
	    con.weighty = 0;
	    con.anchor = GridBagConstraints.SOUTHEAST;
	    con.insets = new Insets( 20,5,0,5 );
	    gbl.setConstraints( btnDefaultAll, con );
	    btnDefaultAll.addActionListener(new buttonHandler());
	    add( btnDefaultAll );
	
	
	    // Build a panel for checkbox settings:
	    FormLayout layout = new FormLayout
	        ("1dlu, 8dlu, left:pref, 8dlu, left:pref", "");//, 8dlu, 20dlu, 8dlu, fill:pref", "");
	    pan = new JPanel();
	    DefaultFormBuilder builder = new DefaultFormBuilder(layout);
	    builder.appendSeparator(Globals.lang("Key generator settings"));
	
	    builder.nextLine();
	    builder.append(pan);
	    builder.append(autoGenerateOnImport);
	    builder.append(letterStartA);
	    builder.nextLine();
	    builder.append(pan);
	    builder.append(warnBeforeOverwriting);
	    builder.append(letterStartB);
	    builder.nextLine();
	    builder.append(pan);
	    builder.append(dontOverwrite);
	    builder.append(alwaysAddLetter);
	    builder.nextLine();
	    builder.append(pan);
	    builder.append(generateOnSave);        
	    builder.nextLine();
	    builder.append(pan);
	    builder.append(Globals.lang("Replace (regular expression)")+":");
	    builder.append(Globals.lang("by")+":");
	
	    builder.nextLine();
	    builder.append(pan);
	    builder.append(KeyPatternRegex);
	    builder.append(KeyPatternReplacement);
	
	    builder.getPanel().setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
	    con.gridx = 1;
	    con.gridy = 3;
	    con.gridwidth = GridBagConstraints.REMAINDER;
	    con.weightx = 1;
	    con.fill = GridBagConstraints.BOTH;
	    gbl.setConstraints(builder.getPanel(), con);
	    add(builder.getPanel());
	
	    dontOverwrite.addChangeListener(new ChangeListener() {
	        public void stateChanged(ChangeEvent event) {
	            // Warning before overwriting is only relevant if overwriting can happen:
	            warnBeforeOverwriting.setEnabled(!dontOverwrite.isSelected());
	        }
	    });
	
	  /*
	   Simon Fischer's patch for replacing a regexp in keys before converting to filename:
	
	layout = new FormLayout
	        ("left:pref, 8dlu, left:pref, left:pref", "");
	builder = new DefaultFormBuilder(layout);
	    builder.appendSeparator(Globals.lang("Bibkey to filename conversion"));
	    builder.nextLine();
	builder.append(Globals.lang("Replace"), basenamePatternRegex);
	    builder.nextLine();
	builder.append(Globals.lang("by"), basenamePatternReplacement);
	    builder.nextLine();
	
	    builder.getPanel().setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
	    con.gridx = 2;
	con.gridy = 3;
	con.gridwidth = GridBagConstraints.REMAINDER;
	con.weightx = 1;
	con.fill = GridBagConstraints.BOTH;
	gbl.setConstraints(builder.getPanel(), con);
	    add(builder.getPanel());
	    */
	}

	public String doLayout(BibtexEntry bibtex, BibtexDatabase database) {
	
		switch (type) {
		case LayoutHelper.IS_LAYOUT_TEXT:
			return text;
		case LayoutHelper.IS_SIMPLE_FIELD:
			String value = BibtexDatabase.getResolvedField(text, bibtex, database);
	        if (value == null)
	            value = "";
	        // If a post formatter has been set, call it:
	        if (postFormatter != null)
	            value = postFormatter.format(value);
	        return value;
		case LayoutHelper.IS_FIELD_START:
		case LayoutHelper.IS_GROUP_START: {
	        String field;
	        if (type == LayoutHelper.IS_GROUP_START)
	            field = BibtexDatabase.getResolvedField(text, bibtex, database);
	        else {
	            String[] parts = text.split(";");
	            field = null;
	            for (int i = 0; i < parts.length; i++) {
	                field = BibtexDatabase.getResolvedField(parts[i], bibtex, database);
	                if (field == null)
	                    break;
	            }
	        }
			
			if ((field == null)
				|| ((type == LayoutHelper.IS_GROUP_START) && (field.equalsIgnoreCase(LayoutHelper
					.getCurrentGroup())))) {
				return null;
			} else {
				if (type == LayoutHelper.IS_GROUP_START) {
					LayoutHelper.setCurrentGroup(field);
				}
				StringBuffer sb = new StringBuffer(100);
				String fieldText;
				boolean previousSkipped = false;
	
				for (int i = 0; i < layoutEntries.length; i++) {
					fieldText = layoutEntries[i].doLayout(bibtex, database);
	
					if (fieldText == null) {
						if ((i + 1) < layoutEntries.length) {
							if (layoutEntries[i + 1].doLayout(bibtex, database).trim().length() == 0) {
								i++;
								previousSkipped = true;
								continue;
							}
						}
					} else {
						// if previous was skipped --> remove leading line
						// breaks
						if (previousSkipped) {
							int eol = 0;
	
							while ((eol < fieldText.length())
								&& ((fieldText.charAt(eol) == '\n') || (fieldText.charAt(eol) == '\r'))) {
								eol++;
							}
	
							if (eol < fieldText.length()) {
								sb.append(fieldText.substring(eol));
							}
						} else {
							// System.out.println("ENTRY-BLOCK: " +
							// layoutEntries[i].doLayout(bibtex));
							sb.append(fieldText);
						}
					}
	
					previousSkipped = false;
				}
	
				return sb.toString();
			}
		}
		case LayoutHelper.IS_FIELD_END:
		case LayoutHelper.IS_GROUP_END:
			return "";
		case LayoutHelper.IS_OPTION_FIELD: {
			String fieldEntry;
	
			if (text.equals("bibtextype")) {
				fieldEntry = bibtex.getType().getName();
			} else {
				// changed section begin - arudert
				// resolve field (recognized by leading backslash) or text
				String field = text.startsWith("\\") ? BibtexDatabase.getResolvedField(text.substring(1), bibtex, database)
					: BibtexDatabase.getText(text, database);
				// changed section end - arudert
				if (field == null) {
					fieldEntry = "";
				} else {
					fieldEntry = field;
				}
			}
	
			// System.out.println("OPTION: "+option);
			if (option != null) {
				for (int i = 0; i < option.length; i++) {
					fieldEntry = option[i].format(fieldEntry);
				}
			}
	
	        // If a post formatter has been set, call it:
	        if (postFormatter != null)
	            fieldEntry = postFormatter.format(fieldEntry);
	
			return fieldEntry;
		}
	    case LayoutHelper.IS_ENCODING_NAME: {
	        // Printing the encoding name is not supported in entry layouts, only
	        // in begin/end layouts. This prevents breakage if some users depend
	        // on a field called "encoding". We simply return this field instead:
	        return BibtexDatabase.getResolvedField("encoding", bibtex, database);
	    }
	    default:
			return "";
		}
	}

	private BibtexEntry parseNextEntry(String allText, int startIndex) {
	    BibtexEntry entry = null;
	    
	 	int index = allText.indexOf("<div class=\"detail", piv);
	    int endIndex = allText.indexOf("</div>", index);
	
	    if (index >= 0 && endIndex > 0) {
	    	endIndex += 6;
	    	piv = endIndex;
	    	String text = allText.substring(index, endIndex);
	        
	        BibtexEntryType type = null;
	        String sourceField = null;
	        
	        String typeName = "";
	        Matcher typeMatcher = typePattern.matcher(text);
	        if (typeMatcher.find()) {
	            typeName = typeMatcher.group(1);
	            if (typeName.equalsIgnoreCase("IEEE Journals") || typeName.equalsIgnoreCase("IEEE Early Access") ||
	            		typeName.equalsIgnoreCase("IET Journals") || typeName.equalsIgnoreCase("AIP Journals") ||
					   	typeName.equalsIgnoreCase("AVS Journals") || typeName.equalsIgnoreCase("IBM Journals")) {
	                type = BibtexEntryType.getType("article");
	                sourceField = "journal";
	            } else if (typeName.equalsIgnoreCase("IEEE Conferences") || typeName.equalsIgnoreCase("IET Conferences")) {
	                type = BibtexEntryType.getType("inproceedings");
	                sourceField = "booktitle";
		        } else if (typeName.equalsIgnoreCase("IEEE Standards")) {
	                type = BibtexEntryType.getType("standard");
	                sourceField = "number";
		        } else if (typeName.equalsIgnoreCase("IEEE Educational Courses")) {
		        	type = BibtexEntryType.getType("Electronic");
		        	sourceField = "note";
		        } else if (typeName.equalsIgnoreCase("IEEE Book Chapter")) {
		        	type = BibtexEntryType.getType("inCollection");
		        	sourceField = "booktitle";
		        }
	        }
	        
	        if (type == null) {
	        	type = BibtexEntryType.getType("misc");
	        	sourceField = "note";
	            System.err.println("Type detection failed. Use MISC instead.");
	            unparseable++;
	            System.err.println(text);
	        }
	    
	        entry = new BibtexEntry(Util.createNeutralId(), type);
	        
	        if (typeName.equalsIgnoreCase("IEEE Standards")) {
	        	entry.setField("organization", "IEEE");
	        }
	        
	        if (typeName.equalsIgnoreCase("IEEE Book Chapter")) {
	        	entry.setField("publisher", "IEEE");
	        }
	        
	        if (typeName.equalsIgnoreCase("IEEE Early Access")) {
	        	entry.setField("note", "Early Access");
	        }
	        
	        Set<String> fields = fieldPatterns.keySet();
	        for (String field: fields) {
	        	Matcher fieldMatcher = Pattern.compile(fieldPatterns.get(field)).matcher(text);
	        	if (fieldMatcher.find()) {
	        		entry.setField(field, htmlConverter.format(fieldMatcher.group(1)));
	        		if (field.equals("title") && fieldMatcher.find()) {
	        			String sec_title = htmlConverter.format(fieldMatcher.group(1));
	        			if (entry.getType() == BibtexEntryType.getStandardType("standard")) {
	        				sec_title = sec_title.replaceAll("IEEE Std ", "");
	        			}
	        			entry.setField(sourceField, sec_title);
	        			
	        		}
	        		if (field.equals("pages") && fieldMatcher.groupCount() == 2) {
	        			entry.setField(field, fieldMatcher.group(1) + "-" + fieldMatcher.group(2));
	        		}
	        	}
	        }
	        if (entry.getType() == BibtexEntryType.getStandardType("inproceedings") && entry.getField("author").equals("")) {
	        	entry.setType(BibtexEntryType.getStandardType("proceedings"));
	        }
	    
	        if (includeAbstract) {
	        	index = allText.indexOf("<div class=\"abstract RevealContent", piv);
	            if (index >= 0) {
	            	endIndex = allText.indexOf("</div>", index) + 6;
		            piv = endIndex;
		            
	            	text = allText.substring(index, endIndex);
	            	Matcher absMatcher = absPattern.matcher(text);
	            	if (absMatcher.find()) {
	            		entry.setField("abstract", absMatcher.group(1));
	            	}
	            }
	        }
	    }
	    
	    if (entry == null) {
	    	return null;
	    } else {
	        return cleanup(entry);
	    }
	}

	private BibtexEntry cleanup(BibtexEntry entry) {
		if (entry == null)
			return null;
		
		// clean up author
		String author = (String)entry.getField("author");
		if (author != null) {
	    	author = author.replaceAll("\\.", ". ");
	    	author = author.replaceAll("  ", " ");
	    	author = author.replaceAll("\\. -", ".-");
	    	author = author.replaceAll("; ", " and ");
	    	author = author.replaceAll("[,;]$", "");
	    	entry.setField("author", author);
		}
		// clean up month
		String month = (String)entry.getField("month");
		if ((month != null) && (month.length() > 0)) {
	    	month = month.replaceAll("\\.", "");
	    	month = month.toLowerCase();
	
	    	Pattern monthPattern = Pattern.compile("(\\d*+)\\s*([a-z]*+)-*(\\d*+)\\s*([a-z]*+)");
	    	Matcher mm = monthPattern.matcher(month);
	    	String date = month;
	    	if (mm.find()) {
	    		if (mm.group(3).length() == 0) {
	    			if (mm.group(2).length() > 0) {
	    				date = "#" + mm.group(2).substring(0, 3) + "#";
	    				if (mm.group(1).length() > 0) {
	    					date += " " + mm.group(1) + ",";
	    				}
	    			} else {
	    				date = mm.group(1) + ",";
	    			}
	    		} else if (mm.group(2).length() == 0) {
	    			if (mm.group(4).length() > 0) {
	    				date = "#" + mm.group(4).substring(0, 3) + "# " + mm.group(1) + "--" + mm.group(3) + ",";
	    			} else
	    				date += ",";
	    		} else {
	    			date = "#" + mm.group(2).substring(0, 3) + "# " + mm.group(1) + "--#" + mm.group(4).substring(0, 3) + "# " + mm.group(3) + ",";
	    		}
	    	}
	    	//date = date.trim();
	    	//if (!date.isEmpty()) {
	    	entry.setField("month", date);
	    	//}
		}
		
		// clean up pages
		String field = "pages";
		String pages = entry.getField(field);
		if (pages != null) {
	    	String [] pageNumbers = pages.split("-");
	    	if (pageNumbers.length == 2) {
	    		if (pageNumbers[0].equals(pageNumbers[1])) {// single page
	    			entry.setField(field, pageNumbers[0]);
	    		} else {
	    			entry.setField(field, pages.replaceAll("-", "--"));
	    		}
	    	}
		}
		
		// clean up publication field
		BibtexEntryType type = entry.getType();
		String sourceField = "";
		if (type.getName() == "Article") {
	    	sourceField = "journal";
			entry.clearField("booktitle");
		} else if (type.getName() == "Inproceedings"){
	        sourceField = "booktitle";
		}
	    String fullName = entry.getField(sourceField);
	    if (fullName != null) {
	        if (type.getName() == "Article") {
	        	int ind = fullName.indexOf(": Accepted for future publication");
				if (ind > 0) {
					fullName = fullName.substring(0, ind);
					entry.setField("year", "to be published");
					entry.clearField("month");
					entry.clearField("pages");
				}
		        String[] parts = fullName.split("[\\[\\]]"); //[see also...], [legacy...]
		        fullName = parts[0];
		        if (parts.length == 3) {
					fullName += parts[2];
				}
	        } else {
	        	fullName = fullName.replace("Conference Proceedings", "Proceedings").
	        			replace("Proceedings of", "Proceedings").replace("Proceedings.", "Proceedings");
	        	fullName = fullName.replaceAll("International", "Int.");
	        	fullName = fullName.replaceAll("Symposium", "Symp.");
	        	fullName = fullName.replaceAll("Conference", "Conf.");
	        	fullName = fullName.replaceAll(" on", " ").replace("  ", " ");
	        }
	        
	        Matcher m1 = publicationPattern.matcher(fullName);
			if (m1.find()) {
				String prefix = m1.group(2).trim();
				String postfix = m1.group(1).trim();
				String abrv = "";
				String[] parts = prefix.split("\\. ", 2);
				if (parts.length == 2) {
					if (parts[0].matches(abrvPattern)) {
						prefix = parts[1];
						abrv = parts[0];
					} else {
						prefix = parts[0];
						abrv = parts[1];
					}
				}
				if (prefix.matches(abrvPattern) == false) {
					fullName = prefix + " " + postfix + " " + abrv;
					fullName = fullName.trim();
				} else {
					fullName = postfix + " " + prefix;
				}
			}
			if (type.getName() == "Article") {
				fullName = fullName.replace("- ", "-"); //IEE Proceedings-
				
				fullName = fullName.trim();
				if (Globals.prefs.getBoolean("useIEEEAbrv")) {
					String id = Globals.journalAbbrev.getAbbreviatedName(fullName, false);
					if (id != null)
						fullName = id;
				}
	        }
			if (type.getName() == "Inproceedings") {
	            Matcher m2 = proceedingPattern.matcher(fullName);
				if (m2.find()) {
					String prefix = m2.group(2); 
					String postfix = m2.group(1).replaceAll("\\.$", "");
					if (prefix.matches(abrvPattern) == false) {
						String abrv = "";
					
						String[] parts = postfix.split("\\. ", 2);
						if (parts.length == 2) {
							if (parts[0].matches(abrvPattern)) {
								postfix = parts[1];
								abrv = parts[0];
							} else {
								postfix = parts[0];
								abrv = parts[1];
							}
						}
						fullName = prefix.trim() + " " + postfix.trim() + " " + abrv;
						
					} else {
						fullName = postfix.trim() + " " + prefix.trim();
					}
					
				}
				
				fullName = fullName.trim();
				
				fullName = fullName.replaceAll("^[tT]he ", "").replaceAll("^\\d{4} ", "").replaceAll("[,.]$", "");
				String year = entry.getField("year");
				fullName = fullName.replaceAll(", " + year + "\\.?", "");
				
	        	if (fullName.contains("Abstract") == false && fullName.contains("Summaries") == false && fullName.contains("Conference Record") == false)
	        		fullName = "Proc. " + fullName;
	        }
			entry.setField(sourceField, fullName);
	    }
		return entry;
	}

	protected void populateFromBibtex(BibtexEntry bibtex) {
		LayoutFormatter chars = new XMLChars();
		if (bibtex.getField("title") != null) {
			if(CHARFORMAT)
				title = chars.format(bibtex.getField("title").toString());
			else
				title = bibtex.getField("title").toString();
		}
		
		if (bibtex.getField("publisher") != null) {
			if(CHARFORMAT)
				publisher = chars.format(bibtex.getField("publisher").toString());
			else
				publisher = bibtex.getField("publisher").toString();
		}
			
		if (bibtex.getField("bibtexkey") != null)
			id = bibtex.getField("bibtexkey").toString();
		if (bibtex.getField("place") != null) {
			if(CHARFORMAT)
				place = chars.format(bibtex.getField("place").toString());
			else
				place = bibtex.getField("place").toString();
		}
			
		date = getDate(bibtex);	
		genre = getMODSgenre(bibtex);
		if (bibtex.getField("author") != null)
			authors = getAuthors(bibtex.getField("author").toString());
		if (bibtex.getType() == BibtexEntryType.ARTICLE || 
			bibtex.getType() == BibtexEntryType.INPROCEEDINGS)
		{
			host = new MODSEntry();
			host.entryType = "relatedItem";
			host.title = bibtex.getField("booktitle");
			host.publisher = bibtex.getField("publisher");
			host.number = bibtex.getField("number");
			if (bibtex.getField("pages") != null)
				host.volume = bibtex.getField("volume");
			host.issuance = "continuing";
			if (bibtex.getField("pages") != null)
				host.pages = new PageNumbers(bibtex.getField("pages"));
		}
		
		populateExtensionFields(bibtex);
		
	}

	// must be from http://www.loc.gov/marc/sourcecode/genre/genrelist.html
	protected String getMODSgenre(BibtexEntry bibtex) {
		String bibtexType = bibtex.getType().getName();
		/**
		 * <pre> String result; if (bibtexType.equals("Mastersthesis")) result =
		 * "theses"; else result = "conference publication"; // etc... </pre>
		 */
		return bibtexType;		
	}

	/**
	 * loop through entry types to get required, optional, general and utility 
	 * fields for this type.
	 */
	public static void refreshFields() {
	
	    if (fields==null) {
	        fields = new ArrayList<String>();
	    } else {
	        fields.clear();
	    }
	
	    for (BibtexEntryType val : BibtexEntryType.ALL_TYPES.values()) {
	        fields = uniqueInsert(fields, val.getRequiredFields());
	        fields = uniqueInsert(fields, val.getOptionalFields());
	        fields = uniqueInsert(fields, val.getGeneralFields());
	        fields = uniqueInsert(fields, val.getUtilityFields());
	    }
	    //fields = uniqueInsert(fields, new String[] {"owner", "timestamp"});
	
	    // create comma separated list of field names
	    fieldstr = "";
	    for (int i = 0; i < fields.size(); i++) {
	        if (i > 0)
	            fieldstr = fieldstr + ", ";
	        fieldstr = fieldstr + fields.get(i);
	    }
	
	}

	/**
	 * Generates the DML required to populate the entry_types table with jabref
	 * data.
	 * 
	 * @param out
	 *          The output (PrintSream or Connection) object to which the DML should be written.
	 */
	private static void dmlPopTab_ET( Object out) throws SQLException{
	
	    String dml = "";
	    String insert = "INSERT INTO entry_types (label, "+fieldstr+") VALUES (";
	
	    ArrayList<String> fieldID = new ArrayList<String>();
	    for (int i = 0; i < fields.size(); i++)
	        fieldID.add(null);
	
	    // loop through entry types
	    for (BibtexEntryType val : BibtexEntryType.ALL_TYPES.values()) {
	
	        // set ID for each field corresponding to its relationship to the
	        // entry type
	        for (int i = 0; i < fieldID.size(); i++) {
	            fieldID.set(i, "");
	        }
	        fieldID = setFieldID(fields, fieldID, val.getRequiredFields(),
	            "req");
	        fieldID = setFieldID(fields, fieldID, val.getOptionalFields(),
	            "opt");
	        fieldID = setFieldID(fields, fieldID, val.getGeneralFields(), "gen");
	        fieldID = setFieldID(fields, fieldID, val.getUtilityFields(), "uti");
	
	        // build DML insert statement
	        dml = insert + "\"" + val.getName().toLowerCase() + "\"";
	        for (int i = 0; i < fieldID.size(); i++) {
	            dml = dml + ", ";
	            if (fieldID.get(i) != "") {
	                dml = dml + "\"" + fieldID.get(i) + "\"";
	            } else {
	                dml = dml + "NULL";
	            }
	        }
	        dml = dml + ");";
	
	        // handle DML according to output type
	        processDML(out, dml);
	
	    }
	
	    return;
	
	}
}
