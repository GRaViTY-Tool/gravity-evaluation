package net.sf.jabref.collab;

import net.sf.jabref.BasePanel;
import net.sf.jabref.BibtexDatabase;
import net.sf.jabref.BibtexString;
import net.sf.jabref.DuplicateCheck;
import net.sf.jabref.EntrySorter;
import net.sf.jabref.MetaData;
import net.sf.jabref.Util;
import net.sf.jabref.collab.ChangeScanner.DisplayResultCallback;
import net.sf.jabref.Globals;
import net.sf.jabref.undo.NamedCompound;

import javax.swing.*;
import java.util.Vector;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;

/**
 * 
 */
public class MetaDataChange extends Change {

    static final int
        ADD = 1,
        REMOVE = 2,
        MODIFY = 3;

    InfoPane tp = new InfoPane();
    JScrollPane sp = new JScrollPane(tp);
    private MetaData md;
    private MetaData mdSecondary;
    ArrayList<MetaDataChangeUnit> changes = new ArrayList<MetaDataChangeUnit>();

    public MetaDataChange(MetaData md, MetaData mdSecondary) {
        super(Globals.lang("Metadata change"));
        this.md = md;
        this.mdSecondary = mdSecondary;

        tp.setText("<html>"+Globals.lang("Metadata change")+"</html>");
    }

    public int getChangeCount() {
        return changes.size();
    }

    public void insertMetaDataAddition(String key, Vector<String> value) {
        changes.add(new MetaDataChangeUnit(ADD, key, value));
    }

    public void insertMetaDataRemoval(String key) {
        changes.add(new MetaDataChangeUnit(REMOVE, key, null));
    }

    public void insertMetaDataChange(String key, Vector<String> value) {
        changes.add(new MetaDataChangeUnit(MODIFY, key, value));
    }

    JComponent description() {
        StringBuilder sb = new StringBuilder("<html>"+Globals.lang("Changes have been made to the following metadata elements")+":<p>");
        for (Iterator<MetaDataChangeUnit> iterator = changes.iterator(); iterator.hasNext();) {
            MetaDataChangeUnit unit = iterator.next();
            sb.append("<br>&nbsp;&nbsp;");
            sb.append(unit.key);
            /*switch (unit.type) {
                case ADD:
                    sb.append("<p>Added: "+unit.key);
                    break;
                case REMOVE:
                    sb.append("<p>Removed: "+unit.key);
                    break;
                case MODIFY:
                    sb.append("<p>Modified: "+unit.key);
                    break;
            }*/
        }
        sb.append("</html>");
        tp.setText(sb.toString());
        return sp;
    }

    public boolean makeChange(BasePanel panel, BibtexDatabase secondary, NamedCompound undoEdit) {
        for (Iterator<MetaDataChangeUnit> iterator = changes.iterator(); iterator.hasNext();) {
            MetaDataChangeUnit unit = iterator.next();
            switch (unit.type) {
                case ADD:
                    md.putData(unit.key, unit.value);
                    mdSecondary.putData(unit.key, unit.value);
                    break;
                case REMOVE:
                    md.remove(unit.key);
                    mdSecondary.remove(unit.key);
                    break;
                case MODIFY:
                    md.putData(unit.key, unit.value);
                    mdSecondary.putData(unit.key, unit.value);
                    break;
            }
        }
        return true;
    }

    public void displayResult(final DisplayResultCallback fup) {
	    if (changes.getChildCount() > 0) {
	        SwingUtilities.invokeLater(new Runnable() {
	            public void run() {
	                ChangeDisplayDialog dial = new ChangeDisplayDialog(frame, panel, inTemp, changes);
	                Util.placeDialog(dial, frame);
	                dial.setVisible(true); // dial.show(); -> deprecated since 1.5
	                fup.scanResultsResolved(dial.isOkPressed());
	                if (dial.isOkPressed()) {
	                    // Overwrite the temp database:
	                    storeTempDatabase();
	                }
	            }
	        });
	
	    } else {
	        JOptionPane.showMessageDialog(frame, Globals.lang("No actual changes found."),
	        Globals.lang("External changes"), JOptionPane.INFORMATION_MESSAGE);
	        fup.scanResultsResolved(true);
	    }
	}

	private void scanPreamble(BibtexDatabase inMem, BibtexDatabase onTmp, BibtexDatabase onDisk) {
	    String mem = inMem.getPreamble(),
	    tmp = onTmp.getPreamble(),
	    disk = onDisk.getPreamble();
	    if (tmp != null) {
	        if ((disk == null) || !tmp.equals(disk))
	            changes.add(new PreambleChange(tmp, mem, disk));
	    }
	    else if ((disk != null) && !disk.equals("")) {
	        changes.add(new PreambleChange(tmp, mem, disk));
	    }
	}

	private void scanEntries(EntrySorter mem, EntrySorter tmp, EntrySorter disk) {
	
	    // Create pointers that are incremented as the entries of each base are used in
	    // successive order from the beginning. Entries "further down" in the "disk" base
	    // can also be matched.
	    int piv1 = 0, piv2 = 0;
	
	    // Create a HashSet where we can put references to entry numbers in the "disk"
	    // database that we have matched. This is to avoid matching them twice.
	    HashSet<String> used = new HashSet<String>(disk.getEntryCount());
	    HashSet<Integer> notMatched = new HashSet<Integer>(tmp.getEntryCount());
	
	    // Loop through the entries of the "tmp" database, looking for exact matches in the "disk" one.
	    // We must finish scanning for exact matches before looking for near matches, to avoid an exact
	    // match being "stolen" from another entry.
	    mainLoop: for (piv1=0; piv1<tmp.getEntryCount(); piv1++) {
	
	        // First check if the similarly placed entry in the other base matches exactly.
	        double comp = -1;
	        // (if there are not any entries left in the "disk" database, comp will stay at -1,
	        // and this entry will be marked as nonmatched).
	        if (!used.contains(""+piv2) && (piv2<disk.getEntryCount())) {
	            comp = DuplicateCheck.compareEntriesStrictly(tmp.getEntryAt(piv1), disk.getEntryAt(piv2));
	        }
	        if (comp > 1) {
	            used.add(""+piv2);
	            piv2++;
	            continue mainLoop;
	        }
	
	        // No? Then check if another entry matches exactly.
	        if (piv2 < disk.getEntryCount()-1) {
	            for (int i = piv2+1; i < disk.getEntryCount(); i++) {
	                if (!used.contains(""+i))
	                    comp = DuplicateCheck.compareEntriesStrictly(tmp.getEntryAt(piv1), disk.getEntryAt(i));
	                else
	                    comp = -1;
	
	                if (comp > 1) {
	                    used.add("" + i);
	                    continue mainLoop;
	                }
	            }
	        }
	
	        // No? Add this entry to the list of nonmatched entries.
	        notMatched.add(new Integer(piv1));
	    }
	
	
	    // Now we've found all exact matches, look through the remaining entries, looking
	    // for close matches.
	    if (notMatched.size() > 0) {
	
	        for (Iterator<Integer> it=notMatched.iterator(); it.hasNext();) {
	
	            Integer integ = it.next();
	            piv1 = integ.intValue();
	
	
	            // These two variables will keep track of which entry most closely matches the
	            // one we're looking at, in case none matches completely.
	            int bestMatchI = -1;
	            double bestMatch = 0;
	            double comp = -1;
	
	            if (piv2 < disk.getEntryCount()-1) {
	                for (int i = piv2; i < disk.getEntryCount(); i++) {
	                    if (!used.contains(""+i)) {
	                        comp = DuplicateCheck.compareEntriesStrictly(tmp.getEntryAt(piv1),
	                        disk.getEntryAt(i));
	                    }
	                    else
	                        comp = -1;
	
	                    if (comp > bestMatch) {
	                        bestMatch = comp;
	                        bestMatchI = i;
	                    }
	                }
	            }
	
	            if (bestMatch > MATCH_THRESHOLD) {
	                used.add(""+bestMatchI);
	                it.remove();
	
	                EntryChange ec = new EntryChange(bestFit(tmp, mem, piv1), tmp.getEntryAt(piv1),
	                disk.getEntryAt(bestMatchI));
	                changes.add(ec);
	
	                // Create an undo edit to represent this change:
	                //NamedCompound ce = new NamedCompound("Modified entry");
	                //ce.addEdit(new UndoableRemoveEntry(inMem, disk.getEntryAt(bestMatchI), panel));
	                //ce.addEdit(new UndoableInsertEntry(inMem, tmp.getEntryAt(piv1), panel));
	                //ce.end();
	                //changes.add(ce);
	
	                //System.out.println("Possible match for entry:");
	                //System.out.println("----------------------------------------------");
	
	            }
	            else {
	                EntryDeleteChange ec = new EntryDeleteChange(bestFit(tmp, mem, piv1), tmp.getEntryAt(piv1));
	                changes.add(ec);
	      /*NamedCompound ce = new NamedCompound("Removed entry");
	      ce.addEdit(new UndoableInsertEntry(inMem, tmp.getEntryAt(piv1), panel));
	      ce.end();
	      changes.add(ce);*/
	
	            }
	
	        }
	
	    }
	
	    // Finally, look if there are still untouched entries in the disk database. These
	    // mayhave been added.
	    if (used.size() < disk.getEntryCount()) {
	        for (int i=0; i<disk.getEntryCount(); i++) {
	            if (!used.contains(""+i)) {
	
	                // See if there is an identical dupe in the mem database:
	                boolean hasAlready = false;
	                for (int j = 0; j < mem.getEntryCount(); j++) {
	                    if (DuplicateCheck.compareEntriesStrictly(mem.getEntryAt(j),
	                        disk.getEntryAt(i)) >= 1) {
	                        hasAlready = true;
	                        break;
	                    }
	                }
	                if (!hasAlready) {
	                    EntryAddChange ec = new EntryAddChange(disk.getEntryAt(i));
	                    changes.add(ec);
	                }
	      /*NamedCompound ce = new NamedCompound("Added entry");
	      ce.addEdit(new UndoableRemoveEntry(inMem, disk.getEntryAt(i), panel));
	      ce.end();
	      changes.add(ce);*/
	            }
	        }
	        //System.out.println("Suspected new entries in file: "+(disk.getEntryCount()-used.size()));
	    }
	}

	private void scanMetaData(MetaData inMem, MetaData inTemp, MetaData onDisk) {
	    MetaDataChange mdc = new MetaDataChange(inMem, inTemp);
	    ArrayList<String> handledOnDisk = new ArrayList<String>();
	    // Loop through the metadata entries of the "tmp" database, looking for
	    // matches
	    for (Iterator i = inTemp.iterator(); i.hasNext();) {
	        String key = (String)i.next();
	        // See if the key is missing in the disk database:
	        Vector<String> vod = onDisk.getData(key);
	        if (vod == null) {
	            mdc.insertMetaDataRemoval(key);
	        }
	        else {
	            // Both exist. Check if they are different:
	            Vector<String> vit = inTemp.getData(key);
	            if (!vod.equals(vit))
	                mdc.insertMetaDataChange(key, vod);
	            // Remember that we've handled this one:
	            handledOnDisk.add(key);
	        }
	    }
	
	    // See if there are unhandled keys in the disk database:
	    for (Iterator i = onDisk.iterator(); i.hasNext();) {
	        String key = (String)i.next();
	        if (!handledOnDisk.contains(key)) {
	            mdc.insertMetaDataAddition(key, onDisk.getData(key));
	        }
	    }
	
	    if (mdc.getChangeCount() > 0)
	        changes.add(mdc);
	}

	private void scanStrings(BibtexDatabase inMem, BibtexDatabase onTmp, BibtexDatabase onDisk) {
	    int nTmp = onTmp.getStringCount(),
	    nDisk = onDisk.getStringCount();
	    if ((nTmp == 0) && (nDisk == 0))
	        return;
	
	    HashSet<Object> used = new HashSet<Object>();
	    HashSet<Object> usedInMem = new HashSet<Object>();
	    HashSet<String> notMatched = new HashSet<String>(onTmp.getStringCount());
	
	    // First try to match by string names.
	    //int piv2 = -1;
	    mainLoop: for (String key : onTmp.getStringKeySet()){
	        BibtexString tmp = onTmp.getString(key);
	
	        //      for (int j=piv2+1; j<nDisk; j++)
	        for (String diskId : onDisk.getStringKeySet()){
	            if (!used.contains(diskId)) {
	                BibtexString disk = onDisk.getString(diskId);
	                if (disk.getName().equals(tmp.getName())) {
	                    // We have found a string with a matching name.
	                    if ((tmp.getContent() != null) && !tmp.getContent().equals(disk.getContent())) {
	                        // But they have nonmatching contents, so we've found a change.
	                        BibtexString mem = findString(inMem, tmp.getName(), usedInMem);
	                        if (mem != null)
	                            changes.add(new StringChange(mem, tmp, tmp.getName(),
	                            mem.getContent(),
	                            tmp.getContent(), disk.getContent()));
	                        else
	                            changes.add(new StringChange(null, tmp, tmp.getName(), null, tmp.getContent(), disk.getContent()));
	                    }
	                    used.add(diskId);
	                    //if (j==piv2)
	                    //  piv2++;
	                    continue mainLoop;
	                }
	
	            }
	        }
	        // If we get here, there was no match for this string.
	        notMatched.add(tmp.getId());
	    }
	
	    // See if we can detect a name change for those entries that we couldn't match.
	    if (notMatched.size() > 0) {
	        for (Iterator<String> i = notMatched.iterator(); i.hasNext();){
	            BibtexString tmp = onTmp.getString(i.next());
	
	            // If we get to this point, we found no string with matching name. See if we
	            // can find one with matching content.
	            for (String diskId : onDisk.getStringKeySet()){
	
	            	if (!used.contains(diskId)) {
	                    BibtexString disk = onDisk.getString(diskId);
	
	                    if (disk.getContent().equals(tmp.getContent())) {
	                        // We have found a string with the same content. It cannot have the same
	                        // name, or we would have found it above.
	
	                        // Try to find the matching one in memory:
	                        BibtexString bsMem = null;
	                        
	                        for (String memId : inMem.getStringKeySet()){
	                            BibtexString bsMem_cand = inMem.getString(memId);
	                            if (bsMem_cand.getContent().equals(disk.getContent()) &&
	                            !usedInMem.contains(memId)) {
	                                usedInMem.add(memId);
	                                bsMem = bsMem_cand;
	                                break;
	                            }
	                        }
	
	                        changes.add(new StringNameChange(bsMem, tmp, bsMem.getName(),
	                        tmp.getName(), disk.getName(),
	                        tmp.getContent()));
	                        i.remove();
	                        used.add(diskId);
	
	                    }
	                }
	            }
	        }
	    }
	
	    if (notMatched.size() > 0) {
	        // Still one or more non-matched strings. So they must have been removed.
	        for (Iterator<String> i = notMatched.iterator(); i.hasNext(); ) {
	            String nmId = i.next();
	            BibtexString tmp = onTmp.getString(nmId);
	            BibtexString mem = findString(inMem, tmp.getName(), usedInMem);
	            if (mem != null) { // The removed string is not removed from the mem version.
	                changes.add(new StringRemoveChange(tmp, tmp, mem));
	            }
	        }
	    }
	
	
	    // Finally, see if there are remaining strings in the disk database. They
	    // must have been added.
	    for (Iterator<String> i=onDisk.getStringKeySet().iterator(); i.hasNext();) {
	        String diskId = i.next();
	        if (!used.contains(diskId)) {
	            BibtexString disk = onDisk.getString(diskId);
	            //System.out.println(disk.getName());
	            used.add(diskId);
	            changes.add(new StringAddChange(disk));
	        }
	    }
	}

	class MetaDataChangeUnit {
        int type;
        String key;
        Vector<String> value;

        public MetaDataChangeUnit(int type, String key, Vector<String> value) {
            this.type = type;
            this.key = key;
            this.value = value;
        }
    }
}
