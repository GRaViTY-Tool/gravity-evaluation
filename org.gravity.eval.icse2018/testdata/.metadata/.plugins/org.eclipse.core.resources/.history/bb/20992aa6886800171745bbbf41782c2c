/* Generated By:JJTree: Do not edit this line. ASTClassOrInterfaceDeclaration.java */

package net.sourceforge.pmd.ast;

import java.util.List;

public class ASTClassOrInterfaceDeclaration extends AccessNode {
    public ASTClassOrInterfaceDeclaration(int id) {
        super(id);
    }

    public ASTClassOrInterfaceDeclaration(JavaParser p, int id) {
        super(p, id);
    }

    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(JavaParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    public boolean isNested() {
        return jjtGetParent() instanceof ASTClassOrInterfaceBodyDeclaration;
    }

    private boolean isInterface;

    public boolean isInterface() {
        return this.isInterface;
    }

    public void setInterface() {
        this.isInterface = true;
    }

    public void dump(String prefix) {
        String interfaceStr = isInterface ? "interface" : "class";
        String innerStr = isNested() ? "(nested)" : "";
        System.out.println(toString(prefix) + "(" + getImage() + ")(" + interfaceStr + ")" + innerStr);
        dumpChildren(prefix);
    }

	private Object checkNames(ASTFieldDeclaration node, Object data) {
	    ASTType childNodeType = (ASTType) node.jjtGetChild(0);
	    String varType = "";
	    if (childNodeType.jjtGetChild(0) instanceof ASTName) {
	        varType = ((ASTName) childNodeType.jjtGetChild(0)).getImage();
	    } else if (childNodeType.jjtGetChild(0) instanceof ASTPrimitiveType) {
	        varType = ((ASTPrimitiveType) childNodeType.jjtGetChild(0)).getImage();
	    }
	    if (varType != null && varType.length() > 0) {
	        //Get the variable name
	        ASTVariableDeclarator childNodeName = (ASTVariableDeclarator) node.jjtGetChild(1);
	        ASTVariableDeclaratorId childNodeId = (ASTVariableDeclaratorId) childNodeName.jjtGetChild(0);
	        String varName = childNodeId.getImage();
	
	        if (varName.equals("serialVersionUID") || (node.isFinal() && !node.isStatic() && !node.isInterfaceMember())) {
	            return data;
	        }
	
	        // static finals (and interface fields, which are implicitly static and final) are
	        // checked for uppercase
	        if ((node.isStatic() && node.isFinal()) || (node.jjtGetParent().jjtGetParent().jjtGetParent() instanceof ASTClassOrInterfaceDeclaration && ((ASTClassOrInterfaceDeclaration) node.jjtGetParent().jjtGetParent().jjtGetParent()).isInterface())) {
	            if (!varName.equals(varName.toUpperCase())) {
	                addViolationWithMessage(data, childNodeName, "Variables that are final and static should be in all caps.");
	            }
	            return data;
	        }
	
	        String strippedVarName = null;
	        if (node.isStatic()) {
	            strippedVarName = normalizeStaticVariableName(varName);
	        } else {
	            strippedVarName = normalizeMemberVariableName(varName);
	        }
	
	        if (strippedVarName.indexOf('_') >= 0) {
	            addViolationWithMessage(data, childNodeName, "Variables that are not final should not contain underscores (except for underscores in standard prefix/suffix).");
	        }
	        if (Character.isUpperCase(varName.charAt(0))) {
	            addViolationWithMessage(data, childNodeName, "Variables should start with a lowercase character");
	        }
	    }
	    return data;
	}

	public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
	
	    if ( !node.isNested() ) {
	      return super.visit( node, data );
	    }
	
	    return countNodeChildren( node, data );
	  }

	public Object visit(ASTEnumDeclaration node, Object data) {
	    /*
	     * If the enum is a type in and of itself, don't count its declaration
	     * twice.
	     */
	    if ( node.jjtGetParent() instanceof ASTTypeDeclaration ) {
	      Integer nodeCount = countNodeChildren( node, data );
	      int count = nodeCount.intValue() - 1;
	      return new Integer( count );
	    }
	    return countNodeChildren( node, data );
	  }

	public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
	    if (node.isInterface()) {
	        return data;
	    }
	    return super.visit(node, data);
	}

	private void lclFindChildrenOfType(Node node, Class targetType, List results) {
	    if (node.getClass().equals(targetType)) {
	        results.add(node);
	    }
	
	    if (node instanceof ASTClassOrInterfaceDeclaration && ((ASTClassOrInterfaceDeclaration) node).isNested()) {
	        return;
	    }
	
	    if (node instanceof ASTClassOrInterfaceBodyDeclaration && ((ASTClassOrInterfaceBodyDeclaration) node).isAnonymousInnerClass()) {
	        return;
	    }
	
	    for (int i = 0; i < node.jjtGetNumChildren(); i++) {
	        Node child = node.jjtGetChild(i);
	        if (child.getClass().equals(targetType)) {
	            results.add(child);
	        }
	    }
	}

	public Object visit(ASTClassOrInterfaceDeclaration clz, Object data) {
	    if (clz.isInterface()) {
	        return data;
	    }
	    return super.visit(clz, data);
	}

	/**
	 * This check must be evaluated independelty for each class.  Inner classses
	 * get their own EvalPackage in order to perform independent evaluation.
	 */
	public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
	    if (!node.isInterface()) {
	        return visitClassDec(node, data);
	    } else {
	        putEvalPackage(nullEvalPackage);
	        Object o = super.visit(node, data);//interface may have inner classes, possible? if not just skip whole interface
	        removeCurrentEvalPackage();
	        return o;
	    }
	}

	public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
	    if (node.isInterface()) {
	        return data;
	    }
	    return super.visit(node, data);
	}

}
