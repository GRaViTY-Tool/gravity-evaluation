/***************************************************************************
                           GanttTask.java  -  description
                             -------------------
    begin                : dec 2002
    copyright            : (C) 2002 by Thomas Alexandre
    email                : alexthomas(at)ganttproject.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

package net.sourceforge.ganttproject;

import net.sourceforge.ganttproject.GanttGraphicArea.Arrow;
import net.sourceforge.ganttproject.GanttGraphicArea.GanttPaintParam;
import net.sourceforge.ganttproject.GanttGraphicArea.Notes;
import net.sourceforge.ganttproject.resource.HumanResource;
import net.sourceforge.ganttproject.roles.Role;
import net.sourceforge.ganttproject.shape.ShapeConstants;
import net.sourceforge.ganttproject.shape.ShapePaint;
import net.sourceforge.ganttproject.task.ResourceAssignment;
import net.sourceforge.ganttproject.task.Task;
import net.sourceforge.ganttproject.task.TaskImpl;
import net.sourceforge.ganttproject.task.TaskManager;
import net.sourceforge.ganttproject.task.TaskMutator;
import net.sourceforge.ganttproject.task.dependency.TaskDependency;
import net.sourceforge.ganttproject.time.TimeUnit;
import net.sourceforge.ganttproject.time.TimeUnitManager;
import net.sourceforge.ganttproject.util.ColorConvertion;

import java.awt.Color;
import java.awt.Graphics;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Serializable;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Vector;

import javax.swing.tree.DefaultMutableTreeNode;

/**
 * Class that generate a task
 */

public class GanttTask extends TaskImpl

    implements Serializable {

  public static int LOW = 0;

  public static int NORMAL = 1;

  public static int HIGHT = 2;


/////////////////////////////////////////////////////////////////////////////////

  /** Constructor */

  public GanttTask(String name, GanttCalendar start, long length, TaskManager taskManager) {
      super(taskManager);
      TimeUnitManager timeManager = getTimeUnitManager();
      TaskMutator mutator = createMutator();
      mutator.setName(name);
      mutator.setStart(start);
      mutator.setDuration(taskManager.createLength(timeManager.getTimeUnit(TimeUnit.DAY), length));
      mutator.commit();
      enableEvents(true);
  }


    private GanttTask(GanttTask copy) {
        super(copy);
//        for (int i = 0; i < getPredecessorsOld().size(); i++) {
//          GanttTaskRelationship tempRel = (GanttTaskRelationship) ( (
//              GanttTaskRelationship) getPredecessorsOld().get(i)).clone();
//          addPredecessor(tempRel);
//        }

//        for (int i = 0; i < successors.size(); i++) {
//          GanttTaskRelationship tempRel = (GanttTaskRelationship) ( (
//              GanttTaskRelationship) successors.get(i)).clone();
//          addSuccessor(tempRel);
//        }
        enableEvents(true);

    }


  /**
   * @return a clone of the Task
   */
  public GanttTask Clone() {
      return new GanttTask(this);
  }

  /** Return the name. */
  public String toString() {
    return getName();
    //return getName();
  }

  /** Return the shape of the task */


  /** Return the duration */

  public int getLength() {

    return (int) getDuration().getLength();

  }


  /** Change the duration */
  public void setLength(int l) {
      TaskMutator mutator = createMutator();
      mutator.setDuration(getManager().createLength(getDuration().getTimeUnit(), l));
      mutator.commit();
  }



  /**whether the time relationship between this task and other has been checked. property will be used in scheduling check*/

  private boolean checked = false;


  public Vector getPredecessorsOld() {
      TaskDependency[] deps = getDependenciesAsDependant().toArray();
      Vector result = new Vector(deps.length);
      for (int i=0; i<deps.length; i++) {
          TaskDependency next = deps[i];
          GanttTaskRelationship rel = new GanttTaskRelationship(next.getDependee().getTaskID(), getTaskID(), next.getConstraint().getID(), getManager());
          result.add(rel);
      }
    return result;
  }

    public Vector getSuccessorsOld() {
        TaskDependency[] deps = getDependenciesAsDependee().toArray();
        Vector result = new Vector(deps.length);
        for (int i=0; i<deps.length; i++) {
            TaskDependency next = deps[i];
            GanttTaskRelationship rel = new GanttTaskRelationship(getTaskID(), next.getDependant().getTaskID(), next.getConstraint().getID(), getManager());
            result.add(rel);
        }
        return result;
    }


  /** Unlink the task from all relationship */
  public void unlink () {
      getDependencies().clear();

  }
  
  /**return true if the realtionship between this task and others has been checked*/

  public boolean isChecked() {

    return checked;

  }

  /**set the checked state of task: true if the relationship has been check. or else, false*/

  public void setChecked(boolean checked) {

    this.checked = checked;

  }

  /**
       *set the task ID. the uniquness of ID should be check before using this method
   * @param taskID
   */
  public void setTaskID(int taskID) {
      setTaskIDHack(taskID);
  }


/** Write all tasks. */
	private void writeTasks(OutputStreamWriter out) throws IOException 
	{
//		parse all tasks	
	    for(Iterator it=lot.iterator(); it.hasNext();)
		{
			DefaultMutableTreeNode node = (DefaultMutableTreeNode) it.next();
			if(!node.isRoot())
			{
				GanttTask task = (GanttTask)(node.getUserObject());
				
				//ID
				if(csvOptions.bExportTaskID)
					out.write(correctField(""+task.getTaskID())+
							(bFixedSize?"":csvOptions.sSeparatedChar));
					
				//Name
				if(csvOptions.bExportTaskName)
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar)+
							correctField(getName(node, task))+
							(bFixedSize?"":csvOptions.sSeparatedTextChar+
							csvOptions.sSeparatedChar));
				
				//Start Date
				if(csvOptions.bExportTaskStartDate)
					out.write(correctField(task.getStart().toString())+
							(bFixedSize?"":csvOptions.sSeparatedChar));
				
				//End Date
				if(csvOptions.bExportTaskEndDate)
					out.write(correctField(task.getEnd().toString())+
							(bFixedSize?"":csvOptions.sSeparatedChar));
				
				//Duration
				if(csvOptions.bExportTaskDuration)
					out.write(correctField(""+task.getLength())+
							(bFixedSize?"":csvOptions.sSeparatedChar));
				
				//Percent complete
				if(csvOptions.bExportTaskPercent)
					out.write(correctField(""+task.getCompletionPercentage())+
							(bFixedSize?"":csvOptions.sSeparatedChar));				

				//Web Link
				if(csvOptions.bExportTaskWebLink)
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar)+
							correctField(getWebLink(task))+
							(bFixedSize?"":csvOptions.sSeparatedTextChar+
							csvOptions.sSeparatedChar));				
				
				//associated resources
				if(csvOptions.bExportTaskResources) {
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar));					
					out.write(correctField(getAssignments(task)));					
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar+
							csvOptions.sSeparatedChar));
				}
				
				//Notes
				if(csvOptions.bExportTaskNotes)
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar)+
							correctField(task.getNotes())+
							(bFixedSize?"":csvOptions.sSeparatedTextChar+
							csvOptions.sSeparatedChar));
				
				out.write("\n");
			}
		}	    
	} //end of write tasks


/**set the maximum size for all strings. */
void getMaxSize()
{
	iMaxSize = 0;
	for(Iterator it=lot.iterator(); it.hasNext();)
    {
		DefaultMutableTreeNode node = (DefaultMutableTreeNode) it.next();
		if(!node.isRoot())
		{
			GanttTask task = (GanttTask)(node.getUserObject());

			if(csvOptions.bExportTaskID){
				String s=""+task.getTaskID();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskName){
				String s=""+getName(node, task);
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskStartDate){
				String s=""+task.getStart();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskEndDate){
				String s=""+task.getEnd();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskDuration){
				String s=""+task.getLength();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskPercent){
				String s=""+task.getCompletionPercentage();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskWebLink){
				String s=""+getWebLink(task);
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskResources){
				String s=""+getAssignments(task);
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskNotes){
				String s=""+task.getNotes();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}	
			
		}
    }
	
	//parse all resources
	for (int i = 0; i < resources.size(); i++)
	{
	   	HumanResource p = (HumanResource) resources.get(i);
	   	
	   	if(csvOptions.bExportResourceID){
			String s=""+p.getId();
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	   	if(csvOptions.bExportResourceName){
			String s=""+p.getName();
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	   	if(csvOptions.bExportResourceMail){
			String s=""+p.getMail();
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	   	if(csvOptions.bExportResourcePhone){
			String s=""+p.getPhone();
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	   	if(csvOptions.bExportResourceRole){
	   		Role role = p.getRole();
	        String sRoleID = "0";
	        if(role != null) sRoleID = role.getPersistentID();
			String s=""+sRoleID;
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	}
	
} //get maxIndentation end


/**@return the link of the task. */
private String getWebLink(GanttTask task)
{
	return (task.getWebLink().equals("http://")?"":task.getWebLink());
}


/**@return the name of task with the correct level.*/
private String getName(DefaultMutableTreeNode node, GanttTask task)
{
	if(bFixedSize) return task.getName();
	String res="";
	for(int i=0;i<node.getLevel();i++)
		res+="  ";
	return res+task.getName();
}


/** @return the list of the assignment for the resources. */
private String getAssignments(GanttTask task)
{
	String res = "";
	ResourceAssignment[] assignment = task.getAssignments();
	for(int i=0;i<assignment.length;i++)
		res+=(assignment[i].getResource()+(i==assignment.length-1?"":
				csvOptions.sSeparatedChar.equals(";")?",":";"));
	return res;
}


/** Simple write information of tasks */
  public void writeTask(Writer fout, DefaultMutableTreeNode node, String space) {
    String space2 = s + space;
    try {
      
      GanttTask task = (GanttTask)node.getUserObject();
      
      if(task.getTaskID()==-1) throw new RuntimeException("A task can not has a number equal to -1");
      
      
      int id=task.getTaskID();
      
      /*if (id >= lot.size()) {
        return;
      }*/
      
      
      boolean haschild = false;

      ArrayList child = tree.getAllChildTask(node);
      if (child.size() != 0) {
        haschild = true;

      }

      number.add(new Integer(id));
      cpt++;

//      boolean one = (task.getSuccessorsOld().size() != 0 || (task.getNotes() != null && task.getNotes().length()>=0) ||
//                     haschild);
	
	boolean one = (task.getSuccessorsOld().size()==0 && (task.getNotes() == null || task.getNotes().length()==0) && !haschild);


      //Writes data of task
      fout.write(space + "<task id=\"" + task.getTaskID() + //lots.indexOf(task.toString()) + //By CL
                 "\" ");
      fout.write("name=\"" + correct(task.getName()) + "\" ");

      if (task.colorDefined()) {
        /*fout.write("color=\"#");
        if (task.getColor().getRed() <= 15) {
          fout.write("0");
        }
        fout.write(Integer.toHexString(task.getColor().getRed()));
        if (task.getColor().getGreen() <= 15) {
          fout.write("0");
        }
        fout.write(Integer.toHexString(task.getColor().getGreen()));
        if (task.getColor().getBlue() <= 15) {
          fout.write("0");
        }
        fout.write(Integer.toHexString(task.getColor().getBlue()));
        fout.write("\" ");*/
		fout.write("color=\""+ColorConvertion.getColor(task.getColor())+"\" ");
      }

      if (task.shapeDefined() && 
      		task.getShape() != new ShapePaint(ShapeConstants.BACKSLASH, 
      				task.getColor() , task.getColor())) {
	  fout.write("shape=\"" + task.getShape().getArray()+ "\" ");
      }

      fout.write("meeting=\"" + ( (task.isMilestone()) ? "true" : "false") +
                 "\" ");
      fout.write("start=\"" + task.getStart().toXMLString() + "\" ");
      fout.write("duration=\"" + task.getLength() + "\" ");
      fout.write("complete=\"" + task.getCompletionPercentage() + "\" ");
        fout.write("fixed-start=\"" + (task.isStartFixed() ? "true" : "false") + "\" ");
      fout.write("priority=\"" + task.getPriority() + "\"");
      
      //write the web link of the task
      String sWebLink = task.getWebLink();
      if(sWebLink != null && !sWebLink.equals("") && !sWebLink.equals("http://"))
      	fout.write(" webLink=\"" + sWebLink + "\"");
      
      //write if the task is expand or collapse      
      fout.write(" expand=\"" + task.getExpand() + "\"");
	  	
      if (!one) {
        fout.write(">\n");
      }
      else {
        fout.write("/>\n");
        //fout.writeBytes(">\n");

        //Write notes
      }
      if (task.getNotes() != null && task.getNotes().length()>0) {
        fout.write(space2 + "<notes>");
        fout.write("\n" + space2 + s + correct(replaceAll(task.getNotes(), "\n", "\n" + space2 + s)));
        fout.write("\n" + space2 + "</notes>\n");
      }

      //Write the depends of the task
      /*
      if (task.getDepend().size() != 0) {
        //fout.writeBytes(space2+"<depends>\n");
        for (int i = 0; i < task.getDepend().size(); i++) {
          fout.write(space2 + "<depend id=\"" +
                     tree.getTask( (String) task.getDepend().get(i)).getTaskID() + // changed By CL
                     //lots.indexOf( (String) task.getDepend().get(i)) +
                     "\"/>\n");
          //fout.writeBytes(space2+"</depends>\n");
        }
      }*/

      //use successors to write depends information
      Vector successors = task.getSuccessorsOld();
      for (int i = 0; i < successors.size(); i++) {
        GanttTaskRelationship relationship
            = (GanttTaskRelationship) successors.get(i);
        fout.write(space2 /*+s*/ + "<depend id=\"" +
                   relationship.getSuccessorTaskID()+"\""
                   +" type=\""
                   +relationship.getRelationshipType()
                   +"\"/>\n");
      }

      //Write the child of the task
      if (haschild) {
        for (int i = 0; i < child.size(); i++) {
          Task task2 = (Task) ( (DefaultMutableTreeNode) child.get(i)).
              getUserObject();
          int newid = -1; //lot.lastIndexOf(task2);

          for (int j = 0; j < lot.size(); j++) {
            String a = task2.toString();
            String b = lot.get(j).toString();

            if (a.equals(b)) {
              newid = j;
            }
          }
          writeTask(fout, (DefaultMutableTreeNode)child.get(i), space + s);
        }

      }

      //end of task section
      if (!one) {
        fout.write(space + "</task>\n");
        //fout.writeBytes(space+"</task>\n");

      }
      //      if (tree.getNode(task.toString()).isLeaf() &&
      //          !tree.getFatherNode(task).isRoot()) {
      //        return;
      //      }

      //      if (id == lot.size() - 1) {
      //        return;
      //      }
      //      else {
      //        writeTask(fout, cpt, space);
      //
      //      }

    }
    catch (Exception e) {
      System.out.println(e);
    }
  }


/** Draw a normal task */
  public void paintATaskChild(Graphics g, int x1, int x2, int y, Task task) {
    int d = y;
    y = y * 20 + 27 - margY;

    if (y < 20 || y > getHeight()) {
      return; //Not draw if the task is not on the area
    }
    if ( (x1 > getWidth() && x2 > getWidth()) || (x1 < 0 && x2 < 0)) {
      return;
    }

    //Blue rectangle
      Color c = ((GanttTask)task).colorDefined() ? task.getColor() :myUIConfiguration.getTaskColor();
    g.setColor(c);
    g.fillRect(x1, y, (x2 - x1 - 1), 12);

    //Draw nice border
    //if(draw3dBorders)
    {	
    	if (drag == d - 1) {
    		g.setColor(arrayColor[0]);
    	}
    	else {
    		g.setColor(Color.black);
    	}
    	g.drawRect(x1, y, x2 - x1 - 1, 12);
    	
    	//AT
    	//This code print a gray border around the task
    	//BTW I've comment it for several reason
    	//- It' increase the time of rendering
    	//- when printing the char, this border isn't good
    	//- for the rendering, it's only beautiful with the default color, but not with another one
    	//- finally I found it nicer now :)
    	/*g.setColor(arrayColor[7]);
    	g.drawLine(x1 + 1, y + 1, (x2 - 1) - 1, y + 1);
    	g.drawLine(x1 + 1, y + 1, x1 + 1, y + 11);
    	
    	g.setColor(arrayColor[8]);
    	g.drawLine(x1 + 2, y + 11, (x2 - 1) - 2, y + 11);
    	g.drawLine(x2 - 2, y + 2, x2 - 2, y + 11);*/
  	}
    
	//Draw the resource list after the task
	paintResources (x2+40, y+10, task, g);

  }


/** Paint all tasks  */
  public void paintTasks(Graphics g) {
      int sizex = getWidth();
      int sizey = getHeight();
      int headery = 45;
      float fgra = (float) sizex / (float) getGranit(true);

      g.setFont(myUIConfiguration.getChartMainFont());

      //Get all task

      //Probably optimised on next release
      listOfParam.clear();

      int y = 0;

      for (Iterator tasks = listOfTask.iterator(); tasks.hasNext();) {
          DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode) tasks.next();
          GanttTask task = (GanttTask) treeNode.getUserObject();

//Is the task is visible, the task could be draw
          if (isVisible(task)) {
              int x1 = -10, x2 = sizex + 10;
              int e1; //ecart entre la date de debut de la tache et la date du debut du calendrier
              int fois;
              int type = 2;
              y++;

//difference between the start date of the task and the end
              e1 = date.diff(task.getStart());

//Calcul start and end pixel of each task
              float fx1, fx2;

              if (task.isMilestone()) {
                  fx1 = (float) e1 * fgra *
                          ((date.compareTo(task.getStart()) == 1) ? -1 : 1);
                  x1 = (int) fx1;
              } else {
                  fx1 = (float) e1 * fgra *
                          ((date.compareTo(task.getStart()) == 1) ? -1 : 1);
                  fx2 = fx1 + (float) task.getLength() * fgra;
                  x1 = (int) fx1;
                  x2 = (int) fx2;
              }

              int percent = 0;

//Meeting task
              if (task.isMilestone()) {
                  paintATaskBilan(g, x1, y, task);
                  x2 = x1 + (int) fgra;
                  type = 0;
              }
//A mother task
              else if (tree.getAllChildTask(treeNode).size() != 0) {

                  //Compute percent-complete
                  tree.computePercentComplete(treeNode);

                  paintATaskFather(g, x1, x2, y, task);
                  if (drawPercent) {
                      percent = paintAdvancement(g, x1, x2, y, task.getCompletionPercentage(), task.getShape(),
                              task.getColor(), true);
                  }
                  type = 1;
              }
//A normal task
              else {
                  paintATaskChild(g, x1, x2, y, task);
                  if (drawPercent) {

                      percent = paintAdvancement(g, x1, x2, y, task.getCompletionPercentage(), task.getShape(),
                              task.getColor(), false);
                  }
                  type = 2;
              }

//Add parameters on the array
              listOfParam.add(new GanttPaintParam(task.getName(), task.getTaskID(),
                      x1, x2, percent, y, type));
          }
      }

  }


/** Draw the arrows for depends */
  public void paintDepend(Graphics g) {
  
  
  	//for paint triangles
    int xPoints[] = new int[3];
    int yPoints[] = new int[3];
	
  
  	//Set the color to black
     g.setColor(Color.black);
	
	//Parsing all tasks
	for(Iterator tasks=listOfTask.iterator(); tasks.hasNext(); ) {
		//Get the task
		GanttTask task = (GanttTask)(((DefaultMutableTreeNode)tasks.next()).getUserObject());
		//Only if the task is visible
		if(isVisible(task)) {
			//Get all sucessors for the task
			Vector successors = task.getSuccessorsOld();
			//Parsing the sucessors
			for(Iterator suc=successors.iterator(); suc.hasNext();){
				//Get the relashionship
				GanttTaskRelationship relationship = (GanttTaskRelationship)suc.next();
				//Get the second task
				Task task2 = relationship.getSuccessorTask();
				//Only if the second task is visible
				if (this.isVisible(task2)) {
					//Get the start index and end index for param values
          int index1 = this.indexOf(listOfParam, task.getTaskID());
          int index2 = this.indexOf(listOfParam, task2.getTaskID());
					
					//System.out.println(task+"  "+task2+"  "+index1+" "+index2);
					try{
					//Y coords
					int yt1 = ( (GanttPaintParam) listOfParam.get(index1)).y;
          int yt2 = ( (GanttPaintParam) listOfParam.get(index2)).y;
					yt1 = yt1 * 20 + 32 - margY;
					yt2 = yt2 * 20 + 32 - margY;
					
					//Start-Start relashion
					if(relationship.getRelationshipType()==GanttTaskRelationship.SS) {
						//Get x coord
						int x1t1 = ( (GanttPaintParam) listOfParam.get(index1)).x1;
						int x1t2 = ( (GanttPaintParam) listOfParam.get(index2)).x1;
						
						int xa=(x1t1<x1t2)?x1t1-7:x1t2-7;
						
						//Draw Lines
						g.drawLine(x1t1, yt1, xa, yt1);
			            g.drawLine(xa, yt1, xa, yt2);
						g.drawLine(xa, yt2, x1t2, yt2);
						
						//Traiangle for task 1
						/*x1t1--;
						xPoints[0] = x1t1;
              			xPoints[1] = x1t1 - 3;
			            xPoints[2] = x1t1 - 3;
						yPoints[0] = yt1;
						yPoints[1] = yt1 - 4;
						yPoints[2] = yt1 + 4;
						g.fillPolygon(xPoints, yPoints, 3);*/
						//Traiangle for task 2
						x1t2--;
						xPoints[0] = x1t2;
              			xPoints[1] = x1t2 - 3;
			            xPoints[2] = x1t2 - 3;
						yPoints[0] = yt2;
						yPoints[1] = yt2 - 4;
						yPoints[2] = yt2 + 4;
						g.fillPolygon(xPoints, yPoints, 3);
					
					//Finish-Start relashion
					} else if(relationship.getRelationshipType()==GanttTaskRelationship.FS) {
						//Get x coord
						int x2t1 = ( (GanttPaintParam) listOfParam.get(index1)).x2;
						int x1t2 = ( (GanttPaintParam) listOfParam.get(index2)).x1;
						
						x1t2 += 2;
						
						xPoints[0] = x1t2;
              			xPoints[1] = x1t2 + 3;
			            xPoints[2] = x1t2 - 3;

			            if (yt1 > yt2) {
			              yt2 += 7;
			              yPoints[1] = yt2 + 4;
			              yPoints[2] = yt2 + 4;
			            }
			            else {
			              yt2 -= 6;
			              yPoints[1] = yt2 - 4;
			              yPoints[2] = yt2 - 4;
			            }
			            yPoints[0] = yt2;
			
						g.fillPolygon(xPoints, yPoints, 3);
			            g.drawLine(x2t1, yt1, x1t2, yt1);
			            g.drawLine(x1t2, yt1, x1t2, yt2);
					
					//Finish-Finish relashion
					} else if(relationship.getRelationshipType()==GanttTaskRelationship.FF) {
						//Get x coord
						int x2t1 = ( (GanttPaintParam) listOfParam.get(index1)).x2;
						int x2t2 = ( (GanttPaintParam) listOfParam.get(index2)).x2;
						
						int xa=(x2t1>x2t2)?x2t1+7:x2t2+7;
						
						//Draw Lines
						g.drawLine(x2t1, yt1, xa, yt1);
			            g.drawLine(xa, yt1, xa, yt2);
						g.drawLine(xa, yt2, x2t2, yt2);
						
						//Traiangle for task 1
						/*x2t1++;
						xPoints[0] = x2t1;
              			xPoints[1] = x2t1 + 3;
			            xPoints[2] = x2t1 + 3;
						yPoints[0] = yt1;
						yPoints[1] = yt1 - 4;
						yPoints[2] = yt1 + 4;
						g.fillPolygon(xPoints, yPoints, 3);*/
						//Traiangle for task 2
						x2t2++;
						xPoints[0] = x2t2;
              			xPoints[1] = x2t2 + 3;
			            xPoints[2] = x2t2 + 3;
						yPoints[0] = yt2;
						yPoints[1] = yt2 - 4;
						yPoints[2] = yt2 + 4;
						g.fillPolygon(xPoints, yPoints, 3);
					
					//Start-Finish relashion
					} else if(relationship.getRelationshipType()==GanttTaskRelationship.SF) {
						//Get x coord
						int x1t1 = ( (GanttPaintParam) listOfParam.get(index1)).x1;
						int x2t2 = ( (GanttPaintParam) listOfParam.get(index2)).x2;
					
						x2t2 -= 3;
						
						xPoints[0] = x2t2;
              			xPoints[1] = x2t2 + 3;
			            xPoints[2] = x2t2 - 3;

			            if (yt1 > yt2) {
			              yt2 += 7;
			              yPoints[1] = yt2 + 4;
			              yPoints[2] = yt2 + 4;
			            }
			            else {
			              yt2 -= 6;
			              yPoints[1] = yt2 - 4;
			              yPoints[2] = yt2 - 4;
			            }
			            yPoints[0] = yt2;
			
						g.fillPolygon(xPoints, yPoints, 3);
			            g.drawLine(x1t1, yt1, x2t2, yt1);
			            g.drawLine(x2t2, yt1, x2t2, yt2);
					
					}
					
					}catch(Exception e){}
				
				}//End of visible Task2			
			}//End of parsing the successors
		}//End of isVisible Task1
	}//End of parsing the iterator
	
  } //Enf of paintDepend function


/** Detect if the position of the mouse is on a special place (return -1 if nothing or the numer of the task*/
  public int detectPosition(int mx, int my, boolean all) {
    for (int i = 0; i < listOfParam.size(); i++) {
      GanttPaintParam param = (GanttPaintParam) listOfParam.get(i);
      if ( ( (param.type == 2 || param.type == 0) && !all) || all) {
        int y = param.y * 20 + 27 - margY;
        int x1 = param.x1;
        int x2 = param.x2;
        int x3 = param.x3;

        if ( (my >= y && my <= y + 12)) {
          //The end of the task
          if (mx >= x2 /*-2*/ && mx <= x2 + 2) {
            typeSeletion = 0;
            setTaskToMove(i);
            GanttCalendar enddate = taskToMove.getEnd().newAdd( -1);
            notes = new Notes(enddate.toString(), mx, y - 30);
            arrow.setDraw(false);
            return i;
          }
          //the start of the task
          else if (mx >= x1 - 2 && mx <= x1 /*+2*/) {
            typeSeletion = 1;
            setTaskToMove(i);
            notes = new Notes(taskToMove.getStart().toString(), mx, y - 30);
            arrow.setDraw(false);
			      return i;
          }
          //the percent length
          else if (mx >= x3 - 2 && mx <= x3 + 2) {
            typeSeletion = 3;
            setTaskToMove(i);
            notes = new Notes("  " + taskToMove.getCompletionPercentage() + "%", mx, y - 30);
            arrow.setDraw(false);
            return i;
          }

          //A depend
          else if (mx > x1 + 3 && mx < x2 - 3) {
            typeSeletion = 2;

            if (param.type != 0) {
              arrow = new Arrow(mx, y + 6, mx, y + 6);
              notes.setDraw(false);
            }
            else {
              setTaskToMove(i);
              notes = new Notes(taskToMove.getStart().toString(), mx, y - 30);
            }

            return i;
          }
        }
      }
    }
    return -1;
  }
}
