package net.sourceforge.ganttproject.task;

import net.sourceforge.ganttproject.GanttCalendar;
import net.sourceforge.ganttproject.GanttTask;
import net.sourceforge.ganttproject.GanttTaskRelationship;
import net.sourceforge.ganttproject.resource.HumanResource;
import net.sourceforge.ganttproject.roles.Role;
import net.sourceforge.ganttproject.shape.ShapePaint;
import net.sourceforge.ganttproject.shape.ShapeConstants;
import net.sourceforge.ganttproject.task.dependency.*;
import net.sourceforge.ganttproject.task.hierarchy.TaskHierarchyItem;
import net.sourceforge.ganttproject.time.TimeUnitManager;
//import net.sourceforge.ganttproject.resource.ProjectResource;
import net.sourceforge.ganttproject.util.ColorConvertion;

import java.util.List;
import java.util.Vector;

import javax.swing.tree.DefaultMutableTreeNode;

import java.util.ArrayList;
import java.util.Iterator;
import java.awt.*;
import java.io.Writer;

/**
 * Created by IntelliJ IDEA.
 * @author bard
 * Date: 31.01.2004
 */
public class TaskImpl implements Task {
    private int myID;
    private final TaskManagerImpl myManager;
    private String myName;
    private String myWebLink = new String("http://");
    private boolean isMilestone;
    private int myPriority;
    private GanttCalendar myStart;
    private GanttCalendar myEnd;
    private int myCompletionPercentage;
    private TaskLength myLength;
    private boolean isStartFixed;

	private boolean bExpand;
    
    private TimeUnitManager myTimeUnitManager;
    //private final TaskDependencyCollection myDependencies = new TaskDependencyCollectionImpl();
    private final ResourceAssignmentCollectionImpl myAssignments;
    private final TaskDependencySlice myDependencySlice;
    private final TaskDependencySlice myDependencySliceAsDependant;
    private final TaskDependencySlice myDependencySliceAsDependee;
    private boolean myEventsEnabled;
    private final TaskHierarchyItem myTaskHierarchyItem;
    private ShapePaint myShape;
    private Color myColor;
    private String myNotes;


    protected TaskImpl(TaskManager taskManager) {
        myManager = (TaskManagerImpl) taskManager;
        myID = myManager.getMaxID();
        myManager.increaseMaxID();
        myTimeUnitManager = myManager.getTimeUnitManager();
        myAssignments = new ResourceAssignmentCollectionImpl(this);
        myDependencySlice = new TaskDependencySliceImpl(this, myManager.getDependencyCollection());
        myDependencySliceAsDependant = new TaskDependencySliceAsDependant(this, myManager.getDependencyCollection());
        myDependencySliceAsDependee = new TaskDependencySliceAsDependee(this, myManager.getDependencyCollection());
        myPriority = 1;
        myTaskHierarchyItem = myManager.getHierarchyManager().createItem(this);
        isStartFixed = false;
        myNotes = "";
		bExpand = true;
        myColor=null;
    }

    protected TaskImpl(TaskImpl copy) {
        myManager = copy.myManager;
        myAssignments = copy.myAssignments.copy();
        myID = copy.myID;
        myName = copy.myName;
        myWebLink = copy.myWebLink;
        isMilestone = copy.isMilestone;
        myPriority = copy.myPriority;
        myStart = copy.myStart;
        myEnd = copy.myEnd;
        myCompletionPercentage = copy.myCompletionPercentage;
        myLength = copy.myLength;
        isStartFixed = copy.isStartFixed;
        myShape = copy.myShape;
        myColor = copy.myColor;
        myNotes = copy.myNotes;
		bExpand = copy.bExpand;
        //
        myTimeUnitManager = copy.myTimeUnitManager;
        myDependencySlice = copy.myDependencySlice;
        myDependencySliceAsDependant = copy.myDependencySliceAsDependant;
        myDependencySliceAsDependee = copy.myDependencySliceAsDependee;
        myTaskHierarchyItem = myManager.getHierarchyManager().createItem(this);
    }

    public TaskMutator createMutator() {
        return new MutatorImpl();
    }

    // main properties
    public int getTaskID() {
        return myID;
    }

    public String getName() {
        return myName;
    }
    
    public String getWebLink() {
        return myWebLink;
    }

    public boolean isMilestone() {
        return isMilestone;
    }

    public int getPriority() {
        return myPriority;
    }

    public GanttCalendar getStart() {
        return myStart;
    }

    public GanttCalendar getEnd() {
        if (myEnd==null) {
            myEnd = getStart().Clone();
            myEnd.add((int) getDuration().getLength());
        }
        return myEnd;
    }

    public TaskLength getDuration() {
        //System.err.println("[TaskImp] this="+this+" duration="+myLength+" id="+myID);
        return myLength;
    }

    public int getCompletionPercentage() {
        return myCompletionPercentage;
    }

    public boolean isStartFixed() {
        return isStartFixed;
    }

	public boolean getExpand(){
    	return bExpand;
    }

    public ShapePaint getShape() {
        return myShape==null ?
                new ShapePaint(ShapeConstants.BACKSLASH, getColor() , getColor()) :
                myShape;
    }

    public Color getColor() {
        return myColor==null ? myManager.getConfig().getDefaultColor() : myColor;
    }

    public String getNotes() {
        return myNotes;
    }

    public GanttTaskRelationship[] getPredecessors() {
        return new GanttTaskRelationship[0];  //To change body of implemented methods use Options | File Templates.
    }

    public GanttTaskRelationship[] getSuccessors() {
        return new GanttTaskRelationship[0];  //To change body of implemented methods use Options | File Templates.
    }

    public ResourceAssignment[] getAssignments() {
        return myAssignments.getAssignments();
    }

    public ResourceAssignmentCollection getAssignmentCollection() {
        return myAssignments;
    }

    //
    public Task getSupertask() {
        TaskHierarchyItem container = myTaskHierarchyItem.getContainerItem();
        return container.getTask();
    }

    public Task[] getNestedTasks() {
        TaskHierarchyItem[] nestedItems = myTaskHierarchyItem.getNestedItems();
        Task[] result = new Task[nestedItems.length];
        for (int i=0; i<nestedItems.length; i++) {
            result[i] = nestedItems[i].getTask();
        }
        return result;
    }

    public void move(Task targetSupertask) {
        TaskImpl supertaskImpl = (TaskImpl) targetSupertask;
        TaskHierarchyItem targetItem = supertaskImpl.myTaskHierarchyItem;
        myTaskHierarchyItem.delete();
        targetItem.addNestedItem(myTaskHierarchyItem);
    }

    public TaskDependencySlice getDependencies() {
        return myDependencySlice;
    }

    public TaskDependencySlice getDependenciesAsDependant() {
        return myDependencySliceAsDependant;
    }

    public TaskDependencySlice getDependenciesAsDependee() {
        return myDependencySliceAsDependee;
    }

    public TaskManager getManager() {
        return myManager;
    }

    //TODO: remove this hack. ID must never be changed
    protected void setTaskIDHack(int taskID) {
        myID = taskID;
    }

    protected TimeUnitManager getTimeUnitManager() {
        return myTimeUnitManager;
    }

    private class MutatorImpl implements TaskMutator {
        private final List myCommands = new ArrayList();
        public void commit() {
            for (int i=0; i<myCommands.size(); i++) {
                Runnable next = (Runnable) myCommands.get(i);
                next.run();
            }
            myCommands.clear();
        }

        public void setName(final String name) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setName(name);
                }
            });
        }

        public void setMilestone(final boolean milestone) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setMilestone(milestone);
                }
            });
        }

        public void setPriority(final int priority) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setPriority(priority);
                }
            });
        }

        public void setStart(final GanttCalendar start) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setStart(start);
                }
            });
        }

        public void setEnd(final GanttCalendar end) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setEnd(end);
                }
            });
        }

        public void setDuration(final TaskLength length) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setDuration(length);
                }
            });
        }

		public void setExpand(final boolean expand) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setExpand(expand);
                }
            });
        }
    
        public void setCompletionPercentage(final int percentage) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setCompletionPercentage(percentage);
                }
            });
        }

        public void setStartFixed(final boolean isFixed) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setStartFixed(isFixed);
                }
            });
        }

        public void setShape(final ShapePaint shape) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setShape(shape);
                }
            });
        }

        public void setColor(final Color color) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setColor(color);
                }
            });
        }

        public void setNotes(final String notes) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setNotes(notes);
                }
            });
        }

        public void addNotes(final String notes) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.addNotes(notes);
                }
            });
        }

    }

    public void setName(String name) {

        myName = name;
    }
    public void setWebLink(String webLink) {

        myWebLink = webLink;
    }
    public void setMilestone(boolean milestone) {
        isMilestone = milestone;
    }

    public void setPriority(int priority) {
        myPriority = priority;
    }

    public void setStart(GanttCalendar start) {
        GanttCalendar oldStart = myStart==null ? null : myStart.Clone();
        myStart = start;
        if (areEventsEnabled()) {
            myManager.fireTaskScheduleChanged(this, oldStart, getEnd());
        }
    }

    public void setEnd(GanttCalendar end) {
        GanttCalendar oldFinish = myEnd==null ? null : myEnd.Clone();
        myEnd = end;
        int length = myStart.diff(end);
        myLength = getManager().createLength(myLength.getTimeUnit(), length);
        if (areEventsEnabled()) {
            myManager.fireTaskScheduleChanged(this, myStart.Clone(), oldFinish);
        }
    }

    public void setDuration(TaskLength length) {
        GanttCalendar oldFinish = myEnd==null ? null : myEnd.Clone();
        myLength = length;
        myEnd = myStart.newAdd((int) length.getLength());
        if (areEventsEnabled()) {
            myManager.fireTaskScheduleChanged(this, myStart.Clone(), oldFinish);
        }
    }

    public void setCompletionPercentage(int percentage) {
        myCompletionPercentage = percentage;
    }

    public void setStartFixed(boolean isFixed) {
        isStartFixed = isFixed;
    }

    public void setShape(ShapePaint shape) {
        myShape = shape;
    }

    public void setColor(Color color) {
        myColor = color;
    }

    public void setNotes(String notes) {
        myNotes = notes;
	}
    
    public void setExpand(boolean expand){
    	bExpand = expand;
    }

    public void addNotes(String notes) {
        myNotes += notes;
    }

    protected void enableEvents(boolean enabled) {
        myEventsEnabled = enabled;
    }

    protected boolean areEventsEnabled() {
        return myEventsEnabled;
    }

    /**
     * Allows to determine, if a special shape is defined for this task.
     * @return true, if this task has its own shape defined.
     */
    public boolean shapeDefined()
    {
      return (myShape != null);
    }

    /**
     * Allows to determine, if a special color is defined for this task.
     * @return true, if this task has its own color defined.
     */

    public boolean colorDefined() {

      return (myColor != null);

    }

	/** Simple write information of tasks */
	  public void writeTask(Writer fout, DefaultMutableTreeNode node, String space) {
	    String space2 = s + space;
	    try {
	      
	      GanttTask task = (GanttTask)node.getUserObject();
	      
	      if(task.getTaskID()==-1) throw new RuntimeException("A task can not has a number equal to -1");
	      
	      
	      int id=task.getTaskID();
	      
	      /*if (id >= lot.size()) {
	        return;
	      }*/
	      
	      
	      boolean haschild = false;
	
	      ArrayList child = tree.getAllChildTask(node);
	      if (child.size() != 0) {
	        haschild = true;
	
	      }
	
	      number.add(new Integer(id));
	      cpt++;
	
	//      boolean one = (task.getSuccessorsOld().size() != 0 || (task.getNotes() != null && task.getNotes().length()>=0) ||
	//                     haschild);
		
		boolean one = (task.getSuccessorsOld().size()==0 && (task.getNotes() == null || task.getNotes().length()==0) && !haschild);
	
	
	      //Writes data of task
	      fout.write(space + "<task id=\"" + task.getTaskID() + //lots.indexOf(task.toString()) + //By CL
	                 "\" ");
	      fout.write("name=\"" + correct(task.getName()) + "\" ");
	
	      if (task.colorDefined()) {
	        /*fout.write("color=\"#");
	        if (task.getColor().getRed() <= 15) {
	          fout.write("0");
	        }
	        fout.write(Integer.toHexString(task.getColor().getRed()));
	        if (task.getColor().getGreen() <= 15) {
	          fout.write("0");
	        }
	        fout.write(Integer.toHexString(task.getColor().getGreen()));
	        if (task.getColor().getBlue() <= 15) {
	          fout.write("0");
	        }
	        fout.write(Integer.toHexString(task.getColor().getBlue()));
	        fout.write("\" ");*/
			fout.write("color=\""+ColorConvertion.getColor(task.getColor())+"\" ");
	      }
	
	      if (task.shapeDefined() && 
	      		task.getShape() != new ShapePaint(ShapeConstants.BACKSLASH, 
	      				task.getColor() , task.getColor())) {
		  fout.write("shape=\"" + task.getShape().getArray()+ "\" ");
	      }
	
	      fout.write("meeting=\"" + ( (task.isMilestone()) ? "true" : "false") +
	                 "\" ");
	      fout.write("start=\"" + task.getStart().toXMLString() + "\" ");
	      fout.write("duration=\"" + task.getLength() + "\" ");
	      fout.write("complete=\"" + task.getCompletionPercentage() + "\" ");
	        fout.write("fixed-start=\"" + (task.isStartFixed() ? "true" : "false") + "\" ");
	      fout.write("priority=\"" + task.getPriority() + "\"");
	      
	      //write the web link of the task
	      String sWebLink = task.getWebLink();
	      if(sWebLink != null && !sWebLink.equals("") && !sWebLink.equals("http://"))
	      	fout.write(" webLink=\"" + sWebLink + "\"");
	      
	      //write if the task is expand or collapse      
	      fout.write(" expand=\"" + task.getExpand() + "\"");
		  	
	      if (!one) {
	        fout.write(">\n");
	      }
	      else {
	        fout.write("/>\n");
	        //fout.writeBytes(">\n");
	
	        //Write notes
	      }
	      if (task.getNotes() != null && task.getNotes().length()>0) {
	        fout.write(space2 + "<notes>");
	        fout.write("\n" + space2 + s + correct(replaceAll(task.getNotes(), "\n", "\n" + space2 + s)));
	        fout.write("\n" + space2 + "</notes>\n");
	      }
	
	      //Write the depends of the task
	      /*
	      if (task.getDepend().size() != 0) {
	        //fout.writeBytes(space2+"<depends>\n");
	        for (int i = 0; i < task.getDepend().size(); i++) {
	          fout.write(space2 + "<depend id=\"" +
	                     tree.getTask( (String) task.getDepend().get(i)).getTaskID() + // changed By CL
	                     //lots.indexOf( (String) task.getDepend().get(i)) +
	                     "\"/>\n");
	          //fout.writeBytes(space2+"</depends>\n");
	        }
	      }*/
	
	      //use successors to write depends information
	      Vector successors = task.getSuccessorsOld();
	      for (int i = 0; i < successors.size(); i++) {
	        GanttTaskRelationship relationship
	            = (GanttTaskRelationship) successors.get(i);
	        fout.write(space2 /*+s*/ + "<depend id=\"" +
	                   relationship.getSuccessorTaskID()+"\""
	                   +" type=\""
	                   +relationship.getRelationshipType()
	                   +"\"/>\n");
	      }
	
	      //Write the child of the task
	      if (haschild) {
	        for (int i = 0; i < child.size(); i++) {
	          Task task2 = (Task) ( (DefaultMutableTreeNode) child.get(i)).
	              getUserObject();
	          int newid = -1; //lot.lastIndexOf(task2);
	
	          for (int j = 0; j < lot.size(); j++) {
	            String a = task2.toString();
	            String b = lot.get(j).toString();
	
	            if (a.equals(b)) {
	              newid = j;
	            }
	          }
	          writeTask(fout, (DefaultMutableTreeNode)child.get(i), space + s);
	        }
	
	      }
	
	      //end of task section
	      if (!one) {
	        fout.write(space + "</task>\n");
	        //fout.writeBytes(space+"</task>\n");
	
	      }
	      //      if (tree.getNode(task.toString()).isLeaf() &&
	      //          !tree.getFatherNode(task).isRoot()) {
	      //        return;
	      //      }
	
	      //      if (id == lot.size() - 1) {
	      //        return;
	      //      }
	      //      else {
	      //        writeTask(fout, cpt, space);
	      //
	      //      }
	
	    }
	    catch (Exception e) {
	      System.out.println(e);
	    }
	  }

	/**@return the link of the task. */
	private String getWebLink(GanttTask task)
	{
		return (task.getWebLink().equals("http://")?"":task.getWebLink());
	}

	/**set the maximum size for all strings. */
	void getMaxSize()
	{
		iMaxSize = 0;
		for(Iterator it=lot.iterator(); it.hasNext();)
	    {
			DefaultMutableTreeNode node = (DefaultMutableTreeNode) it.next();
			if(!node.isRoot())
			{
				GanttTask task = (GanttTask)(node.getUserObject());
	
				if(csvOptions.bExportTaskID){
					String s=""+task.getTaskID();
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskName){
					String s=""+getName(node, task);
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskStartDate){
					String s=""+task.getStart();
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskEndDate){
					String s=""+task.getEnd();
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskDuration){
					String s=""+task.getLength();
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskPercent){
					String s=""+task.getCompletionPercentage();
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskWebLink){
					String s=""+getWebLink(task);
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskResources){
					String s=""+getAssignments(task);
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskNotes){
					String s=""+task.getNotes();
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}	
				
			}
	    }
		
		//parse all resources
		for (int i = 0; i < resources.size(); i++)
		{
		   	HumanResource p = (HumanResource) resources.get(i);
		   	
		   	if(csvOptions.bExportResourceID){
				String s=""+p.getId();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
		   	if(csvOptions.bExportResourceName){
				String s=""+p.getName();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
		   	if(csvOptions.bExportResourceMail){
				String s=""+p.getMail();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
		   	if(csvOptions.bExportResourcePhone){
				String s=""+p.getPhone();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
		   	if(csvOptions.bExportResourceRole){
		   		Role role = p.getRole();
		        String sRoleID = "0";
		        if(role != null) sRoleID = role.getPersistentID();
				String s=""+sRoleID;
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
		}
		
	} //get maxIndentation end

}
