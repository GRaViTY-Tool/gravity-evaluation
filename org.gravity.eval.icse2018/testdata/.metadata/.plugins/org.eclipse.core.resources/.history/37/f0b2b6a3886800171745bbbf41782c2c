/* Generated By:JJTree: Do not edit this line. ASTMethodDeclaration.java */

package net.sourceforge.pmd.ast;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import net.sourceforge.pmd.RuleContext;
import net.sourceforge.pmd.stat.DataPoint;

public class ASTMethodDeclaration extends AccessNode {
    public ASTMethodDeclaration(int id) {
        super(id);
    }

    public ASTMethodDeclaration(JavaParser p, int id) {
        super(p, id);
    }

    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(JavaParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    public void dump(String prefix) {
        System.out.println(collectDumpedModifiers(prefix));
        dumpChildren(prefix);
    }

    /**
     * Gets the name of the method.
     *
     * @return a String representing the name of the method
     */
    public String getMethodName() {
        ASTMethodDeclarator md = (ASTMethodDeclarator) getFirstChildOfType(ASTMethodDeclarator.class);
        if (md != null)
            return md.getImage();
        return null;
    }

    public boolean isSyntacticallyPublic() {
        return super.isPublic();
    }

    public boolean isSyntacticallyAbstract() {
        return super.isAbstract();
    }

    public boolean isPublic() {
        if (isInterfaceMember()) {
            return true;
        }
        return super.isPublic();
    }

    public boolean isAbstract() {
        if (isInterfaceMember()) {
            return true;
        }
        return super.isAbstract();
    }

    public boolean isInterfaceMember() {
        ASTClassOrInterfaceDeclaration clz = (ASTClassOrInterfaceDeclaration) getFirstParentOfType(ASTClassOrInterfaceDeclaration.class);
        return clz != null && clz.isInterface();
    }

    public boolean isVoid() {
        return ((ASTResultType) getFirstChildOfType(ASTResultType.class)).isVoid();
    }

    public ASTResultType getResultType() {
        return (ASTResultType) getFirstChildOfType(ASTResultType.class);
    }

    public ASTBlock getBlock() {
        // FIXME doesn't work for all methods that use generics and declare exceptions
        if (this.jjtGetChild(2) instanceof ASTBlock) {
            return (ASTBlock) this.jjtGetChild(2);
        }
        if (jjtGetNumChildren() > 3) {
            if (this.jjtGetChild(3) instanceof ASTBlock) {
                return (ASTBlock) this.jjtGetChild(3);
            }
        }
        return null;
    }

	public Object visit(ASTMethodDeclaration node, Object data) {
	    if (node.isSyntacticallyPublic() || node.isSyntacticallyAbstract()) {
	        check(node, data);
	    }
	    return super.visit(node, data);
	}

	public Object visit(ASTDoStatement node, Object data) {
	    // (npath of do + bool_comp of do + 1) * npath of next
	
	    int boolCompDo = sumExpressionComplexity( (ASTExpression) node.getFirstChildOfType( ASTExpression.class ) );
	
	    Integer nPathDo = (Integer) ( (SimpleJavaNode) node.getFirstChildOfType( ASTStatement.class ) ).jjtAccept(
	        this, data );
	
	    return new Integer( boolCompDo + nPathDo.intValue() + 1 );
	  }

	private int complexityMultipleOf(SimpleJavaNode node, int npathStart, Object data) {
		
		int npath = npathStart;		
		SimpleJavaNode simpleNode;
		
	    for ( int i = 0; i < node.jjtGetNumChildren(); i++ ) {
	        simpleNode = (SimpleJavaNode) node.jjtGetChild( i );
	        npath *= ((Integer) simpleNode.jjtAccept( this, data )).intValue();
	      }
	    
	    return npath;
	}

	public Object visit(ASTForStatement node, Object data) {
	    // (npath of for + bool_comp of for + 1) * npath of next
	
	    int boolCompFor = sumExpressionComplexity( (ASTExpression) node.getFirstChildOfType( ASTExpression.class ) );
	
	    Integer nPathFor = (Integer) ( (SimpleJavaNode) node.getFirstChildOfType( ASTStatement.class ) ).jjtAccept(
	        this, data );
	
	    return new Integer( boolCompFor + nPathFor.intValue() + 1 );
	  }

	public Object visit(ASTSwitchStatement node, Object data) {
	    // bool_comp of switch + sum(npath(case_range))
	
	    int boolCompSwitch = sumExpressionComplexity( (ASTExpression) node.getFirstChildOfType( ASTExpression.class ) );
	
	    int npath = 0;
	    int caseRange = 0;
	    for ( int i = 0; i < node.jjtGetNumChildren(); i++ ) {
	      SimpleJavaNode simpleNode = (SimpleJavaNode) node.jjtGetChild( i );
	
	      // Fall-through labels count as 1 for complexity
	      if ( simpleNode instanceof ASTSwitchLabel ) {
	        npath += caseRange;
	        caseRange = 1;
	      } else {
	        Integer complexity = (Integer) simpleNode.jjtAccept( this, data );
	        caseRange *= complexity.intValue();
	      }
	    }
	    // add in npath of last label
	    npath += caseRange;
	    return new Integer( boolCompSwitch + npath );
	  }

	protected void makeViolations(RuleContext ctx, Set p) {
	    Iterator points = p.iterator();
	    while ( points.hasNext() ) {
	      DataPoint point = (DataPoint) points.next();
	      addViolation( ctx, point.getNode(), new String[] {
	          ( (ASTMethodDeclaration) point.getNode() ).getMethodName(),
	          String.valueOf( (int) point.getScore() ) } );
	    }
	  }

	private int complexitySumOf(SimpleJavaNode node, int npathStart, Object data) {
		
		int npath = npathStart;		
		SimpleJavaNode simpleNode;
		
	    for ( int i = 0; i < node.jjtGetNumChildren(); i++ ) {
	        simpleNode = (SimpleJavaNode) node.jjtGetChild( i );
	        npath += ((Integer) simpleNode.jjtAccept( this, data )).intValue();
	      }
	    
	    return npath;
	}

	public Object visit(ASTIfStatement node, Object data) {
	    // (npath of if + npath of else (or 1) + bool_comp of if) * npath of next
	
	    int boolCompIf = sumExpressionComplexity( (ASTExpression) node.getFirstChildOfType( ASTExpression.class ) );
	
	    int complexity = 0;
	
	    List statementChildren = new ArrayList();
	    for ( int i = 0; i < node.jjtGetNumChildren(); i++ ) {
	      if ( node.jjtGetChild( i ).getClass() == ASTStatement.class ) {
	        statementChildren.add( node.jjtGetChild( i ) );
	      }
	    }
	
	    if ( statementChildren.isEmpty()
	        || ( statementChildren.size() == 1 && node.hasElse() )
	        || ( statementChildren.size() != 1 && !node.hasElse() ) ) {
	      throw new IllegalStateException( "If node has wrong number of children" );
	    }
	
	    // add path for not taking if
	    if ( !node.hasElse() ) {
	      complexity++;
	    }
	
	    for ( Iterator iter = statementChildren.iterator(); iter.hasNext(); ) {
	      SimpleJavaNode element = (SimpleJavaNode) iter.next();
	      complexity += ( (Integer) element.jjtAccept( this, data ) ).intValue();
	    }
	
	    return new Integer( boolCompIf + complexity );
	  }

	/**
	   * Calculate the boolean complexity of the given expression. NPath boolean
	   * complexity is the sum of && and || tokens. This is calculated by summing
	   * the number of children of the &&'s (minus one) and the children of the ||'s
	   * (minus one).
	   * <p>
	   * Note that this calculation applies to Cyclomatic Complexity as well.
	   * 
	   * @param expr
	   *          control structure expression
	   * @return complexity of the boolean expression
	   */
	  public static int sumExpressionComplexity(ASTExpression expr) {
	    if (expr == null) {
	      return 0;
	    }
	
	    List andNodes = expr.findChildrenOfType( ASTConditionalAndExpression.class );
	    List orNodes = expr.findChildrenOfType( ASTConditionalOrExpression.class );
	
	    int children = 0;
	
	    for ( Iterator iter = orNodes.iterator(); iter.hasNext(); ) {
	      ASTConditionalOrExpression element = (ASTConditionalOrExpression) iter.next();
	      children += element.jjtGetNumChildren();
	      children--;
	    }
	
	    for ( Iterator iter = andNodes.iterator(); iter.hasNext(); ) {
	      ASTConditionalAndExpression element = (ASTConditionalAndExpression) iter.next();
	      children += element.jjtGetNumChildren();
	      children--;
	    }
	
	    return children;
	  }
}
