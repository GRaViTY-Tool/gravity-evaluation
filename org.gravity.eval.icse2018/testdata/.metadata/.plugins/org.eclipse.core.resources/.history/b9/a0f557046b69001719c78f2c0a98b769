/* Generated By:JJTree: Do not edit this line. ASTConditionalExpression.java */

package net.sourceforge.pmd.ast;

import net.sourceforge.pmd.util.NumericConstants;

public class ASTConditionalExpression extends SimpleJavaNode {
    public ASTConditionalExpression(int id) {
        super(id);
    }

    public ASTConditionalExpression(JavaParser p, int id) {
        super(p, id);
    }

    private boolean isTernary;

    public void setTernary() {
        isTernary = true;
    }

    public boolean isTernary() {
        return this.isTernary;
    }

    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(JavaParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

	public Object visit(ASTConditionalExpression node, Object data) {
	    if ( node.isTernary() ) {
	//      int npath = 0;
	//
	//      for ( int i = 0; i < node.jjtGetNumChildren(); i++ ) {
	//        SimpleJavaNode simpleNode = (SimpleJavaNode) node.jjtGetChild( i );
	//        Integer complexity = (Integer) simpleNode.jjtAccept( this, data );
	//        npath += complexity.intValue();
	//      }
	    	int npath = complexitySumOf(node, 0, data);
	    	
	      npath += 2;
	      return new Integer( npath );
	    }
	    return NumericConstants.ONE;
	  }

	public Object visit(ASTSwitchStatement node, Object data) {
	    // bool_comp of switch + sum(npath(case_range))
	
	    int boolCompSwitch = sumExpressionComplexity( (ASTExpression) node.getFirstChildOfType( ASTExpression.class ) );
	
	    int npath = 0;
	    int caseRange = 0;
	    for ( int i = 0; i < node.jjtGetNumChildren(); i++ ) {
	      SimpleJavaNode simpleNode = (SimpleJavaNode) node.jjtGetChild( i );
	
	      // Fall-through labels count as 1 for complexity
	      if ( simpleNode instanceof ASTSwitchLabel ) {
	        npath += caseRange;
	        caseRange = 1;
	      } else {
	        Integer complexity = (Integer) simpleNode.jjtAccept( this, data );
	        caseRange *= complexity.intValue();
	      }
	    }
	    // add in npath of last label
	    npath += caseRange;
	    return new Integer( boolCompSwitch + npath );
	  }

	public Object visit(ASTDoStatement node, Object data) {
	    // (npath of do + bool_comp of do + 1) * npath of next
	
	    int boolCompDo = sumExpressionComplexity( (ASTExpression) node.getFirstChildOfType( ASTExpression.class ) );
	
	    Integer nPathDo = (Integer) ( (SimpleJavaNode) node.getFirstChildOfType( ASTStatement.class ) ).jjtAccept(
	        this, data );
	
	    return new Integer( boolCompDo + nPathDo.intValue() + 1 );
	  }

	private int complexityMultipleOf(SimpleJavaNode node, int npathStart, Object data) {
		
		int npath = npathStart;		
		SimpleJavaNode simpleNode;
		
	    for ( int i = 0; i < node.jjtGetNumChildren(); i++ ) {
	        simpleNode = (SimpleJavaNode) node.jjtGetChild( i );
	        npath *= ((Integer) simpleNode.jjtAccept( this, data )).intValue();
	      }
	    
	    return npath;
	}
}
