/* Generated By:JJTree: Do not edit this line. ASTElement.java */

package net.sourceforge.pmd.jsp.ast;

public class ASTElement extends SimpleNode {

/* BEGIN CUSTOM CODE */

    /**
     * Name of the element-tag. Cannot be null.
     */
    private String name;

    /**
     * Flag indicating that the element consists of one tag ("<... />").
     */
    private boolean empty; //


    /**
     * @return boolean - true if the element has a namespace-prefix, false otherwise
     */
    public boolean isHasNamespacePrefix() {
        return (name.indexOf(':') >= 0);
    }

    /**
     * @return String - the part of the name that is before the (first) colon (":")
     */
    public String getNamespacePrefix() {
        int colonIndex = name.indexOf(':');
        return ((colonIndex >= 0)
                ? name.substring(0, colonIndex)
                : "");
    }

    /**
     * @return String - The part of the name that is after the first colon (":").
     *         If the name does not contain a colon, the full name is returned.
     */
    public String getLocalName() {
        int colonIndex = name.indexOf(':');
        return ((colonIndex >= 0)
                ? name.substring(colonIndex + 1)
                : name);
    }

    /**
     * @return Returns the name.
     */
    public String getName() {
        return name;
    }

    /**
     * @param name The name to set.
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * @return Returns the empty.
     */
    public boolean isEmpty() {
        return empty;
    }

    /**
     * @param empty The empty to set.
     */
    public void setEmpty(boolean empty) {
        this.empty = empty;
    }

    /* (non-Javadoc)
     * @see com.applicationengineers.pmd4jsp.ast.SimpleNode#toString(java.lang.String)
     */
    public String toString(String prefix) {
        return super.toString(prefix) + " name=[" + name + "] ";
    }
/* END CUSTOM CODE */



    public ASTElement(int id) {
        super(id);
    }

    public ASTElement(JspParser p, int id) {
        super(p, id);
    }


    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(JspParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

	final public String UnparsedText() throws ParseException {
	 /*@bgen(jjtree) UnparsedText */
	  ASTUnparsedText jjtn000 = new ASTUnparsedText(this, JJTUNPARSEDTEXT);
	  boolean jjtc000 = true;
	  jjtree.openNodeScope(jjtn000);Token t;
	    try {
	      t = jj_consume_token(UNPARSED_TEXT);
	          jjtree.closeNodeScope(jjtn000, true);
	          jjtc000 = false;
	                jjtn000.setImage(t.image);
	                {if (true) return t.image;}
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	    throw new RuntimeException("Missing return statement in function");
	  }

	/**
	 * Text that contains no single quotes, and that does not contain the start
	 * of a EL expression or value binding.
	 */
	  final public String UnparsedTextNoSingleQuotes() throws ParseException {
	 /*@bgen(jjtree) UnparsedText */
	  ASTUnparsedText jjtn000 = new ASTUnparsedText(this, JJTUNPARSEDTEXT);
	  boolean jjtc000 = true;
	  jjtree.openNodeScope(jjtn000);Token t;
	    try {
	      t = jj_consume_token(UNPARSED_TEXT_NO_SINGLE_QUOTES);
	          jjtree.closeNodeScope(jjtn000, true);
	          jjtc000 = false;
	                jjtn000.setImage(t.image);
	                {if (true) return t.image;}
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	    throw new RuntimeException("Missing return statement in function");
	  }

	/**
	 * The value of an attribute of an element.
	 * EL expressions, JSF value bindings, and JSP expressions
	 * are parsed as sub-nodes of the AttributeValue node.
	 */
	  final public void AttributeValue() throws ParseException {
	 /*@bgen(jjtree) AttributeValue */
	        ASTAttributeValue jjtn000 = new ASTAttributeValue(this, JJTATTRIBUTEVALUE);
	        boolean jjtc000 = true;
	        jjtree.openNodeScope(jjtn000);StringBuffer content = new StringBuffer();
	        String tmp;
	        Token t;
	    try {
	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	      case DOUBLE_QUOTE:
	        jj_consume_token(DOUBLE_QUOTE);
	        label_8:
	        while (true) {
	          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	          case EL_EXPRESSION_IN_ATTRIBUTE:
	          case VALUE_BINDING_IN_ATTRIBUTE:
	          case JSP_EXPRESSION_IN_ATTRIBUTE:
	          case UNPARSED_TEXT_NO_DOUBLE_QUOTES:
	            ;
	            break;
	          default:
	            jj_la1[15] = jj_gen;
	            break label_8;
	          }
	          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	          case UNPARSED_TEXT_NO_DOUBLE_QUOTES:
	            tmp = UnparsedTextNoDoubleQuotes();
	            break;
	          case EL_EXPRESSION_IN_ATTRIBUTE:
	          case VALUE_BINDING_IN_ATTRIBUTE:
	          case JSP_EXPRESSION_IN_ATTRIBUTE:
	            tmp = QuoteIndependentAttributeValueContent();
	            break;
	          default:
	            jj_la1[16] = jj_gen;
	            jj_consume_token(-1);
	            throw new ParseException();
	          }
	                            content.append(tmp);
	        }
	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	        case ENDING_DOUBLE_QUOTE:
	          jj_consume_token(ENDING_DOUBLE_QUOTE);
	          break;
	        case DOLLAR_OR_HASH_DOUBLE_QUOTE:
	          t = jj_consume_token(DOLLAR_OR_HASH_DOUBLE_QUOTE);
	                                                                    content.append(t.image.substring(0, 1));
	          break;
	        default:
	          jj_la1[17] = jj_gen;
	          jj_consume_token(-1);
	          throw new ParseException();
	        }
	        break;
	      case SINGLE_QUOTE:
	        jj_consume_token(SINGLE_QUOTE);
	        label_9:
	        while (true) {
	          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	          case EL_EXPRESSION_IN_ATTRIBUTE:
	          case VALUE_BINDING_IN_ATTRIBUTE:
	          case JSP_EXPRESSION_IN_ATTRIBUTE:
	          case UNPARSED_TEXT_NO_SINGLE_QUOTES:
	            ;
	            break;
	          default:
	            jj_la1[18] = jj_gen;
	            break label_9;
	          }
	          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	          case UNPARSED_TEXT_NO_SINGLE_QUOTES:
	            tmp = UnparsedTextNoSingleQuotes();
	            break;
	          case EL_EXPRESSION_IN_ATTRIBUTE:
	          case VALUE_BINDING_IN_ATTRIBUTE:
	          case JSP_EXPRESSION_IN_ATTRIBUTE:
	            tmp = QuoteIndependentAttributeValueContent();
	            break;
	          default:
	            jj_la1[19] = jj_gen;
	            jj_consume_token(-1);
	            throw new ParseException();
	          }
	                            content.append(tmp);
	        }
	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	        case ENDING_SINGLE_QUOTE:
	          jj_consume_token(ENDING_SINGLE_QUOTE);
	          break;
	        case DOLLAR_OR_HASH_SINGLE_QUOTE:
	          t = jj_consume_token(DOLLAR_OR_HASH_SINGLE_QUOTE);
	                                                                 content.append(t.image.substring(0, 1));
	          break;
	        default:
	          jj_la1[20] = jj_gen;
	          jj_consume_token(-1);
	          throw new ParseException();
	        }
	        break;
	      default:
	        jj_la1[21] = jj_gen;
	        jj_consume_token(-1);
	        throw new ParseException();
	      }
	          jjtree.closeNodeScope(jjtn000, true);
	          jjtc000 = false;
	          jjtn000.setImage( content.toString() );
	    } catch (Throwable jjte000) {
	          if (jjtc000) {
	            jjtree.clearNodeScope(jjtn000);
	            jjtc000 = false;
	          } else {
	            jjtree.popNode();
	          }
	          if (jjte000 instanceof RuntimeException) {
	            {if (true) throw (RuntimeException)jjte000;}
	          }
	          if (jjte000 instanceof ParseException) {
	            {if (true) throw (ParseException)jjte000;}
	          }
	          {if (true) throw (Error)jjte000;}
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	  }

	/**
	 * Text that contains no double quotes, and that does not contain the start
	 * of a EL expression or value binding.
	 */
	  final public String UnparsedTextNoDoubleQuotes() throws ParseException {
	 /*@bgen(jjtree) UnparsedText */
	  ASTUnparsedText jjtn000 = new ASTUnparsedText(this, JJTUNPARSEDTEXT);
	  boolean jjtc000 = true;
	  jjtree.openNodeScope(jjtn000);Token t;
	    try {
	      t = jj_consume_token(UNPARSED_TEXT_NO_DOUBLE_QUOTES);
	          jjtree.closeNodeScope(jjtn000, true);
	          jjtc000 = false;
	                jjtn000.setImage(t.image);
	                {if (true) return t.image;}
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	    throw new RuntimeException("Missing return statement in function");
	  }

	final public void JspExpression() throws ParseException {
	 /*@bgen(jjtree) JspExpression */
	        ASTJspExpression jjtn000 = new ASTJspExpression(this, JJTJSPEXPRESSION);
	        boolean jjtc000 = true;
	        jjtree.openNodeScope(jjtn000);Token t;
	    try {
	      jj_consume_token(JSP_EXPRESSION_START);
	      t = jj_consume_token(JSP_EXPRESSION);
	                               jjtn000.setImage(t.image.trim());
	      jj_consume_token(JSP_EXPRESSION_END);
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	  }

	final public String ElExpressionInAttribute() throws ParseException {
	 /*@bgen(jjtree) ElExpression */
	        ASTElExpression jjtn000 = new ASTElExpression(this, JJTELEXPRESSION);
	        boolean jjtc000 = true;
	        jjtree.openNodeScope(jjtn000);Token t;
	    try {
	      t = jj_consume_token(EL_EXPRESSION_IN_ATTRIBUTE);
	          jjtree.closeNodeScope(jjtn000, true);
	          jjtc000 = false;
	                jjtn000.setImage(expressionContent(t.image));
	                {if (true) return t.image;}
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	    throw new RuntimeException("Missing return statement in function");
	  }

	final public String JspExpressionInAttribute() throws ParseException {
	 /*@bgen(jjtree) JspExpressionInAttribute */
	        ASTJspExpressionInAttribute jjtn000 = new ASTJspExpressionInAttribute(this, JJTJSPEXPRESSIONINATTRIBUTE);
	        boolean jjtc000 = true;
	        jjtree.openNodeScope(jjtn000);Token t;
	    try {
	      t = jj_consume_token(JSP_EXPRESSION_IN_ATTRIBUTE);
	          jjtree.closeNodeScope(jjtn000, true);
	          jjtc000 = false;
	                jjtn000.setImage(t.image.substring(3, t.image.length()-2).trim()); // without <% and %>
	                {if (true) return t.image;}
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	    throw new RuntimeException("Missing return statement in function");
	  }

	/**
	 * This production groups all characters between two tags, where
	 * tag is an xml-tag "<...>" or a jsp-page-tag "<%...%>" or CDATA "<![CDATA[...]]>".
	 * Text consists of unparsed text and/or Expression Language expressions.
	 */
	  final public void Text() throws ParseException {
	 /*@bgen(jjtree) Text */
	        ASTText jjtn000 = new ASTText(this, JJTTEXT);
	        boolean jjtc000 = true;
	        jjtree.openNodeScope(jjtn000);StringBuffer content = new StringBuffer();
	        String tmp;
	    try {
	      label_5:
	      while (true) {
	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	        case UNPARSED_TEXT:
	          tmp = UnparsedText();
	                                       content.append(tmp);
	          break;
	        case EL_EXPRESSION:
	          tmp = ElExpression();
	                                       content.append(tmp);
	          break;
	        default:
	          jj_la1[9] = jj_gen;
	          jj_consume_token(-1);
	          throw new ParseException();
	        }
	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	        case EL_EXPRESSION:
	        case UNPARSED_TEXT:
	          ;
	          break;
	        default:
	          jj_la1[10] = jj_gen;
	          break label_5;
	        }
	      }
	          jjtree.closeNodeScope(jjtn000, true);
	          jjtc000 = false;
	          jjtn000.setImage(content.toString());
	    } catch (Throwable jjte000) {
	          if (jjtc000) {
	            jjtree.clearNodeScope(jjtn000);
	            jjtc000 = false;
	          } else {
	            jjtree.popNode();
	          }
	          if (jjte000 instanceof RuntimeException) {
	            {if (true) throw (RuntimeException)jjte000;}
	          }
	          if (jjte000 instanceof ParseException) {
	            {if (true) throw (ParseException)jjte000;}
	          }
	          {if (true) throw (Error)jjte000;}
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	  }

	/**
	 * An EL expression, not within an attribute value.
	 */
	  final public String ElExpression() throws ParseException {
	 /*@bgen(jjtree) ElExpression */
	        ASTElExpression jjtn000 = new ASTElExpression(this, JJTELEXPRESSION);
	        boolean jjtc000 = true;
	        jjtree.openNodeScope(jjtn000);Token t;
	    try {
	      t = jj_consume_token(EL_EXPRESSION);
	          jjtree.closeNodeScope(jjtn000, true);
	          jjtc000 = false;
	                jjtn000.setImage(expressionContent(t.image));
	                {if (true) return t.image;}
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	    throw new RuntimeException("Missing return statement in function");
	  }

	/**
	 * A XML element, either with a single empty tag, or with a starting and closing tag
	 * with optional contained content.
	 */
	  final public void Element() throws ParseException {
	 /*@bgen(jjtree) Element */
	        ASTElement jjtn000 = new ASTElement(this, JJTELEMENT);
	        boolean jjtc000 = true;
	        jjtree.openNodeScope(jjtn000);Token startTagName;
	        Token endTagName;
	        String tagName;
	    try {
	      jj_consume_token(TAG_START);
	      startTagName = jj_consume_token(TAG_NAME);
	                                tagName = startTagName.image; jjtn000.setName(tagName);
	      label_7:
	      while (true) {
	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	        case ATTR_NAME:
	          ;
	          break;
	        default:
	          jj_la1[12] = jj_gen;
	          break label_7;
	        }
	        Attribute();
	      }
	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	      case TAG_END:
	        jj_consume_token(TAG_END);
	                  jjtn000.setEmpty(false);
	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	        case TAG_START:
	        case COMMENT_START:
	        case CDATA_START:
	        case JSP_COMMENT_START:
	        case JSP_DECLARATION_START:
	        case JSP_EXPRESSION_START:
	        case JSP_SCRIPTLET_START:
	        case JSP_DIRECTIVE_START:
	        case EL_EXPRESSION:
	        case UNPARSED_TEXT:
	          Content();
	          break;
	        default:
	          jj_la1[13] = jj_gen;
	          ;
	        }
	        jj_consume_token(ENDTAG_START);
	        endTagName = jj_consume_token(TAG_NAME);
	                        if (! tagName.equalsIgnoreCase(endTagName.image)) {
	                                {if (true) throw new StartAndEndTagMismatchException(
	                                        startTagName.beginLine, startTagName.beginColumn,
	                                        startTagName.image,
	                                        endTagName.beginLine, endTagName.beginColumn,
	                                        endTagName.image  );}
	                        }
	        jj_consume_token(TAG_END);
	        break;
	      case TAG_SLASHEND:
	        jj_consume_token(TAG_SLASHEND);
	                          jjtree.closeNodeScope(jjtn000, true);
	                          jjtc000 = false;
	                          jjtn000.setEmpty(true);
	        break;
	      default:
	        jj_la1[14] = jj_gen;
	        jj_consume_token(-1);
	        throw new ParseException();
	      }
	    } catch (Throwable jjte000) {
	      if (jjtc000) {
	        jjtree.clearNodeScope(jjtn000);
	        jjtc000 = false;
	      } else {
	        jjtree.popNode();
	      }
	      if (jjte000 instanceof RuntimeException) {
	        {if (true) throw (RuntimeException)jjte000;}
	      }
	      if (jjte000 instanceof ParseException) {
	        {if (true) throw (ParseException)jjte000;}
	      }
	      {if (true) throw (Error)jjte000;}
	    } finally {
	      if (jjtc000) {
	        jjtree.closeNodeScope(jjtn000, true);
	      }
	    }
	  }

	final public void JspDeclaration() throws ParseException {
	 /*@bgen(jjtree) JspDeclaration */
	        ASTJspDeclaration jjtn000 = new ASTJspDeclaration(this, JJTJSPDECLARATION);
	        boolean jjtc000 = true;
	        jjtree.openNodeScope(jjtn000);Token t;
	    try {
	      jj_consume_token(JSP_DECLARATION_START);
	      t = jj_consume_token(JSP_DECLARATION);
	                                jjtn000.setImage(t.image.trim());
	      jj_consume_token(JSP_DECLARATION_END);
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	  }

	final public void CData() throws ParseException {
	 /*@bgen(jjtree) CData */
	        ASTCData jjtn000 = new ASTCData(this, JJTCDATA);
	        boolean jjtc000 = true;
	        jjtree.openNodeScope(jjtn000);StringBuffer content = new StringBuffer();
	        Token t;
	    try {
	      jj_consume_token(CDATA_START);
	      label_6:
	      while (true) {
	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	        case UNPARSED:
	          ;
	          break;
	        default:
	          jj_la1[11] = jj_gen;
	          break label_6;
	        }
	        t = jj_consume_token(UNPARSED);
	                                          content.append(t.image);
	      }
	      jj_consume_token(CDATA_END);
	          jjtree.closeNodeScope(jjtn000, true);
	          jjtc000 = false;
	                jjtn000.setImage(content.toString());
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	  }

	final public void JspComment() throws ParseException {
	 /*@bgen(jjtree) JspComment */
	        ASTJspComment jjtn000 = new ASTJspComment(this, JJTJSPCOMMENT);
	        boolean jjtc000 = true;
	        jjtree.openNodeScope(jjtn000);Token t;
	    try {
	      jj_consume_token(JSP_COMMENT_START);
	      t = jj_consume_token(JSP_COMMENT_CONTENT);
	                                    jjtn000.setImage(t.image.trim());
	      jj_consume_token(JSP_COMMENT_END);
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	  }
}
