package net.sourceforge.ganttproject;

import net.sourceforge.ganttproject.task.TaskManager;
import net.sourceforge.ganttproject.util.ColorConvertion;

import java.io.Writer;
import java.util.ArrayList;
import java.util.Vector;

import javax.swing.tree.DefaultMutableTreeNode;

import net.sourceforge.ganttproject.shape.ShapeConstants;
import net.sourceforge.ganttproject.shape.ShapePaint;
import net.sourceforge.ganttproject.task.Task;

/**
 * <p>Title: </p>
 * <p>Description: This class model the four relationships between
 different tasks.
 * <p>Start-start: As soon as the predecessor task starts, the
 successor task can start.</p>
 * <p>start to finish: As soon as the predecessor task starts, the
 successor task can finish.
 * This type of link is rarely used, but still available if you need
 it.</p>
 * <p>finish to start relationship: As soon as the predecessor task
 finishes,
 * the successor task can start</p>
 * <p>finish to finish relationship: As soon as the predecessor task
 finishes,
 * the successor task can finish</p>
 * </p>
 */

public class GanttTaskRelationship {
  public static final int SS = 1; //start to start
  public static final int FS = 2; // Finish to start
  public static final int FF = 3; //Finish to finish
  public static final int SF = 4; //start to finsih

  //private GanttTask predecessorTask; //predecessor;
  //private GanttTask successorTask; //successor;
  private int predecessorTaskID = -1;
  private int successorTaskID = -1;
  private int relationshipType;
    private final TaskManager myTaskManager;


    /** Constructor, do nothing */
  public GanttTaskRelationship() {
        this(null);
    }

    public GanttTaskRelationship(TaskManager taskManager) {
        myTaskManager = taskManager;
    }
  /**Constructor */
  public GanttTaskRelationship (int predecessorTaskID,
                         int successorTaskID,
                         int relationshipType, TaskManager taskManager)
  {
      this(taskManager);
  	this.predecessorTaskID=predecessorTaskID;
  	this.successorTaskID=successorTaskID;
  	this.relationshipType=relationshipType;
  }



  //getters and setters
  /**get the predecessor task*/
  public GanttTask getPredecessorTask() {
    if (predecessorTaskID != -1) {
      return getManager().getTask(predecessorTaskID);
    }
    else {
      return null;
    }
  }

  /**get the predecessor task ID or -1 if there is no such ID*/
  public int getPredecessorTaskID() {
    return predecessorTaskID;
  }

  /**set the predecessor task by GanttTask object*/
  public void setPredecessorTask(Task predecessorTask) {
    this.predecessorTaskID = predecessorTask.getTaskID();
    //this.predecessorTask=predecessorTask;
  }

  /**
   * set the predecessor task ID by integer
   * @param predecessorTaskID ID of predecessor task
   */
  public void setPredecessorTask(int predecessorTaskID) {
    this.predecessorTaskID = predecessorTaskID;
  }

  /**get the successor task*/
  public Task getSuccessorTask() {
    if (successorTaskID != -1) {
      return getManager().getTask(successorTaskID);
    }
    else {
      return null;
    }
  }

  /**
   *
   * @return id of successor task
   */
  public int getSuccessorTaskID() {
    return successorTaskID;
  }

  /**
   * set the successor task by GanttTask object
   * @param successorTask GanttTask object of successor
   */
  public void setSuccessorTask(Task successorTask) {
    this.successorTaskID = successorTask.getTaskID();
    //this.successorTask = successorTask;
  }

  /**
   * set the successor task ID by the integer
   * @param seccessorTaskID id of the successor
   */
  public void setSuccessorTask(int seccessorTaskID) {
    this.successorTaskID = seccessorTaskID;
  }

  /**get the relationship type*/
  public int getRelationshipType() {
    return relationshipType;
  }

  /**set the relationship type*/
  public void setRelationshipType(int relationshipType) {
    this.relationshipType = relationshipType;
  }

  public boolean equals(GanttTaskRelationship compareRel) {
	return relationshipType  == compareRel.relationshipType &&
           predecessorTaskID == compareRel.predecessorTaskID &&
           successorTaskID   == compareRel.successorTaskID;
  }

  public Object clone(){
    GanttTaskRelationship copyRel=new GanttTaskRelationship(myTaskManager);
    copyRel.relationshipType=relationshipType;
    copyRel.predecessorTaskID=predecessorTaskID;
    copyRel.successorTaskID=successorTaskID;
    return copyRel;
  }
  
  public String toString(){
    String res = "Relation ";
  	res += (relationshipType==SS)?"(SS) ":(relationshipType==SF)?"(SF) ":
			(relationshipType==FS)?"(FS) ":"(FF) ";	
	res+=getSuccessorTask()+" ("+getSuccessorTaskID()+") "+getPredecessorTask()+" ("+getPredecessorTaskID()+")";
  	return res;
  }

    private TaskManager getManager() {
        return myTaskManager;
    }

	/** Simple write information of tasks */
	  public void writeTask(Writer fout, DefaultMutableTreeNode node, String space) {
	    String space2 = s + space;
	    try {
	      
	      GanttTask task = (GanttTask)node.getUserObject();
	      
	      if(task.getTaskID()==-1) throw new RuntimeException("A task can not has a number equal to -1");
	      
	      
	      int id=task.getTaskID();
	      
	      /*if (id >= lot.size()) {
	        return;
	      }*/
	      
	      
	      boolean haschild = false;
	
	      ArrayList child = tree.getAllChildTask(node);
	      if (child.size() != 0) {
	        haschild = true;
	
	      }
	
	      number.add(new Integer(id));
	      cpt++;
	
	//      boolean one = (task.getSuccessorsOld().size() != 0 || (task.getNotes() != null && task.getNotes().length()>=0) ||
	//                     haschild);
		
		boolean one = (task.getSuccessorsOld().size()==0 && (task.getNotes() == null || task.getNotes().length()==0) && !haschild);
	
	
	      //Writes data of task
	      fout.write(space + "<task id=\"" + task.getTaskID() + //lots.indexOf(task.toString()) + //By CL
	                 "\" ");
	      fout.write("name=\"" + correct(task.getName()) + "\" ");
	
	      if (task.colorDefined()) {
	        /*fout.write("color=\"#");
	        if (task.getColor().getRed() <= 15) {
	          fout.write("0");
	        }
	        fout.write(Integer.toHexString(task.getColor().getRed()));
	        if (task.getColor().getGreen() <= 15) {
	          fout.write("0");
	        }
	        fout.write(Integer.toHexString(task.getColor().getGreen()));
	        if (task.getColor().getBlue() <= 15) {
	          fout.write("0");
	        }
	        fout.write(Integer.toHexString(task.getColor().getBlue()));
	        fout.write("\" ");*/
			fout.write("color=\""+ColorConvertion.getColor(task.getColor())+"\" ");
	      }
	
	      if (task.shapeDefined() && 
	      		task.getShape() != new ShapePaint(ShapeConstants.BACKSLASH, 
	      				task.getColor() , task.getColor())) {
		  fout.write("shape=\"" + task.getShape().getArray()+ "\" ");
	      }
	
	      fout.write("meeting=\"" + ( (task.isMilestone()) ? "true" : "false") +
	                 "\" ");
	      fout.write("start=\"" + task.getStart().toXMLString() + "\" ");
	      fout.write("duration=\"" + task.getLength() + "\" ");
	      fout.write("complete=\"" + task.getCompletionPercentage() + "\" ");
	        fout.write("fixed-start=\"" + (task.isStartFixed() ? "true" : "false") + "\" ");
	      fout.write("priority=\"" + task.getPriority() + "\"");
	      
	      //write the web link of the task
	      String sWebLink = task.getWebLink();
	      if(sWebLink != null && !sWebLink.equals("") && !sWebLink.equals("http://"))
	      	fout.write(" webLink=\"" + sWebLink + "\"");
	      
	      //write if the task is expand or collapse      
	      fout.write(" expand=\"" + task.getExpand() + "\"");
		  	
	      if (!one) {
	        fout.write(">\n");
	      }
	      else {
	        fout.write("/>\n");
	        //fout.writeBytes(">\n");
	
	        //Write notes
	      }
	      if (task.getNotes() != null && task.getNotes().length()>0) {
	        fout.write(space2 + "<notes>");
	        fout.write("\n" + space2 + s + correct(replaceAll(task.getNotes(), "\n", "\n" + space2 + s)));
	        fout.write("\n" + space2 + "</notes>\n");
	      }
	
	      //Write the depends of the task
	      /*
	      if (task.getDepend().size() != 0) {
	        //fout.writeBytes(space2+"<depends>\n");
	        for (int i = 0; i < task.getDepend().size(); i++) {
	          fout.write(space2 + "<depend id=\"" +
	                     tree.getTask( (String) task.getDepend().get(i)).getTaskID() + // changed By CL
	                     //lots.indexOf( (String) task.getDepend().get(i)) +
	                     "\"/>\n");
	          //fout.writeBytes(space2+"</depends>\n");
	        }
	      }*/
	
	      //use successors to write depends information
	      Vector successors = task.getSuccessorsOld();
	      for (int i = 0; i < successors.size(); i++) {
	        GanttTaskRelationship relationship
	            = (GanttTaskRelationship) successors.get(i);
	        fout.write(space2 /*+s*/ + "<depend id=\"" +
	                   relationship.getSuccessorTaskID()+"\""
	                   +" type=\""
	                   +relationship.getRelationshipType()
	                   +"\"/>\n");
	      }
	
	      //Write the child of the task
	      if (haschild) {
	        for (int i = 0; i < child.size(); i++) {
	          Task task2 = (Task) ( (DefaultMutableTreeNode) child.get(i)).
	              getUserObject();
	          int newid = -1; //lot.lastIndexOf(task2);
	
	          for (int j = 0; j < lot.size(); j++) {
	            String a = task2.toString();
	            String b = lot.get(j).toString();
	
	            if (a.equals(b)) {
	              newid = j;
	            }
	          }
	          writeTask(fout, (DefaultMutableTreeNode)child.get(i), space + s);
	        }
	
	      }
	
	      //end of task section
	      if (!one) {
	        fout.write(space + "</task>\n");
	        //fout.writeBytes(space+"</task>\n");
	
	      }
	      //      if (tree.getNode(task.toString()).isLeaf() &&
	      //          !tree.getFatherNode(task).isRoot()) {
	      //        return;
	      //      }
	
	      //      if (id == lot.size() - 1) {
	      //        return;
	      //      }
	      //      else {
	      //        writeTask(fout, cpt, space);
	      //
	      //      }
	
	    }
	    catch (Exception e) {
	      System.out.println(e);
	    }
	  }
}
