/* Generated By:JJTree: Do not edit this line. ASTConditionalExpression.java */

package net.sourceforge.pmd.ast;

import java.util.Iterator;
import java.util.List;

import net.sourceforge.pmd.util.NumericConstants;

public class ASTConditionalExpression extends SimpleJavaNode {
    public ASTConditionalExpression(int id) {
        super(id);
    }

    public ASTConditionalExpression(JavaParser p, int id) {
        super(p, id);
    }

    private boolean isTernary;

    public void setTernary() {
        isTernary = true;
    }

    public boolean isTernary() {
        return this.isTernary;
    }

    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(JavaParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

	public Object visit(ASTConditionalExpression node, Object data) {
	    if ( node.isTernary() ) {
	//      int npath = 0;
	//
	//      for ( int i = 0; i < node.jjtGetNumChildren(); i++ ) {
	//        SimpleJavaNode simpleNode = (SimpleJavaNode) node.jjtGetChild( i );
	//        Integer complexity = (Integer) simpleNode.jjtAccept( this, data );
	//        npath += complexity.intValue();
	//      }
	    	int npath = complexitySumOf(node, 0, data);
	    	
	      npath += 2;
	      return new Integer( npath );
	    }
	    return NumericConstants.ONE;
	  }

	public Object visit(ASTSwitchStatement node, Object data) {
	    // bool_comp of switch + sum(npath(case_range))
	
	    int boolCompSwitch = sumExpressionComplexity( (ASTExpression) node.getFirstChildOfType( ASTExpression.class ) );
	
	    int npath = 0;
	    int caseRange = 0;
	    for ( int i = 0; i < node.jjtGetNumChildren(); i++ ) {
	      SimpleJavaNode simpleNode = (SimpleJavaNode) node.jjtGetChild( i );
	
	      // Fall-through labels count as 1 for complexity
	      if ( simpleNode instanceof ASTSwitchLabel ) {
	        npath += caseRange;
	        caseRange = 1;
	      } else {
	        Integer complexity = (Integer) simpleNode.jjtAccept( this, data );
	        caseRange *= complexity.intValue();
	      }
	    }
	    // add in npath of last label
	    npath += caseRange;
	    return new Integer( boolCompSwitch + npath );
	  }

	public Object visit(ASTDoStatement node, Object data) {
	    // (npath of do + bool_comp of do + 1) * npath of next
	
	    int boolCompDo = sumExpressionComplexity( (ASTExpression) node.getFirstChildOfType( ASTExpression.class ) );
	
	    Integer nPathDo = (Integer) ( (SimpleJavaNode) node.getFirstChildOfType( ASTStatement.class ) ).jjtAccept(
	        this, data );
	
	    return new Integer( boolCompDo + nPathDo.intValue() + 1 );
	  }

	private int complexityMultipleOf(SimpleJavaNode node, int npathStart, Object data) {
		
		int npath = npathStart;		
		SimpleJavaNode simpleNode;
		
	    for ( int i = 0; i < node.jjtGetNumChildren(); i++ ) {
	        simpleNode = (SimpleJavaNode) node.jjtGetChild( i );
	        npath *= ((Integer) simpleNode.jjtAccept( this, data )).intValue();
	      }
	    
	    return npath;
	}

	public Object visit(ASTReturnStatement node, Object data) {
	    // return statements are valued at 1, or the value of the boolean expression
	
	    ASTExpression expr = (ASTExpression) node.getFirstChildOfType( ASTExpression.class );
	
	    if ( expr == null ) {
	      return NumericConstants.ONE;
	    }
	
	    List andNodes = expr.findChildrenOfType( ASTConditionalAndExpression.class );
	    List orNodes = expr.findChildrenOfType( ASTConditionalOrExpression.class );
	    int boolCompReturn = andNodes.size() + orNodes.size();
	
	    if ( boolCompReturn > 0 ) {
	      return new Integer( boolCompReturn );
	    }
	    return NumericConstants.ONE;
	  }

	public Object visit(ASTForStatement node, Object data) {
	    // (npath of for + bool_comp of for + 1) * npath of next
	
	    int boolCompFor = sumExpressionComplexity( (ASTExpression) node.getFirstChildOfType( ASTExpression.class ) );
	
	    Integer nPathFor = (Integer) ( (SimpleJavaNode) node.getFirstChildOfType( ASTStatement.class ) ).jjtAccept(
	        this, data );
	
	    return new Integer( boolCompFor + nPathFor.intValue() + 1 );
	  }

	public Object visit(ASTWhileStatement node, Object data) {
	    // (npath of while + bool_comp of while + 1) * npath of next
	
	    int boolCompWhile = sumExpressionComplexity( (ASTExpression) node.getFirstChildOfType( ASTExpression.class ) );
	
	    Integer nPathWhile = (Integer) ( (SimpleJavaNode) node.getFirstChildOfType( ASTStatement.class ) ).jjtAccept(
	        this, data );
	
	    return new Integer( boolCompWhile + nPathWhile.intValue() + 1 );
	  }

	/**
	   * Calculate the boolean complexity of the given expression. NPath boolean
	   * complexity is the sum of && and || tokens. This is calculated by summing
	   * the number of children of the &&'s (minus one) and the children of the ||'s
	   * (minus one).
	   * <p>
	   * Note that this calculation applies to Cyclomatic Complexity as well.
	   * 
	   * @param expr
	   *          control structure expression
	   * @return complexity of the boolean expression
	   */
	  public static int sumExpressionComplexity(ASTExpression expr) {
	    if (expr == null) {
	      return 0;
	    }
	
	    List andNodes = expr.findChildrenOfType( ASTConditionalAndExpression.class );
	    List orNodes = expr.findChildrenOfType( ASTConditionalOrExpression.class );
	
	    int children = 0;
	
	    for ( Iterator iter = orNodes.iterator(); iter.hasNext(); ) {
	      ASTConditionalOrExpression element = (ASTConditionalOrExpression) iter.next();
	      children += element.jjtGetNumChildren();
	      children--;
	    }
	
	    for ( Iterator iter = andNodes.iterator(); iter.hasNext(); ) {
	      ASTConditionalAndExpression element = (ASTConditionalAndExpression) iter.next();
	      children += element.jjtGetNumChildren();
	      children--;
	    }
	
	    return children;
	  }
}
