/*
 Copyright (C) 2003 Morten O. Alver, Nizar N. Batada

 All programs in this directory and
 subdirectories are published under the GNU General Public License as
 described below.

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or (at
 your option) any later version.

 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 USA

 Further information about the GNU GPL is available at:
 http://www.gnu.org/copyleft/gpl.ja.html

 */
package net.sf.jabref;

import java.io.*;
import java.util.HashMap;
import java.util.Iterator;
import java.util.StringTokenizer;
import java.util.Vector;

import javax.swing.JOptionPane;
import javax.swing.event.PopupMenuEvent;

import net.sf.jabref.external.ExternalFileType;
import net.sf.jabref.groups.GroupTreeNode;
import net.sf.jabref.groups.VersionHandling;
import net.sf.jabref.gui.FileListEntry;
import net.sf.jabref.gui.FileListTableModel;
import net.sf.jabref.sql.DBStrings;
import net.sf.jabref.undo.NamedCompound;
import net.sf.jabref.undo.UndoableFieldChange;

public class MetaData implements Iterable<String> {
    private HashMap<String, Vector<String>> metaData = new HashMap<String, Vector<String>>();
    private StringReader data;
    private GroupTreeNode groupsRoot = null;
    private File file = null; // The File where this base gets saved.

    private DBStrings dbStrings = new DBStrings();

    /**
     * The MetaData object stores all meta data sets in Vectors. To ensure that
     * the data is written correctly to string, the user of a meta data Vector
     * must simply make sure the appropriate changes are reflected in the Vector
     * it has been passed.
     */
    public MetaData(HashMap<String, String> inData, BibtexDatabase db) {
        boolean groupsTreePresent = false;
        Vector<String> flatGroupsData = null;
        Vector<String> treeGroupsData = null;
        // The first version (0) lacked a version specification, 
        // thus this value defaults to 0.
        int groupsVersionOnDisk = 0;
        
        if (inData != null) 
        	for (String key : inData.keySet()){
            data = new StringReader(inData.get(key));
            String unit;
            Vector<String> orderedData = new Vector<String>();
            // We must allow for ; and \ in escape sequences.
            try {
                while ((unit = getNextUnit(data)) != null) {
                    orderedData.add(unit);
                }
            } catch (IOException ex) {
                System.err.println("Weird error while parsing meta data.");
            }
            if (key.equals("groupsversion")) {
                if (orderedData.size() >= 1)
                    groupsVersionOnDisk = Integer.parseInt(orderedData.firstElement().toString());
            } else if (key.equals("groupstree")) {
                groupsTreePresent = true;
                treeGroupsData = orderedData; // save for later user
                // actual import operation is handled later because "groupsversion"
                // tag might not yet have been read
            } else if (key.equals("groups")) {
                flatGroupsData = orderedData;
            } else {
                putData(key, orderedData);
            }
        }
        
        // this possibly handles import of a previous groups version
        if (groupsTreePresent)
            putGroups(treeGroupsData, db, groupsVersionOnDisk);
        
        if (!groupsTreePresent && flatGroupsData != null) {
            groupsRoot = VersionHandling.importFlatGroups(flatGroupsData);
        }
    }

    /**
     * The MetaData object can be constructed with no data in it.
     */
    public MetaData() {

    }

    /**
     * Add default metadata for new database:
     */
    public void initializeNewDatabase() {
        metaData.put(Globals.SELECTOR_META_PREFIX + "keywords", new Vector<String>());
        metaData.put(Globals.SELECTOR_META_PREFIX + "author", new Vector<String>());
        metaData.put(Globals.SELECTOR_META_PREFIX + "journal", new Vector<String>());
        metaData.put(Globals.SELECTOR_META_PREFIX + "publisher", new Vector<String>());
        metaData.put(Globals.SELECTOR_META_PREFIX + "review", new Vector<String>());
    }

    public Iterator<String> iterator() {
        return metaData.keySet().iterator();
    }

    public Vector<String> getData(String key) {
        return metaData.get(key);
    }

    public void remove(String key) {
        metaData.remove(key);
    }

    /**
     * Stores the specified data in this object, using the specified key. For
     * certain keys (e.g. "groupstree"), the objects in orderedData are
     * reconstructed from their textual (String) representation if they are of
     * type String, and stored as an actual instance.
     */
    public void putData(String key, Vector<String> orderedData) {
        metaData.put(key, orderedData);
    }

    /**
     * Look up the directory set up for the given field type for this database.
     * If no directory is set up, return that defined in global preferences.
     * @param fieldName The field type
     * @return The default directory for this field type.
     */
    public String getFileDirectory(String fieldName) {
        // There can be up to three directory definitions for these files - the database's
        // metadata can specify a general directory and/or a user-specific directory, or
	// the preferences can specify one. The settings are prioritized in the following
	// order and the first defined setting is used: metadata user-specific directory,
	// metadata general directory, preferences directory.
        String key = Globals.prefs.get("userFileDirIndividual");
        String dir;
        Vector<String> vec = getData(key);
	if (vec == null) {
	    key = Globals.prefs.get("userFileDir");
	    vec = getData(key);
	}
        if ((vec != null) && (vec.size() > 0)) {
            dir = vec.get(0);
            // If this directory is relative, we try to interpret it as relative to
            // the file path of this bib file:
            if (!(new File(dir)).isAbsolute() && (file != null)) {
                String relDir = new StringBuffer(file.getParent()).
                        append(System.getProperty("file.separator")).
                        append(dir).toString();
                // If this directory actually exists, it is very likely that the
                // user wants us to use it:
                if ((new File(relDir)).exists())
                    dir = relDir;
            }
        }
        else {
            dir = Globals.prefs.get(fieldName + "Directory");
	}

        return dir;
    }

    private void putGroups(Vector<String> orderedData, BibtexDatabase db, int version) {
        try {
            groupsRoot = VersionHandling.importGroups(orderedData, db, 
                    version);
        } catch (Exception e) {
            // we cannot really do anything about this here
            System.err.println(e);
        }
    }

    public GroupTreeNode getGroups() {
        return groupsRoot;
    }
    
    /**
     * Sets a new group root node. <b>WARNING </b>: This invalidates everything
     * returned by getGroups() so far!!!
     */
    public void setGroups(GroupTreeNode root) {
        groupsRoot = root;
    }

    /**
     * Writes all data to the specified writer, using each object's toString()
     * method.
     */
    public void writeMetaData(Writer out) throws IOException {
        // write all meta data except groups
        for (Iterator<String> i = metaData.keySet().iterator(); i.hasNext();) {
            String key = i.next();
            StringBuffer sb = new StringBuffer();
            Vector<String> orderedData = metaData.get(key);
            if (orderedData.size() >= 0) {
                sb.append("@comment{").append(GUIGlobals.META_FLAG).append(key).append(":");
                for (int j = 0; j < orderedData.size(); j++) {
                    sb.append(Util.quote(orderedData.elementAt(j), ";", '\\')).append(";");
                }
                sb.append("}");
            }
            wrapStringBuffer(sb, Globals.METADATA_LINE_LENGTH);
            sb.append(Globals.NEWLINE);
            sb.append(Globals.NEWLINE);
            
            out.write(sb.toString());
        }
        // write groups if present. skip this if only the root node exists 
        // (which is always the AllEntriesGroup).
        if (groupsRoot != null && groupsRoot.getChildCount() > 0) {
            StringBuffer sb = new StringBuffer();
            // write version first
            sb.append("@comment{").append(GUIGlobals.META_FLAG).append("groupsversion:");
            sb.append(""+VersionHandling.CURRENT_VERSION+";");
            sb.append("}");
            sb.append(Globals.NEWLINE);
            sb.append(Globals.NEWLINE);
            out.write(sb.toString());
            
            // now write actual groups
            sb = new StringBuffer();
            sb.append("@comment{").append(GUIGlobals.META_FLAG).append("groupstree:");
            sb.append(Globals.NEWLINE);
            // GroupsTreeNode.toString() uses "\n" for separation
            StringTokenizer tok = new StringTokenizer(groupsRoot.getTreeAsString(),Globals.NEWLINE);
            while (tok.hasMoreTokens()) {
                StringBuffer s = 
                    new StringBuffer(Util.quote(tok.nextToken(), ";", '\\') + ";");
                wrapStringBuffer(s, Globals.METADATA_LINE_LENGTH);
                sb.append(s);
                sb.append(Globals.NEWLINE);
            }
            sb.append("}");
            sb.append(Globals.NEWLINE);
            sb.append(Globals.NEWLINE);
            out.write(sb.toString());
        }
    }

    private void wrapStringBuffer(StringBuffer sb, int lineLength) {
        for (int i=lineLength; i<sb.length(); i+=lineLength+Globals.NEWLINE_LENGTH) {
            sb.insert(i, Globals.NEWLINE);
        }
    }
    
    /**
     * Reads the next unit. Units are delimited by ';'. 
     */
    private String getNextUnit(Reader reader) throws IOException {
        int c;
        boolean escape = false;
        StringBuffer res = new StringBuffer();
        while ((c = reader.read()) != -1) {
            if (escape) {
                res.append((char)c);
                escape = false;
            } else if (c == '\\') {
                escape = true;
            } else if (c == ';') {
                break;
            } else {
                res.append((char)c);
            }
        }
        if (res.length() > 0)
            return res.toString();
        return null;
    }

    public File getFile() {
        return file;
    }

    public void setFile(File file) {
        this.file = file;
    }

    public DBStrings getDBStrings() {
        return dbStrings;
    }

    public void setDBStrings(DBStrings dbStrings) {
        this.dbStrings = dbStrings;
    }

	/**
	 * Set the dynamic contents of "Add to group ..." submenu.
	 */
	public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
	    BibtexEntry[] bes = panel.getSelectedEntries();
	    panel.storeCurrentEdit();
	    GroupTreeNode groups = metaData.getGroups();
	    if (groups == null) {
	        groupAddMenu.setEnabled(false);
	        groupMoveMenu.setEnabled(false);
	        groupRemoveMenu.setEnabled(false);
	        return;
	    }
	
	    groupAddMenu.setEnabled(true);
	    groupMoveMenu.setEnabled(true);
	    groupRemoveMenu.setEnabled(true);
	    groupAddMenu.removeAll();
	    groupMoveMenu.removeAll();
	    groupRemoveMenu.removeAll();
	
	    if (bes == null)
	        return;
	    add(groupAddMenu);
	    add(groupMoveMenu);
	    add(groupRemoveMenu);
	
	    groupAddMenu.setEnabled(false);
	    groupMoveMenu.setEnabled(false);
	    groupRemoveMenu.setEnabled(false);
	    insertNodes(groupAddMenu,metaData.getGroups(),bes,true,false);
	    insertNodes(groupMoveMenu,metaData.getGroups(),bes,true,true);
	    insertNodes(groupRemoveMenu,metaData.getGroups(),bes,false,false);
	
	    addSeparator();
	    floatMarked.setSelected(Globals.prefs.getBoolean("floatMarkedEntries"));
	    add(floatMarked);
	}

	/**
	 * Copy the given file to the base directory for its file type, and give it
	 * the given name.
	 * 
	 * @param fileName
	 *            The name of the source file.
	 * @param fileType
	 *            The FileType associated with the file.
	 * @param toFile
	 *            The destination filename. An existing path-component will be removed.
	 * @param edits
	 *            TODO we should be able to undo this!
	 * @return
	 */
	private boolean doCopy(String fileName, ExternalFileType fileType, String toFile,
	    NamedCompound edits) {
	
	    String dir = panel.metaData().getFileDirectory(GUIGlobals.FILE_FIELD);
	    if ((dir == null) || !(new File(dir)).exists()) {
	        // OOps, we don't know which directory to put it in, or the given
	        // dir doesn't exist....
	        System.out.println("dir: " + dir + "\t ext: " + fileType.getExtension());
	        return false;
	    }
	    toFile = new File(toFile).getName();
	    
	    File destFile = new File(new StringBuffer(dir).append(System.getProperty("file.separator"))
	        .append(toFile).toString());
	    if (destFile.equals(new File(fileName))){
	        // File is already in the correct position. Don't override!
	        return true;
	    }
	    
	    if (destFile.exists()) {
	        int answer = JOptionPane.showConfirmDialog(frame, "'" + destFile.getPath() + "' "
	            + Globals.lang("exists. Overwrite?"), Globals.lang("File exists"),
	            JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
	        if (answer == JOptionPane.NO_OPTION)
	            return false;
	    }
	    try {
	        Util.copyFile(new File(fileName), destFile, true);
	    } catch (IOException e) {
	        e.printStackTrace();
	        return false;
	    }
	
	    return true;
	}

	/**
	 * Make a extension to the file.
	 * 
	 * @param entry
	 *            The entry to extension from.
	 * @param fileType
	 *            The FileType associated with the file.
	 * @param filename
	 *            The path to the file.
	 * @param edits
	 *            An NamedCompound action this action is to be added to. If none
	 *            is given, the edit is added to the panel's undoManager.
	 */
	private void doLink(BibtexEntry entry, ExternalFileType fileType, String filename,
	    boolean avoidDuplicate, NamedCompound edits) {
	
	
	    String oldValue = entry.getField(GUIGlobals.FILE_FIELD);
	    FileListTableModel tm = new FileListTableModel();
	    if (oldValue != null)
	        tm.setContent(oldValue);
	
	    // If avoidDuplicate==true, we should check if this file is already linked:
	    if (avoidDuplicate) {
	        // For comparison, find the absolute filename:
	        String fileDir = panel.metaData().getFileDirectory(GUIGlobals.FILE_FIELD);
	        String absFilename = (!(new File(filename).isAbsolute()) && (fileDir != null)) ?
	                new File(fileDir, filename).getAbsolutePath() : filename;
	        System.out.println("absFilename: "+absFilename);
	        
	        for (int i=0; i<tm.getRowCount(); i++) {
	            FileListEntry flEntry = tm.getEntry(i);
	            // Find the absolute filename for this existing link:
	            String absName = (!(new File(flEntry.getLink()).isAbsolute()) && (fileDir != null)) ?
	                    new File(fileDir, flEntry.getLink()).getAbsolutePath() : flEntry.getLink();
	            System.out.println("absName: "+absName);
	            // If the filenames are equal, we don't need to link, so we simply return:
	            if (absFilename.equals(absName))
	                return;
	        }
	    }
	
	    tm.addEntry(tm.getRowCount(), new FileListEntry("", filename, fileType));
	    String newValue = tm.getStringRepresentation();
	    UndoableFieldChange edit = new UndoableFieldChange(entry, GUIGlobals.FILE_FIELD,
	            oldValue, newValue);
	    entry.setField(GUIGlobals.FILE_FIELD, newValue);
	
	    if (edits == null) {
	        panel.undoManager.addEdit(edit);
	    } else {
	        edits.addEdit(edit);
	    }
	}

	/**
	 * Move the given file to the base directory for its file type, and rename
	 * it to the given filename.
	 * 
	 * @param fileName
	 *            The name of the source file.
	 * @param fileType
	 *            The FileType associated with the file.
	 * @param destFilename
	 *            The destination filename.
	 * @param edits
	 *            TODO we should be able to undo this action
	 * @return true if the operation succeeded.
	 */
	private boolean doMove(String fileName, ExternalFileType fileType, String destFilename,
	    NamedCompound edits) {
	    String dir = panel.metaData().getFileDirectory(GUIGlobals.FILE_FIELD);
	    if ((dir == null) || !(new File(dir)).exists()) {
	        // OOps, we don't know which directory to put it in, or the given
	        // dir doesn't exist....
	        // This should not happen!!
	        return false;
	    }
	    File fromFile = new File(fileName);
	    File toFile = new File(dir + System.getProperty("file.separator") + destFilename);
	    if (toFile.exists()) {
	    	int answer = JOptionPane.showConfirmDialog(frame,
	    			toFile.getAbsolutePath() + " exists. Overwrite?", "Overwrite file?", 
	    			JOptionPane.YES_NO_OPTION);
	    	if (answer == JOptionPane.NO_OPTION) {
	    		return false;
	    	}
	    }
	
	    if (!fromFile.renameTo(toFile)) {
	    	JOptionPane.showMessageDialog(frame,
	    			"There was an error moving the file. Please move the file manually and link in place.",
	    			"Error moving file", JOptionPane.ERROR_MESSAGE);
	    	return false;
	    } else {
	    	return true;
	    }
	
	}
}
