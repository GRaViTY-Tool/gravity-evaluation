package net.sf.jabref.collab;

import java.io.File;
import java.util.HashSet;
import java.util.Iterator;

import javax.swing.tree.DefaultMutableTreeNode;

import net.sf.jabref.*;
import net.sf.jabref.export.FileActions;
import net.sf.jabref.export.SaveException;
import net.sf.jabref.export.SaveSession;
import net.sf.jabref.groups.GroupTreeNode;


public class ChangeScanner extends Thread {

    final double MATCH_THRESHOLD = 0.4;
    final String[] sortBy = new String[] {"year", "author", "title" };
    File f;
    BibtexDatabase inMem, inTemp = null;
    MetaData mdInMem, mdInTemp;
    BasePanel panel;
    JabRefFrame frame;

    /**
     * We create an ArrayList to hold the changes we find. These will be added in the form
     * of UndoEdit objects. We instantiate these so that the changes found in the file on disk
     * can be reproduced in memory by calling redo() on them. REDO, not UNDO!
     */
    //ArrayList changes = new ArrayList();
    DefaultMutableTreeNode changes = new DefaultMutableTreeNode(Globals.lang("External changes"));

    //  NamedCompound edit = new NamedCompound("Merged external changes")

    public ChangeScanner(JabRefFrame frame, BasePanel bp) { //, BibtexDatabase inMem, MetaData mdInMem) {
        panel = bp;
        this.frame = frame;
        this.inMem = bp.database();
        this.mdInMem = bp.metaData();
        // Set low priority:
        setPriority(Thread.MIN_PRIORITY);

    }

    public void changeScan(File f) {
        this.f = f;
        start();
    }

    private void storeTempDatabase() {
        new Thread(new Runnable() {
            public void run() {
                try {
                    SaveSession ss = FileActions.saveDatabase(inTemp, mdInTemp,
                        Globals.fileUpdateMonitor.getTempFile(panel.fileMonitorHandle()), Globals.prefs,
                        false, false, panel.getEncoding(), true);
                    ss.commit();
                } catch (SaveException ex) {
                    System.out.println("Problem updating tmp file after accepting external changes");
                }


            }
        }).start();
    }

    private BibtexString findString(BibtexDatabase base, String name, HashSet<Object> used) {
        if (!base.hasStringLabel(name))
            return null;
        for (Iterator<String> i=base.getStringKeySet().iterator(); i.hasNext();) {
            String key = i.next();
            BibtexString bs = base.getString(key);
            if (bs.getName().equals(name) && !used.contains(key)) {
                used.add(key);
                return bs;
            }
        }
        return null;
    }

    /**
     * This method only detects wheter a change took place or not. It does not
     * determine the type of change. This would be possible, but difficult to do
     * properly, so I rather only report the change.
     */
    public void scanGroups(MetaData inMem, MetaData onTmp, MetaData onDisk) {
        final GroupTreeNode groupsTmp = onTmp.getGroups();
        final GroupTreeNode groupsDisk = onDisk.getGroups();
        if (groupsTmp == null && groupsDisk == null)
            return;
        if ((groupsTmp != null && groupsDisk == null)
                || (groupsTmp == null && groupsDisk != null)) {
            changes.add(new GroupChange(groupsDisk, groupsTmp));
            return;
        }
        if (groupsTmp.equals(groupsDisk))
            return;
        changes.add(new GroupChange(groupsDisk, groupsTmp));
        return;

//
//        if (((vOnTmp == null) || (vOnTmp.size()==0)) && ((vOnDisk == null) || (vOnDisk.size()==0))) {
//            // No groups defined in either the tmp or disk version.
//            return;
//        }
//
//        // To avoid checking for null all the time, make empty vectors to replace null refs. We clone
//        // non-null vectors so we can remove the elements as we finish with them.
//        if (vOnDisk == null)
//            vOnDisk = new Vector(0);
//        else
//            vOnDisk = (Vector)vOnDisk.clone();
//        if (vOnTmp == null)
//            vOnTmp = new Vector(0);
//        else
//            vOnTmp = (Vector)vOnTmp.clone();
//        if (vInMem == null)
//            vInMem = new Vector(0);
//        else
//            vInMem = (Vector)vInMem.clone();
//
//        // If the tmp version has groups, iterate through these and compare with disk version:
//        while (vOnTmp.size() >= 1) {
//            AbstractGroup group = (AbstractGroup)vOnTmp.firstElement();
//            vOnTmp.removeElementAt(0);
//            int pos = GroupSelector.findGroupByName(vOnDisk,group.getName());
//            if (pos == -1) {
//                // Couldn't find the group.
//                changes.add(new GroupAddOrRemove(group, false));
//            } else {
//                AbstractGroup diskGroup = (AbstractGroup)vOnDisk.elementAt(pos);
//
//                if (!diskGroup.equals(group)) {
//                    // Group has changed.
//                    changes.add(new GroupChange(inMem, group, diskGroup));
//                }
//
//                // Remove this group, since it's been accounted for.
//                vOnDisk.remove(pos);
//            }
//        }
//
//        // If there are entries left in the disk version, these must have been added.
//        while (vOnDisk.size() >= 1) {
//            AbstractGroup group = (AbstractGroup)vOnDisk.firstElement();
//            vOnDisk.removeElementAt(0);
//            changes.add(new GroupAddOrRemove(group, true));
//        }
    }


    public static interface DisplayResultCallback {
        public void scanResultsResolved(boolean resolved);
    }
}
