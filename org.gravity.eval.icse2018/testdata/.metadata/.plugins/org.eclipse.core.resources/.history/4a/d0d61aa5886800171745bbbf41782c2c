package net.sourceforge.pmd.ast;

import java.util.List;

public class AccessNode extends SimpleJavaNode {

    public static final int PUBLIC = 0x0001;
    public static final int PROTECTED = 0x0002;
    public static final int PRIVATE = 0x0004;
    public static final int ABSTRACT = 0x0008;
    public static final int STATIC = 0x0010;
    public static final int FINAL = 0x0020;
    public static final int SYNCHRONIZED = 0x0040;
    public static final int NATIVE = 0x0080;
    public static final int TRANSIENT = 0x0100;
    public static final int VOLATILE = 0x0200;
    public static final int STRICTFP = 0x1000;

    public AccessNode(int i) {
        super(i);
    }

    public AccessNode(JavaParser parser, int i) {
        super(parser, i);
    }

    private int modifiers;

    public void setModifiers(int m) {
        this.modifiers = m;
    }

    public boolean isPublic() {
        return (modifiers & PUBLIC) != 0;
    }

    public boolean isProtected() {
        return (modifiers & PROTECTED) != 0;
    }

    public boolean isPrivate() {
        return (modifiers & PRIVATE) != 0;
    }

    public boolean isStatic() {
        return (modifiers & STATIC) != 0;
    }

    public boolean isAbstract() {
        return (modifiers & ABSTRACT) != 0;
    }

    public boolean isFinal() {
        return (modifiers & FINAL) != 0;
    }

    public boolean isNative() {
        return (modifiers & NATIVE) != 0;
    }

    public boolean isStrictfp() {
        return (modifiers & STRICTFP) != 0;
    }

    public boolean isSynchronized() {
        return (modifiers & SYNCHRONIZED) != 0;
    }

    public boolean isTransient() {
        return (modifiers & TRANSIENT) != 0;
    }

    public boolean isVolatile() {
        return (modifiers & VOLATILE) != 0;
    }

    public void setPublic() {
        modifiers |= PUBLIC;
    }

    public void setPrivate() {
        modifiers |= PRIVATE;
    }

    public void setProtected() {
        modifiers |= PROTECTED;
    }

    public void setSynchronized() {
        modifiers |= SYNCHRONIZED;
    }

    public void setVolatile() {
        modifiers |= VOLATILE;
    }

    public void setAbstract() {
        modifiers |= ABSTRACT;
    }

    public void setStatic() {
        modifiers |= STATIC;
    }

    public void setTransient() {
        modifiers |= TRANSIENT;
    }

    public void setFinal() {
        modifiers |= FINAL;
    }

    public void setNative() {
        modifiers |= NATIVE;
    }

    public void setStrictfp() {
        modifiers |= STRICTFP;
    }

    /**
     * Removes the given modifier.
     */
    static int removeModifier(int modifiers, int mod) {
        return modifiers & ~mod;
    }

    public boolean isPackagePrivate() {
        return !isPrivate() && !isPublic() && !isProtected();
    }

    public String collectDumpedModifiers(String prefix) {
        String out = toString(prefix) + ":";
        if (isPackagePrivate()) {
            out += "(package private)";
        }
        if (isPrivate()) {
            out += "(private)";
        }
        if (isPublic()) {
            out += "(public)";
        }
        if (isProtected()) {
            out += "(protected)";
        }
        if (isAbstract()) {
            out += "(abstract)";
        }
        if (isStatic()) {
            out += "(static)";
        }
        if (isFinal()) {
            out += "(final)";
        }
        if (isSynchronized()) {
            out += "(synchronized)";
        }
        if (isNative()) {
            out += "(native)";
        }
        if (isStrictfp()) {
            out += "(strict)";
        }
        if (isTransient()) {
            out += "(transient)";
        }
        return out;
    }

	public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
	    if (!node.isInterface() && node.isNested() && (node.isPublic() || node.isStatic())) {
	        ASTClassOrInterfaceDeclaration parent = (ASTClassOrInterfaceDeclaration) node.getFirstParentOfType(ASTClassOrInterfaceDeclaration.class);
	        if (parent != null && parent.isInterface()) {
	            addViolation(data, node, getMessage());
	        }
	    } else if (node.isInterface() && node.isNested() && (node.isPublic() || node.isStatic())) {
	        ASTClassOrInterfaceDeclaration parent = (ASTClassOrInterfaceDeclaration) node.getFirstParentOfType(ASTClassOrInterfaceDeclaration.class);
	        if (parent.isInterface() || (!parent.isInterface() && node.isStatic())) {
	            addViolation(data, node, getMessage());
	        }
	    }
	    return super.visit(node, data);
	}

	private void check(SimpleNode fieldOrMethod, Object data) {
	    // third ancestor could be an AllocationExpression
	    // if this is a method in an anonymous inner class
	    Node parent = fieldOrMethod.jjtGetParent().jjtGetParent().jjtGetParent();
	    if (parent instanceof ASTClassOrInterfaceDeclaration && ((ASTClassOrInterfaceDeclaration) parent).isInterface()) {
	        addViolation(data, fieldOrMethod);
	    }
	}

	public Object visit(ASTMethodDeclaration method, Object data) {
	    if (!method.isPublic() || method.isAbstract() || method.isNative() || method.isStatic()) {
	        return data; // skip various inapplicable method variations
	    }
	
	    Node node = method.jjtGetChild(0);
	    if (node instanceof ASTTypeParameters) {
	        node = method.jjtGetChild(1);
	    }
	    if (((ASTResultType)node).isVoid() && method.getMethodName().startsWith("test"))  {
	        if (!containsAssert(method.getBlock(), false)) {
	            addViolation(data, method);
	        }
	    }
		return data;
	}

	/**
	 * Tells if the expression is an assert statement or not.
	 */
	private boolean isAssertOrFailStatement(ASTStatementExpression expression) {
	    if (expression!=null 
	            && expression.jjtGetNumChildren()>0
	            && expression.jjtGetChild(0) instanceof ASTPrimaryExpression
	            ) {
	        ASTPrimaryExpression pe = (ASTPrimaryExpression) expression.jjtGetChild(0);
	        if (pe.jjtGetNumChildren()> 0 && pe.jjtGetChild(0) instanceof ASTPrimaryPrefix) {
	            ASTPrimaryPrefix pp = (ASTPrimaryPrefix) pe.jjtGetChild(0);
	            if (pp.jjtGetNumChildren()>0 && pp.jjtGetChild(0) instanceof ASTName) {
	                ASTName n = (ASTName) pp.jjtGetChild(0);
	                if (n.getImage()!=null && (n.getImage().startsWith("assert") || n.getImage().startsWith("fail") )) {
	                    return true;
	                }
	            }
	        }
	    }
	    return false;
	}

	public Object visit(ASTMethodDeclaration node, Object data) {
	    // Can skip abstract methods and methods whose only purpose is to
	    // guarantee that the inherited method is not changed by finalizing
	    // them.
	    if (node.isAbstract() || node.isFinal() || node.isNative() || node.isSynchronized()) {
	        return super.visit(node, data);
	    }
	
	    ASTBlock block = node.getBlock();
	    if (block == null) {
	        return super.visit(node, data);
	    }
	    //Only process functions with one BlockStatement
	    if (block.jjtGetNumChildren() != 1 || block.findChildrenOfType(ASTStatement.class).size() != 1)
	        return super.visit(node, data);
	
	    ASTStatement statement = (ASTStatement) block.jjtGetChild(0).jjtGetChild(0);
	    if (statement.jjtGetChild(0).jjtGetNumChildren() == 0) {
	        return data;     // skips empty return statements
	    }
	    SimpleNode statementGrandChild = (SimpleNode) statement.jjtGetChild(0).jjtGetChild(0);
	    ASTPrimaryExpression primaryExpression;
	
	    if (statementGrandChild instanceof ASTPrimaryExpression)
	        primaryExpression = (ASTPrimaryExpression) statementGrandChild;
	    else {
	        List primaryExpressions = findFirstDegreeChildrenOfType(statementGrandChild, ASTPrimaryExpression.class);
	        if (primaryExpressions.size() != 1)
	            return super.visit(node, data);
	        primaryExpression = (ASTPrimaryExpression) primaryExpressions.get(0);
	    }
	
	    ASTPrimaryPrefix primaryPrefix = (ASTPrimaryPrefix) findFirstDegreeChildrenOfType(primaryExpression, ASTPrimaryPrefix.class).get(0);
	    if (!primaryPrefix.usesSuperModifier())
	        return super.visit(node, data);
	
	    ASTMethodDeclarator methodDeclarator = (ASTMethodDeclarator) findFirstDegreeChildrenOfType(node, ASTMethodDeclarator.class).get(0);
	    if (!primaryPrefix.hasImageEqualTo(methodDeclarator.getImage()))
	        return super.visit(node, data);
	
	    //Process arguments
	    ASTPrimarySuffix primarySuffix = (ASTPrimarySuffix) findFirstDegreeChildrenOfType(primaryExpression, ASTPrimarySuffix.class).get(0);
	    ASTArguments arguments = (ASTArguments) primarySuffix.jjtGetChild(0);
	    ASTFormalParameters formalParameters = (ASTFormalParameters) methodDeclarator.jjtGetChild(0);
	    if (formalParameters.jjtGetNumChildren() != arguments.jjtGetNumChildren())
	        return super.visit(node, data);
	
	    if (arguments.jjtGetNumChildren() == 0) //No arguments to check
	        addViolation(data, node, getMessage());
	    else {
	        ASTArgumentList argumentList = (ASTArgumentList) arguments.jjtGetChild(0);
	        for (int i = 0; i < argumentList.jjtGetNumChildren(); i++) {
	            Node ExpressionChild = argumentList.jjtGetChild(i).jjtGetChild(0);
	            if (!(ExpressionChild instanceof ASTPrimaryExpression) || ExpressionChild.jjtGetNumChildren() != 1)
	                return super.visit(node, data); //The arguments are not simply passed through
	
	            ASTPrimaryExpression argumentPrimaryExpression = (ASTPrimaryExpression) ExpressionChild;
	            ASTPrimaryPrefix argumentPrimaryPrefix = (ASTPrimaryPrefix) argumentPrimaryExpression.jjtGetChild(0);
	            if (argumentPrimaryPrefix.jjtGetNumChildren() == 0) {
	                return super.visit(node, data); //The arguments are not simply passed through (using "this" for instance)
	            }
	            Node argumentPrimaryPrefixChild = argumentPrimaryPrefix.jjtGetChild(0);
	            if (!(argumentPrimaryPrefixChild instanceof ASTName))
	                return super.visit(node, data); //The arguments are not simply passed through
	
	            if (formalParameters.jjtGetNumChildren() < i + 1) {
	                return super.visit(node, data); // different number of args
	            }
	
	            ASTName argumentName = (ASTName) argumentPrimaryPrefixChild;
	            ASTFormalParameter formalParameter = (ASTFormalParameter) formalParameters.jjtGetChild(i);
	            ASTVariableDeclaratorId variableId = (ASTVariableDeclaratorId) findFirstDegreeChildrenOfType(formalParameter, ASTVariableDeclaratorId.class).get(0);
	            if (!argumentName.hasImageEqualTo(variableId.getImage())) {
	                return super.visit(node, data); //The arguments are not simply passed through
	            }
	
	        }
	        addViolation(data, node, getMessage()); //All arguments are passed through directly
	    }
	    return super.visit(node, data);
	}
}
