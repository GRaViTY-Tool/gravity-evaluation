/*
Copyright (C) 2003 David Weitzman, Morten O. Alver

All programs in this directory and
subdirectories are published under the GNU General Public License as
described below.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA

Further information about the GNU GPL is available at:
http://www.gnu.org/copyleft/gpl.ja.html

Note:
Modified for use in JabRef.

*/
package net.sf.jabref;

import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.TreeMap;

import javax.xml.parsers.SAXParserFactory;

import net.sf.jabref.imports.BibtexParser;
import net.sf.jabref.imports.OAI2Handler;
import net.sf.jabref.imports.ParserResult;
import net.sf.jabref.undo.UndoableInsertEntry;
import net.sf.jabref.util.XMPUtil;

import java.util.Locale;

public abstract class BibtexEntryType implements Comparable<BibtexEntryType>
{

    public static final BibtexEntryType OTHER =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Other";
            }

            public String[] getOptionalFields()
            {
                return new String[0];
            }

            public String[] getRequiredFields()
            {
                return new String[0];
            }


            public String describeRequiredFields()
            {
                return "";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return true;
            }
        };


    public static final BibtexEntryType ARTICLE =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Article";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "number", "month", "part", "eid", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "journal", "year", "volume", "pages"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE, JOURNAL and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "author", "title", "journal", "year", "bibtexkey", "volume", "pages"
                    }, database);
            }
        };

    public static final BibtexEntryType BOOKLET =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Booklet";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "author", "howpublished", "lastchecked", "address", "month", "year", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "title"
                };
            }

            public String describeRequiredFields()
            {
                return "TITLE";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "title", "bibtexkey"
                    }, database);
            }
        };


   public static final BibtexEntryType INBOOK =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Inbook";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "volume", "number", "pages", "series", "type", "address", "edition",
		    "month", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "chapter", "pages", "title", "publisher", "year", "editor",
		    "author"
                };
            }

            @Override
            public String[] getRequiredFieldsForCustomization() {
                return new String[] {"author/editor", "title", "chapter/pages", "year", "publisher"};
            }

            public String describeRequiredFields()
            {
                return "TITLE, CHAPTER and/or PAGES, PUBLISHER, YEAR, and an "
		    +"EDITOR and/or AUTHOR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "title", "publisher", "year", "bibtexkey"
                    }, database) &&
		    (((entry.getField("author") != null) ||
		      (entry.getField("editor") != null)) &&
		     ((entry.getField("chapter") != null) ||
		      (entry.getField("pages") != null)));
            }
        };

    public static final BibtexEntryType BOOK =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Book";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "volume", "number", "pages", "series", "address", "edition", "month",
                    "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "title", "publisher", "year", "editor", "author"
                };
            }

            public String[] getRequiredFieldsForCustomization()
            {
                return new String[]
                {
                    "title", "publisher", "year", "author/editor"
                };
            }

            public String describeRequiredFields()
            {
                return "TITLE, PUBLISHER, YEAR, and an EDITOR and/or AUTHOR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "title", "publisher", "year", "bibtexkey"
                    }, database) &&
                ((entry.getField("author") != null) ||
                (entry.getField("editor") != null));
            }
        };


    public static final BibtexEntryType INCOLLECTION =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Incollection";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "editor", "volume", "number", "series", "type", "chapter",
		    "pages", "address", "edition", "month", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "booktitle", "publisher", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE, BOOKTITLE, PUBLISHER and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
			"author", "title", "booktitle", "publisher", "year",
			"bibtexkey"

                    }, database);
            }
        };

    public static final BibtexEntryType CONFERENCE =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Conference";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "editor", "volume", "number", "series", "pages",
		    "address", "month", "organization", "publisher", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "booktitle", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE, BOOKTITLE and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
			"author", "title", "booktitle", "year" , "bibtexkey"
                    }, database);
            }
        };

    public static final BibtexEntryType INPROCEEDINGS =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Inproceedings";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "editor", "volume", "number", "series", "pages",
		    "address", "month", "organization", "publisher", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "booktitle", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE, BOOKTITLE and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
			"author", "title", "booktitle", "year" , "bibtexkey"
                    }, database);
            }
        };

    public static final BibtexEntryType PROCEEDINGS =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Proceedings";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "editor", "volume", "number", "series", "address",
		    "publisher", "note", "month", "organization"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "title", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "TITLE and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
			"title", "year", "bibtexkey"
                    }, database);
            }
        };


    public static final BibtexEntryType MANUAL =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Manual";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "author", "organization", "address", "edition",
		    "month", "year", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "title"
                };
            }

            public String describeRequiredFields()
            {
                return "TITLE";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "title", "bibtexkey"
                    }, database);
            }
        };

    public static final BibtexEntryType TECHREPORT =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Techreport";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "type", "number", "address", "month", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "institution", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE, INSTITUTION and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
			"author", "title", "institution", "year",
			"bibtexkey"
                    }, database);
            }
        };


    public static final BibtexEntryType MASTERSTHESIS =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Mastersthesis";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "type", "address", "month", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "school", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE, SCHOOL and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "author", "title", "school", "year", "bibtexkey"
                    }, database);
            }
        };


    public static final BibtexEntryType PHDTHESIS =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Phdthesis";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "type", "address", "month", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "school", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE, SCHOOL and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "author", "title", "school", "year", "bibtexkey"
                    }, database);
            }
        };

    public static final BibtexEntryType UNPUBLISHED =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Unpublished";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "month", "year"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "author", "title", "note"
                };
            }

            public String describeRequiredFields()
            {
                return "AUTHOR, TITLE and NOTE";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
			"author", "title", "note", "bibtexkey"
                    }, database);
            }
        };

     public static final BibtexEntryType PERIODICAL =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Periodical";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "editor", "language", "series", "volume", "number", "organization", "month", "note", "url"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "title", "year"
                };
            }

            public String describeRequiredFields()
            {
                return "TITLE and YEAR";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "title", "year", "bibtexkey"
                    }, database);
            }
        };

     public static final BibtexEntryType PATENT =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Patent";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "author", "title", "language", "assignee", "address", "type", "number", "day", "dayfiled", "month", "monthfiled", "note", "url"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "nationality", "number", "year", "yearfiled"
                };
            }

            public String describeRequiredFields()
            {
                return "NATIONALITY, NUMBER, YEAR or YEARFILED";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "number", "bibtexkey"
                    }, database) &&
                ((entry.getField("year") != null) ||
                (entry.getField("yearfiled") != null));
            }
        };

   public static final BibtexEntryType STANDARD =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Standard";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "author", "language", "howpublished", "type", "number", "revision", "address", "month", "year", "note", "url"
                };
            }

            public String[] getRequiredFields()
            {
                return new String[]
                {
                    "title", "organization", "institution"
                };
            }

            @Override
            public String[] getRequiredFieldsForCustomization() {
                return new String[] {"title", "organization/institution"};
            }

            public String describeRequiredFields()
            {
                return "TITLE, ORGANIZATION or INSTITUTION";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "title", "bibtexkey"
                    }, database) &&
                ((entry.getField("organization") != null) ||
                (entry.getField("institution") != null));
            }
        };

    public static final BibtexEntryType ELECTRONIC =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Electronic";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "author", "month", "year", "title", "language", "howpublished", "organization", "address", "note", "url"
                };
            }

            public String[] getRequiredFields()
            {
                return null;
            }

            public String describeRequiredFields()
            {
                return "None";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
                return entry.allFieldsPresent(new String[]
                    {
                        "bibtexkey"
                    }, database);
            }
        };

    public static final BibtexEntryType MISC =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Misc";
            }

            public String[] getOptionalFields()
            {
                return new String[]
                {
                    "author", "title", "howpublished", "month", "year", "note"
                };
            }

            public String[] getRequiredFields()
            {
                return null;
            }

            public String describeRequiredFields()
            {
                return "None";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
		return entry.allFieldsPresent(new String[]
                    {
			"bibtexkey"
                    }, database);
            }
        };

    /**
     * This type is provided as an emergency choice if the user makes
     * customization changes that remove the type of an entry.
     */
    public static final BibtexEntryType TYPELESS =
        new BibtexEntryType()
        {
            public String getName()
            {
                return "Typeless";
            }

            public String[] getOptionalFields()
            {
                return null;
            }

            public String[] getRequiredFields()
            {
                return null;
            }

            public String describeRequiredFields()
            {
                return "None";
            }

            public boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database)
            {
		return false;
           }
        };


    public abstract String getName();

    public int compareTo(BibtexEntryType o) {
	return getName().compareTo(o.getName());
    }

    public abstract String[] getOptionalFields();

    public abstract String[] getRequiredFields();

    public String[] getGeneralFields() {
        return new String[]
	    {"crossref", "keywords", "doi", "url", "file",
	     "citeseerurl", "pdf", "abstract", "comment",
         "owner", "timestamp", "review", };
    }

    public String[] getPrimaryOptionalFields() {
        return null;
    }

    public abstract String describeRequiredFields();

    public abstract boolean hasAllRequiredFields(BibtexEntry entry, BibtexDatabase database);


    public String[] getUtilityFields(){
        return new String[] {"search" } ;
    }


    public boolean isRequired(String field) {
	String[] req = getRequiredFields();
	if (req == null) return false;
	for (int i=0; i<req.length; i++)
	    if (req[i].equals(field)) return true;
	return false;
    }

    public boolean isOptional(String field) {
	String[] opt = getOptionalFields();
	if (opt == null) return false;
	for (int i=0; i<opt.length; i++)
	    if (opt[i].equals(field)) return true;
	return false;
    }

    public static TreeMap<String, BibtexEntryType> ALL_TYPES = new TreeMap<String, BibtexEntryType>();
    public static TreeMap<String, BibtexEntryType> STANDARD_TYPES = new TreeMap<String, BibtexEntryType>();
    static {
        // Put the standard entry types into the type map.
        if (!Globals.prefs.getBoolean("biblatexMode")) {
            ALL_TYPES.put("article", ARTICLE);
            ALL_TYPES.put("inbook", INBOOK);
            ALL_TYPES.put("book", BOOK);
            ALL_TYPES.put("booklet", BOOKLET);
            ALL_TYPES.put("incollection", INCOLLECTION);
            ALL_TYPES.put("conference", CONFERENCE);
            ALL_TYPES.put("inproceedings", INPROCEEDINGS);
            ALL_TYPES.put("proceedings", PROCEEDINGS);
            ALL_TYPES.put("manual", MANUAL);
            ALL_TYPES.put("mastersthesis", MASTERSTHESIS);
            ALL_TYPES.put("phdthesis", PHDTHESIS);
            ALL_TYPES.put("techreport", TECHREPORT);
            ALL_TYPES.put("unpublished", UNPUBLISHED);
            ALL_TYPES.put("patent", PATENT);
            ALL_TYPES.put("standard", STANDARD);
            ALL_TYPES.put("electronic", ELECTRONIC);
            ALL_TYPES.put("periodical", PERIODICAL);
            ALL_TYPES.put("misc", MISC);
            ALL_TYPES.put("other", OTHER);
        }
        else {
            ALL_TYPES.put("article", BibLatexEntryTypes.ARTICLE);
	    ALL_TYPES.put("book", BibLatexEntryTypes.BOOK);
	    ALL_TYPES.put("inbook", BibLatexEntryTypes.INBOOK);
	    ALL_TYPES.put("bookinbook", BibLatexEntryTypes.BOOKINBOOK);
	    ALL_TYPES.put("suppbook", BibLatexEntryTypes.SUPPBOOK);
	    ALL_TYPES.put("booklet", BibLatexEntryTypes.BOOKLET);
	    ALL_TYPES.put("collection", BibLatexEntryTypes.COLLECTION);
	    ALL_TYPES.put("incollection", BibLatexEntryTypes.INCOLLECTION);
	    ALL_TYPES.put("suppcollection", BibLatexEntryTypes.SUPPCOLLECTION);
	    ALL_TYPES.put("manual", BibLatexEntryTypes.MANUAL);
	    ALL_TYPES.put("misc", BibLatexEntryTypes.MISC);
	    ALL_TYPES.put("online", BibLatexEntryTypes.ONLINE);
	    ALL_TYPES.put("patent", BibLatexEntryTypes.PATENT);
	    ALL_TYPES.put("periodical", BibLatexEntryTypes.PERIODICAL);
	    ALL_TYPES.put("suppperiodical", BibLatexEntryTypes.SUPPPERIODICAL);
	    ALL_TYPES.put("proceedings", BibLatexEntryTypes.PROCEEDINGS);
	    ALL_TYPES.put("inproceedings", BibLatexEntryTypes.INPROCEEDINGS);
	    ALL_TYPES.put("reference", BibLatexEntryTypes.REFERENCE);
	    ALL_TYPES.put("inreference", BibLatexEntryTypes.INREFERENCE);
	    ALL_TYPES.put("report", BibLatexEntryTypes.REPORT);
	    ALL_TYPES.put("set", BibLatexEntryTypes.SET);
	    ALL_TYPES.put("thesis", BibLatexEntryTypes.THESIS);
	    ALL_TYPES.put("unpublished", BibLatexEntryTypes.UNPUBLISHED);
	    ALL_TYPES.put("conference", BibLatexEntryTypes.CONFERENCE);
	    ALL_TYPES.put("electronic", BibLatexEntryTypes.ELECTRONIC);
	    ALL_TYPES.put("mastersthesis", BibLatexEntryTypes.MASTERSTHESIS);
	    ALL_TYPES.put("phdthesis", BibLatexEntryTypes.PHDTHESIS);
	    ALL_TYPES.put("techreport", BibLatexEntryTypes.TECHREPORT);
	    ALL_TYPES.put("www", BibLatexEntryTypes.WWW);
        }

        // We need a record of the standard types, in case the user wants
        // to remove a customized version. Therefore we clone the map.
        STANDARD_TYPES = new TreeMap<String, BibtexEntryType>(ALL_TYPES);
    }

    /**
     * This method returns the BibtexEntryType for the name of a type,
     * or null if it does not exist.
     */
    public static BibtexEntryType getType(String name) {
	//Util.pr("'"+name+"'");
	Object o = ALL_TYPES.get(name.toLowerCase(Locale.US));
	if (o == null)
	    return null;
	else return (BibtexEntryType)o;
    }

    /**
     * This method returns the standard BibtexEntryType for the
     * name of a type, or null if it does not exist.
     */
    public static BibtexEntryType getStandardType(String name) {
	//Util.pr("'"+name+"'");
	Object o = STANDARD_TYPES.get(name.toLowerCase());
	if (o == null)
	    return null;
	else return (BibtexEntryType)o;
    }

    /**
     * Removes a customized entry type from the type map. If this type
     * overrode a standard type, we reinstate the standard one.
     *
     * @param name The customized entry type to remove.
     */
    public static void removeType(String name) {
	//BibtexEntryType type = getType(name);
	String nm = name.toLowerCase();
        //System.out.println(ALL_TYPES.size());
	ALL_TYPES.remove(nm);
        //System.out.println(ALL_TYPES.size());
	if (STANDARD_TYPES.get(nm) != null) {
	    // In this case the user has removed a customized version
	    // of a standard type. We reinstate the standard type.
	    ALL_TYPES.put(nm, STANDARD_TYPES.get(nm));
	}

    }

    /**
     * Load all custom entry types from preferences. This method is
     * called from JabRef when the program starts.
     */
    public static void loadCustomEntryTypes(JabRefPreferences prefs) {
	int number = 0;
	CustomEntryType type;
	while ((type = prefs.getCustomEntryType(number)) != null) {
	    ALL_TYPES.put(type.getName().toLowerCase(), type);
	    number++;
	}
    }

    /**
     * Iterate through all entry types, and store those that are
     * custom defined to preferences. This method is called from
     * JabRefFrame when the program closes.
     */
    public static void saveCustomEntryTypes(JabRefPreferences prefs) {
	Iterator<String> i=ALL_TYPES.keySet().iterator();
	int number = 0;
	//Vector customTypes = new Vector(10, 10);
	while (i.hasNext()) {
	    Object o=ALL_TYPES.get(i.next());
	    if (o instanceof CustomEntryType) {
		// Store this entry type.
		prefs.storeCustomEntryType((CustomEntryType)o, number);
		number++;
	    }
	}
	// Then, if there are more 'old' custom types defined, remove these
	// from preferences. This is necessary if the number of custom types
	// has decreased.
	prefs.purgeCustomEntryTypes(number);
    }

    /**
     * Get an array of the required fields in a form appropriate for the entry customization
     * dialog - that is, thie either-or fields together and separated by slashes.
     * @return Array of the required fields in a form appropriate for the entry customization dialog.
     */
    public String[] getRequiredFieldsForCustomization() {
        return getRequiredFields();
    }

	public void testFromStringSingle() {
		BibtexEntry a = BibtexParser.singleFromString("@article{canh05,"
			+ "  author = {Crowston, K. and Annabi, H.},\n" + "  title = {Title A}}\n");
	
		assertEquals("canh05", a.getCiteKey());
		assertEquals("Crowston, K. and Annabi, H.", a.getField("author"));
		assertEquals("Title A", a.getField("title"));
		assertEquals(BibtexEntryType.ARTICLE, a.getType());
		
		BibtexEntry b = BibtexParser.singleFromString("@article{canh05,"
			+ "  author = {Crowston, K. and Annabi, H.},\n" + "  title = {Title A}}\n"
			+ "@inProceedings{foo," + "  author={Norton Bar}}");
	
		if (!(b.getCiteKey().equals("canh05") || b.getCiteKey().equals("foo"))){
			fail();
		}
	}

	public void testBigNumbers2() throws IOException {
	
		ParserResult result = BibtexParser.parse(new StringReader(""
			+ "@string{bourdieu = {Bourdieu, Pierre}}"
			+ "@book{bourdieu-2002-questions-sociologie, " + "	Address = {Paris},"
			+ "	Author = bourdieu," + "	Isbn = 2707318256," + "	Publisher = {Minuit},"
			+ "	Title = {Questions de sociologie}," + "	Year = 2002" + "}"));
	
		Collection<BibtexEntry> c = result.getDatabase().getEntries();
		assertEquals(1, c.size());
	
		BibtexEntry e = c.iterator().next();
	
		assertEquals("bourdieu-2002-questions-sociologie", e.getCiteKey());
		assertEquals(BibtexEntryType.BOOK, e.getType());
		assertEquals("2707318256", e.getField("isbn"));
		assertEquals("Paris", e.getField("address"));
		assertEquals("Minuit", e.getField("publisher"));
		assertEquals("Questions de sociologie", e.getField("title"));
		assertEquals("#bourdieu#", e.getField("author"));
		assertEquals("2002", e.getField("year"));
	}

	public void testParse2() throws IOException {
	
		BibtexParser parser = new BibtexParser(new StringReader(
			"@article{test,author={Ed von Test}}"));
		ParserResult result = parser.parse();
	
		BibtexEntry e = new BibtexEntry("", BibtexEntryType.ARTICLE);
		e.setField("author", "Ed von Test");
		e.setField("bibtexkey", "test");
	
		Collection<BibtexEntry> c = result.getDatabase().getEntries();
		assertEquals(1, c.size());
	
		BibtexEntry e2 = c.iterator().next();
	
		assertNotSame(e.getId(), e2.getId());
	
		for (String field : e.getAllFields()){
			if (!e.getField(field.toString()).equals(e2.getField(field.toString()))) {
				fail("e and e2 differ in field " + field.toString());
			}
		}
	}

	public void testFromSingle2() {
		/**
		 * More
		 */
		Collection<BibtexEntry> c = BibtexParser.fromString("@article{canh05,"
			+ "  author = {Crowston, K. and Annabi, H.},\n" + "  title = {Title A}}\n"
			+ "@inProceedings{foo," + "  author={Norton Bar}}");
	
		assertEquals(2, c.size());
	
		Iterator<BibtexEntry> i = c.iterator();
		BibtexEntry a = i.next();
		BibtexEntry b = i.next();
	
		if (a.getCiteKey().equals("foo")) {
			BibtexEntry tmp = a;
			a = b;
			b = tmp;
		}
	
		assertEquals("canh05", a.getCiteKey());
		assertEquals("Crowston, K. and Annabi, H.", a.getField("author"));
		assertEquals("Title A", a.getField("title"));
		assertEquals(BibtexEntryType.ARTICLE, a.getType());
	
		assertEquals("foo", b.getCiteKey());
		assertEquals("Norton Bar", b.getField("author"));
		assertEquals(BibtexEntryType.INPROCEEDINGS, b.getType());
	}

	public void testNewlineHandling() throws IOException {
	
		BibtexEntry e = BibtexParser.singleFromString("@article{canh05," +
				"a = {a\nb}," +
				"b = {a\n\nb}," +
				"c = {a\n \nb}," +
				"d = {a \n \n b},"
			+ "title = {\nHallo \nWorld \nthis \n is\n\nnot \n\nan \n\n exercise \n \n.\n \n\n},\n"
			+ "tabs = {\nHallo \tWorld \tthis \t is\t\tnot \t\tan \t\n exercise \t \n.\t \n\t},\n"
			+ "file = {Bemerkung:H:\\bla\\ups  sala.pdf:PDF}, \n"
			+ "}");
		
		assertEquals("canh05", e.getCiteKey());
		assertEquals(BibtexEntryType.ARTICLE, e.getType());
	
		assertEquals("a b", e.getField("a"));
		assertEquals("a\nb", e.getField("b"));
		assertEquals("a b", e.getField("c"));
		assertEquals("a b", e.getField("d"));
		
		// I think the last \n is a bug in the parser...
		assertEquals("Hallo World this is\nnot \nan \n exercise . \n\n", e.getField("title"));
		assertEquals("Hallo World this isnot an exercise . ", e.getField("tabs"));
	}

	private BibtexEntry createNewEntry() {
	
	    // Find out what type is wanted.
	    EntryTypeDialog etd = new EntryTypeDialog(frame);
	    // We want to center the dialog, to make it look nicer.
	    Util.placeDialog(etd, frame);
	    etd.setVisible(true);
	    BibtexEntryType type = etd.getChoice();
	
	    if (type != null) { // Only if the dialog was not cancelled.
	        String id = Util.createNeutralId();
	        final BibtexEntry be = new BibtexEntry(id, type);
	        try {
	            panel.database().insertEntry(be);
	
	            // Set owner/timestamp if options are enabled:
	            ArrayList<BibtexEntry> list = new ArrayList<BibtexEntry>();
	            list.add(be);
	            Util.setAutomaticFields(list, true, true, false);
	
	            // Create an UndoableInsertEntry object.
	            panel.undoManager.addEdit(new UndoableInsertEntry(panel.database(), be, panel));
	            panel.output(Globals.lang("Added new")+" '"+type.getName().toLowerCase()+"' "
	                   +Globals.lang("entry")+".");
	
	            // We are going to select the new entry. Before that, make sure that we are in
	            // show-entry mode. If we aren't already in that mode, enter the WILL_SHOW_EDITOR
	            // mode which makes sure the selection will trigger display of the entry editor
	            // and adjustment of the splitter.
	            if (panel.getMode() != panel.SHOWING_EDITOR) {
	                panel.setMode(panel.WILL_SHOW_EDITOR);
	            }
	
	            /*int row = entryTable.findEntry(be);
	            if (row >= 0)
	                // Selects the entry. The selection listener will open the editor.                      
	                 if (row >= 0) {
	                    try{
	                        entryTable.setRowSelectionInterval(row, row);
	                    }catch(IllegalArgumentException e){
	                        System.out.println("RowCount: " + entryTable.getRowCount());
	                    }
	
	                    //entryTable.setActiveRow(row);
	                    entryTable.ensureVisible(row);
	                 }
	            else {
	                // The entry is not visible in the table, perhaps due to a filtering search
	                // or group selection. Show the entry editor anyway:
	                panel.showEntry(be);
	            }   */
	            panel.showEntry(be);
	            panel.markBaseChanged(); // The database just changed.
	            new FocusRequester(panel.getEntryEditor(be));
	            return be;
	        } catch (KeyCollisionException ex) {
	            Util.pr(ex.getMessage());
	        }
	    }
	    return null;
	}

	protected void setUp() throws Exception {
		parserFactory = SAXParserFactory.newInstance();
		saxParser = parserFactory.newSAXParser();
		be = new BibtexEntry(Util.createNeutralId(), BibtexEntryType.getType("article"));
		handler = new OAI2Handler(be);
	}

	/**
	 * Is UTF8 handling working? This is because Java by default uses the
	 * platform encoding or a special UTF-kind.
	 * 
	 * @throws Exception
	 */
	public void testReadXMPUTF8() throws Exception {
	
		String bibtex = "<bibtex:year>2003</bibtex:year>\n"
				+ "<bibtex:title>�pt�mz�t��n</bibtex:title>\n"
				+ "<bibtex:bibtexkey>OezbekC06</bibtex:bibtexkey>\n";
	
		writeManually(pdfFile, bibtexXPacket(bibtexDescription(bibtex)));
	
		List<BibtexEntry> l = XMPUtil.readXMP(pdfFile.getAbsoluteFile());
		assertEquals(1, l.size());
		BibtexEntry e = l.get(0);
	
		assertNotNull(e);
		assertEquals("OezbekC06", e.getCiteKey());
		assertEquals("2003", e.getField("year"));
		assertEquals("�pt�mz�t��n", e.getField("title"));
		assertEquals(BibtexEntryType.OTHER, e.getType());
	}

	/**
	 * 
	 * @depends XMPUtilTest.testReadMultiple()
	 */
	public void testXMPreadString() throws Exception {
	
		ParserResult result = BibtexParser.parse(new StringReader(
				"@article{canh05,"
						+ "  author = {Crowston, K. and Annabi, H.},\n"
						+ "  title = {Title A}}\n" + "@inProceedings{foo,"
						+ "  author={Norton Bar}}"));
	
		Collection<BibtexEntry> c = result.getDatabase().getEntries();
		assertEquals(2, c.size());
	
		String xmp = XMPUtil.toXMP(c, null);
	
		/* Test minimal syntaxical completeness */
		assertTrue(0 < xmp.indexOf("xpacket"));
		assertTrue(0 < xmp.indexOf("adobe:ns:meta"));
		assertTrue(0 < xmp
				.indexOf("<bibtex:bibtexkey>canh05</bibtex:bibtexkey>")
				|| 0 < xmp.indexOf("bibtex:bibtexkey="));
		assertTrue(0 < xmp.indexOf("<rdf:li>Norton Bar</rdf:li>"));
		assertTrue(0 < xmp.indexOf("id='W5M0MpCehiHzreSzNTczkc9d'?>")
				|| 0 < xmp.indexOf("id=\"W5M0MpCehiHzreSzNTczkc9d\"?>"));
		assertTrue(0 < xmp
				.indexOf("xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'")
				|| 0 < xmp
						.indexOf("xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\""));
		assertTrue(0 < xmp.indexOf("<rdf:Description"));
		assertTrue(0 < xmp.indexOf("<?xpacket end='w'?>")
				|| 0 < xmp.indexOf("<?xpacket end=\"w\"?>"));
	
		/* Test contents of string */
		writeManually(pdfFile, xmp);
	
		List<BibtexEntry> l = XMPUtil.readXMP(pdfFile);
	
		assertEquals(2, l.size());
	
		BibtexEntry a = l.get(0);
		BibtexEntry b = l.get(1);
	
		if (a.getCiteKey().equals("foo")) {
			BibtexEntry tmp = a;
			a = b;
			b = tmp;
		}
	
		assertEquals("canh05", a.getCiteKey());
		assertEquals("K. Crowston and H. Annabi", a.getField("author"));
		assertEquals("Title A", a.getField("title"));
		assertEquals(BibtexEntryType.ARTICLE, a.getType());
	
		assertEquals("foo", b.getCiteKey());
		assertEquals("Norton Bar", b.getField("author"));
		assertEquals(BibtexEntryType.INPROCEEDINGS, b.getType());
	}

	public BibtexEntry t3BibtexEntry() {
		BibtexEntry e = new BibtexEntry();
		e.setType(BibtexEntryType.INPROCEEDINGS);
		e.setField("title", "Hypersonic ultra-sound");
		e.setField("bibtexkey", "Clarkson06");
		e.setField("author", "Kelly Clarkson and Ozzy Osbourne");
		e.setField("journal", "International Journal of High Fidelity");
		e.setField("booktitle", "Catch-22");
		e.setField("editor", "Huey Duck and Dewey Duck and Louie Duck");
		e.setField("pdf", "YeKis03 - Towards.pdf");
		e.setField("keywords", "peanut,butter,jelly");
		e.setField("year", "1982");
		e.setField("month", "#jul#");
		e
				.setField(
						"abstract",
						"The success of the Linux operating system has demonstrated the viability of an alternative form of software development � open source software � that challenges traditional assumptions about software markets. Understanding what drives open source developers to participate in open source projects is crucial for assessing the impact of open source software. This article identifies two broad types of motivations that account for their participation in open source projects. The first category includes internal factors such as intrinsic motivation and altruism, and the second category focuses on external rewards such as expected future returns and personal needs. This article also reports the results of a survey administered to open source programmers.");
		return e;
	}

	/**
	 * Is the XMPEntryType correctly set?
	 * 
	 * @throws Exception
	 */
	public void testReadXMPEntryType() throws Exception {
	
		String bibtex = "<bibtex:entrytype>ARticle</bibtex:entrytype>";
	
		writeManually(pdfFile, bibtexXPacket(bibtexDescription(bibtex)));
	
		List<BibtexEntry> l = XMPUtil.readXMP(pdfFile.getAbsoluteFile());
		assertEquals(1, l.size());
		BibtexEntry e = l.get(0);
	
		assertNotNull(e);
		assertEquals(BibtexEntryType.ARTICLE, e.getType());
	}

	/**
	 * Most basic test for reading.
	 * 
	 * @throws Exception
	 */
	public void testReadXMPSimple() throws Exception {
	
		String bibtex = "<bibtex:year>2003</bibtex:year>\n"
				+ "<bibtex:title>Beach sand convolution by surf-wave optimzation</bibtex:title>\n"
				+ "<bibtex:bibtexkey>OezbekC06</bibtex:bibtexkey>\n";
	
		writeManually(pdfFile, bibtexXPacket(bibtexDescription(bibtex)));
	
		List<BibtexEntry> l = XMPUtil.readXMP(pdfFile.getAbsoluteFile());
		assertEquals(1, l.size());
		BibtexEntry e = l.get(0);
	
		assertNotNull(e);
		assertEquals("OezbekC06", e.getCiteKey());
		assertEquals("2003", e.getField("year"));
		assertEquals("Beach sand convolution by surf-wave optimzation", e
				.getField("title"));
		assertEquals(BibtexEntryType.OTHER, e.getType());
	
	}

	public BibtexEntry t2BibtexEntry() {
		BibtexEntry e = new BibtexEntry(Util.createNeutralId(),
				BibtexEntryType.INCOLLECTION);
		e.setField("title", "�pt�mz�t��n");
		e.setField("bibtexkey", "OezbekC06");
		e.setField("year", "2003");
		e
				.setField(
						"booktitle",
						"Proceedings of the of the 25th International Conference on Software-Engineering (Portland, Oregon)");
		e.setField("pdf", "YeKis03 - Towards.pdf");
		return e;
	}

	/**
	 * Are authors and editors correctly read?
	 * 
	 * @throws Exception
	 */
	public void testReadXMPSeq() throws Exception {
	
		String bibtex = "<bibtex:author><rdf:Seq>\n"
				+ "  <rdf:li>Kelly Clarkson</rdf:li>"
				+ "  <rdf:li>Ozzy Osbourne</rdf:li>"
				+ "</rdf:Seq></bibtex:author>" + "<bibtex:editor><rdf:Seq>"
				+ "  <rdf:li>Huey Duck</rdf:li>"
				+ "  <rdf:li>Dewey Duck</rdf:li>"
				+ "  <rdf:li>Louie Duck</rdf:li>"
				+ "</rdf:Seq></bibtex:editor>"
				+ "<bibtex:bibtexkey>Clarkson06</bibtex:bibtexkey>";
	
		writeManually(pdfFile, bibtexXPacket(bibtexDescription(bibtex)));
	
		List<BibtexEntry> l = XMPUtil.readXMP(pdfFile.getAbsoluteFile());
		assertEquals(1, l.size());
		BibtexEntry e = l.get(0);
	
		assertNotNull(e);
		assertEquals("Clarkson06", e.getCiteKey());
		assertEquals("Kelly Clarkson and Ozzy Osbourne", e.getField("author"));
		assertEquals("Huey Duck and Dewey Duck and Louie Duck", e
				.getField("editor"));
		assertEquals(BibtexEntryType.OTHER, e.getType());
	}
}
