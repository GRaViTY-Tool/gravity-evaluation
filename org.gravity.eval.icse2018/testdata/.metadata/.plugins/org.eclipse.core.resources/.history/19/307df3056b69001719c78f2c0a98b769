/* Generated By:JJTree: Do not edit this line. ASTClassOrInterfaceDeclaration.java */

package net.sourceforge.pmd.ast;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod.ConstructorHolder;
import net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod.ConstructorInvocation;
import net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod.EvalPackage;
import net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod.MethodHolder;
import net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod.MethodInvocation;
import net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod.NullEvalPackage;

public class ASTClassOrInterfaceDeclaration extends AccessNode {
    public ASTClassOrInterfaceDeclaration(int id) {
        super(id);
    }

    public ASTClassOrInterfaceDeclaration(JavaParser p, int id) {
        super(p, id);
    }

    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(JavaParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    public boolean isNested() {
        return jjtGetParent() instanceof ASTClassOrInterfaceBodyDeclaration;
    }

    private boolean isInterface;

    public boolean isInterface() {
        return this.isInterface;
    }

    public void setInterface() {
        this.isInterface = true;
    }

    public void dump(String prefix) {
        String interfaceStr = isInterface ? "interface" : "class";
        String innerStr = isNested() ? "(nested)" : "";
        System.out.println(toString(prefix) + "(" + getImage() + ")(" + interfaceStr + ")" + innerStr);
        dumpChildren(prefix);
    }

	/**
	 * This check must be evaluated independelty for each class.  Inner classses
	 * get their own EvalPackage in order to perform independent evaluation.
	 */
	public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
	    if (!node.isInterface()) {
	        return visitClassDec(node, data);
	    } else {
	        putEvalPackage(nullEvalPackage);
	        Object o = super.visit(node, data);//interface may have inner classes, possible? if not just skip whole interface
	        removeCurrentEvalPackage();
	        return o;
	    }
	}

	/**
	 * Check the methods called on this class by each of the methods on this
	 * class.  If a method calls an unsafe method, mark the calling method as
	 * unsafe.  This changes the list of unsafe methods which necessitates
	 * another pass.  Keep passing until you make a clean pass in which no
	 * methods are changed to unsafe.
	 * For speed it is possible to limit the number of passes.
	 * <p/>
	 * Impossible to tell type of arguments to method, so forget method matching
	 * on types.  just use name and num of arguments.  will be some false hits,
	 * but oh well.
	 *
	 * @todo investigate limiting the number of passes through config.
	 */
	private boolean evaluateDangerOfMethods(Map classMethodMap) {
	    //check each method if it calls overridable method
	    boolean found = false;
	    for (Iterator methodsIter = classMethodMap.entrySet().iterator(); methodsIter.hasNext();) {
	        Map.Entry entry = (Map.Entry) methodsIter.next();
	
	        MethodHolder h = (MethodHolder) entry.getKey();
	        List calledMeths = (List) entry.getValue();
	        for (Iterator calledMethsIter = calledMeths.iterator(); calledMethsIter.hasNext() && !h.isDangerous();) {
	            //if this method matches one of our dangerous methods, mark it dangerous
	            MethodInvocation meth = (MethodInvocation) calledMethsIter.next();
	            //System.out.println("Called meth is " + meth);
	            for (Iterator innerMethsIter = classMethodMap.keySet().iterator(); innerMethsIter.hasNext();) { //need to skip self here h == h3
	                MethodHolder h3 = (MethodHolder) innerMethsIter.next();
	                if (h3.isDangerous()) {
	                    String matchMethodName = h3.getASTMethodDeclarator().getImage();
	                    int matchMethodParamCount = h3.getASTMethodDeclarator().getParameterCount();
	                    //System.out.println("matching " + matchMethodName + " to " + meth.getName());
	                    if (matchMethodName.equals(meth.getName()) && matchMethodParamCount == meth.getArgumentCount()) {
	                        h.setDangerous();
	                        h.setCalledMethod(matchMethodName);
	                        found = true;
	                        break;
	                    }
	                }
	            }
	        }
	    }
	    return found;
	}

	/**
	 * Create a MethodHolder to hold the method.
	 * Store the MethodHolder in the Map as the key
	 * Store each method called by the current method as a List in the Map as the Object
	 */
	public Object visit(ASTMethodDeclarator node, Object data) {
	    if (!(getCurrentEvalPackage() instanceof NullEvalPackage)) {//only evaluate if we have an eval package for this class
	        AccessNode parent = (AccessNode) node.jjtGetParent();
	        MethodHolder h = new MethodHolder(node);
	        if (!parent.isAbstract() && !parent.isPrivate() && !parent.isStatic() && !parent.isFinal()) { //Skip abstract methods, have a separate rule for that
	            h.setDangerous();//this method is overridable
	            ASTMethodDeclaration decl = (ASTMethodDeclaration) node.getFirstParentOfType(ASTMethodDeclaration.class);
	            h.setCalledMethod(decl.getMethodName());
	        }
	        List l = new ArrayList();
	        addCalledMethodsOfNode((SimpleNode) parent, l, getCurrentEvalPackage().m_ClassName);
	        getCurrentEvalPackage().allMethodsOfClass.put(h, l);
	    }
	    return super.visit(node, data);
	}

	/**
	 * This check must be evaluated independelty for each class.  Inner classses
	 * get their own EvalPackage in order to perform independent evaluation.
	 */
	private Object visitClassDec(ASTClassOrInterfaceDeclaration node, Object data) {
	    String className = node.getImage();
	    if (!node.isFinal() && !node.isStatic()) {
	        putEvalPackage(new EvalPackage(className));
	    } else {
	        putEvalPackage(nullEvalPackage);
	    }
	    //store any errors caught from other passes.
	    super.visit((ASTClassOrInterfaceDeclaration) node, data);
	
	    //skip this class if it has no evaluation package
	    if (!(getCurrentEvalPackage() instanceof NullEvalPackage)) {
	        //evaluate danger of all methods in class
	        while (evaluateDangerOfMethods(getCurrentEvalPackage().allMethodsOfClass)) {
	        }
	        //evaluate danger of constructors
	        evaluateDangerOfConstructors1(getCurrentEvalPackage().allPrivateConstructorsOfClass, getCurrentEvalPackage().allMethodsOfClass.keySet());
	        while (evaluateDangerOfConstructors2(getCurrentEvalPackage().allPrivateConstructorsOfClass)) {
	        }
	
	        //get each method called on this object from a non-private constructor, if its dangerous flag it
	        for (Iterator it = getCurrentEvalPackage().calledMethods.iterator(); it.hasNext();) {
	            MethodInvocation meth = (MethodInvocation) it.next();
	            //check against each dangerous method in class
	            for (Iterator it2 = getCurrentEvalPackage().allMethodsOfClass.keySet().iterator(); it2.hasNext();) {
	                MethodHolder h = (MethodHolder) it2.next();
	                if (h.isDangerous()) {
	                    String methName = h.getASTMethodDeclarator().getImage();
	                    int count = h.getASTMethodDeclarator().getParameterCount();
	                    if (methName.equals(meth.getName()) && meth.getArgumentCount() == count) {
	                        addViolation(data, meth.getASTPrimaryExpression(), "method '" + h.getCalled() + "'");
	                    }
	                }
	            }
	        }
	        //get each unsafe private constructor, and check if its called from any non private constructors
	        for (Iterator privConstIter = getCurrentEvalPackage().allPrivateConstructorsOfClass.keySet().iterator(); privConstIter.hasNext();) {
	            ConstructorHolder ch = (ConstructorHolder) privConstIter.next();
	            if (ch.isDangerous()) { //if its dangerous check if its called from any non-private constructors
	                //System.out.println("visitClassDec Evaluating dangerous constructor with " + ch.getASTConstructorDeclaration().getParameterCount() + " params");
	                int paramCount = ch.getASTConstructorDeclaration().getParameterCount();
	                for (Iterator calledConstIter = getCurrentEvalPackage().calledConstructors.iterator(); calledConstIter.hasNext();) {
	                    ConstructorInvocation ci = (ConstructorInvocation) calledConstIter.next();
	                    if (ci.getArgumentCount() == paramCount) {
	                        //match name  super / this !?
	                        addViolation(data, ci.getASTExplicitConstructorInvocation(), "constructor");
	                    }
	                }
	            }
	        }
	    }
	    //finished evaluating this class, move up a level
	    removeCurrentEvalPackage();
	    return data;
	}

	/**
	 * marks constructors dangerous if they call any dangerous methods
	 * Requires only a single pass as methods are already marked
	 *
	 * @todo optimize by having methods already evaluated somehow!?
	 */
	private void evaluateDangerOfConstructors1(Map classConstructorMap, Set evaluatedMethods) {
	    //check each constructor in the class
	    for (Iterator constIter = classConstructorMap.entrySet().iterator(); constIter.hasNext();) {
	        Map.Entry entry = (Map.Entry) constIter.next();
	        ConstructorHolder ch = (ConstructorHolder) entry.getKey();
	        if (!ch.isDangerous()) {//if its not dangerous then evaluate if it should be
	            //if it calls dangerous method mark it as dangerous
	            List calledMeths = (List) entry.getValue();
	            //check each method it calls
	            for (Iterator calledMethsIter = calledMeths.iterator(); calledMethsIter.hasNext() && !ch.isDangerous();) {//but thee are diff objects which represent same thing but were never evaluated, they need reevaluation
	                MethodInvocation meth = (MethodInvocation) calledMethsIter.next();//CCE
	                String methName = meth.getName();
	                int methArgCount = meth.getArgumentCount();
	                //check each of the already evaluated methods: need to optimize this out
	                for (Iterator evaldMethsIter = evaluatedMethods.iterator(); evaldMethsIter.hasNext();) {
	                    MethodHolder h = (MethodHolder) evaldMethsIter.next();
	                    if (h.isDangerous()) {
	                        String matchName = h.getASTMethodDeclarator().getImage();
	                        int matchParamCount = h.getASTMethodDeclarator().getParameterCount();
	                        if (methName.equals(matchName) && (methArgCount == matchParamCount)) {
	                            ch.setDangerous(true);
	                            //System.out.println("evaluateDangerOfConstructors1 setting dangerous constructor with " + ch.getASTConstructorDeclaration().getParameterCount() + " params");
	                            break;
	                        }
	                    }
	
	                }
	            }
	        }
	    }
	}

	/**
	 * Non-private constructor's methods are added to a list for later safety
	 * evaluation.  Non-private constructor's calls on private constructors
	 * are added to a list for later safety evaluation.  Private constructors
	 * are added to a list so their safety to be called can be later evaluated.
	 * <p/>
	 * Note: We are not checking private constructor's calls on non-private
	 * constructors because all non-private constructors will be evaluated for
	 * safety anyway.  This means we wont flag a private constructor as unsafe
	 * just because it calls an unsafe public constructor.  We want to show only
	 * 1 instance of an error, and this would be 2 instances of the same error.
	 *
	 * @todo eliminate the redundency
	 */
	public Object visit(ASTConstructorDeclaration node, Object data) {
	    if (!(getCurrentEvalPackage() instanceof NullEvalPackage)) {//only evaluate if we have an eval package for this class
	        List calledMethodsOfConstructor = new ArrayList();
	        ConstructorHolder ch = new ConstructorHolder(node);
	        addCalledMethodsOfNode(node, calledMethodsOfConstructor, getCurrentEvalPackage().m_ClassName);
	        if (!node.isPrivate()) {
	            //these calledMethods are what we will evaluate for being called badly
	            getCurrentEvalPackage().calledMethods.addAll(calledMethodsOfConstructor);
	            //these called private constructors are what we will evaluate for being called badly
	            //we add all constructors invoked by non-private constructors
	            //but we are only interested in the private ones.  We just can't tell the difference here
	            ASTExplicitConstructorInvocation eci = ch.getASTExplicitConstructorInvocation();
	            if (eci != null && eci.isThis()) {
	                getCurrentEvalPackage().calledConstructors.add(ch.getCalledConstructor());
	            }
	        } else {
	            //add all private constructors to list for later evaluation on if they are safe to call from another constructor
	            //store this constructorHolder for later evaluation
	            getCurrentEvalPackage().allPrivateConstructorsOfClass.put(ch, calledMethodsOfConstructor);
	        }
	    }
	    return super.visit(node, data);
	}

	private void lclFindChildrenOfType(Node node, Class targetType, List results) {
	    if (node.getClass().equals(targetType)) {
	        results.add(node);
	    }
	
	    if (node instanceof ASTClassOrInterfaceDeclaration && ((ASTClassOrInterfaceDeclaration) node).isNested()) {
	        return;
	    }
	
	    if (node instanceof ASTClassOrInterfaceBodyDeclaration && ((ASTClassOrInterfaceBodyDeclaration) node).isAnonymousInnerClass()) {
	        return;
	    }
	
	    for (int i = 0; i < node.jjtGetNumChildren(); i++) {
	        Node child = node.jjtGetChild(i);
	        if (child.getClass().equals(targetType)) {
	            results.add(child);
	        }
	    }
	}

	public Object visit(ASTMethodDeclaration node, Object data) {
	    // Can skip abstract methods and methods whose only purpose is to
	    // guarantee that the inherited method is not changed by finalizing
	    // them.
	    if (node.isAbstract() || node.isFinal() || node.isNative() || node.isSynchronized()) {
	        return super.visit(node, data);
	    }
	
	    ASTBlock block = node.getBlock();
	    if (block == null) {
	        return super.visit(node, data);
	    }
	    //Only process functions with one BlockStatement
	    if (block.jjtGetNumChildren() != 1 || block.findChildrenOfType(ASTStatement.class).size() != 1)
	        return super.visit(node, data);
	
	    ASTStatement statement = (ASTStatement) block.jjtGetChild(0).jjtGetChild(0);
	    if (statement.jjtGetChild(0).jjtGetNumChildren() == 0) {
	        return data;     // skips empty return statements
	    }
	    SimpleNode statementGrandChild = (SimpleNode) statement.jjtGetChild(0).jjtGetChild(0);
	    ASTPrimaryExpression primaryExpression;
	
	    if (statementGrandChild instanceof ASTPrimaryExpression)
	        primaryExpression = (ASTPrimaryExpression) statementGrandChild;
	    else {
	        List primaryExpressions = findFirstDegreeChildrenOfType(statementGrandChild, ASTPrimaryExpression.class);
	        if (primaryExpressions.size() != 1)
	            return super.visit(node, data);
	        primaryExpression = (ASTPrimaryExpression) primaryExpressions.get(0);
	    }
	
	    ASTPrimaryPrefix primaryPrefix = (ASTPrimaryPrefix) findFirstDegreeChildrenOfType(primaryExpression, ASTPrimaryPrefix.class).get(0);
	    if (!primaryPrefix.usesSuperModifier())
	        return super.visit(node, data);
	
	    ASTMethodDeclarator methodDeclarator = (ASTMethodDeclarator) findFirstDegreeChildrenOfType(node, ASTMethodDeclarator.class).get(0);
	    if (!primaryPrefix.hasImageEqualTo(methodDeclarator.getImage()))
	        return super.visit(node, data);
	
	    //Process arguments
	    ASTPrimarySuffix primarySuffix = (ASTPrimarySuffix) findFirstDegreeChildrenOfType(primaryExpression, ASTPrimarySuffix.class).get(0);
	    ASTArguments arguments = (ASTArguments) primarySuffix.jjtGetChild(0);
	    ASTFormalParameters formalParameters = (ASTFormalParameters) methodDeclarator.jjtGetChild(0);
	    if (formalParameters.jjtGetNumChildren() != arguments.jjtGetNumChildren())
	        return super.visit(node, data);
	
	    if (arguments.jjtGetNumChildren() == 0) //No arguments to check
	        addViolation(data, node, getMessage());
	    else {
	        ASTArgumentList argumentList = (ASTArgumentList) arguments.jjtGetChild(0);
	        for (int i = 0; i < argumentList.jjtGetNumChildren(); i++) {
	            Node ExpressionChild = argumentList.jjtGetChild(i).jjtGetChild(0);
	            if (!(ExpressionChild instanceof ASTPrimaryExpression) || ExpressionChild.jjtGetNumChildren() != 1)
	                return super.visit(node, data); //The arguments are not simply passed through
	
	            ASTPrimaryExpression argumentPrimaryExpression = (ASTPrimaryExpression) ExpressionChild;
	            ASTPrimaryPrefix argumentPrimaryPrefix = (ASTPrimaryPrefix) argumentPrimaryExpression.jjtGetChild(0);
	            if (argumentPrimaryPrefix.jjtGetNumChildren() == 0) {
	                return super.visit(node, data); //The arguments are not simply passed through (using "this" for instance)
	            }
	            Node argumentPrimaryPrefixChild = argumentPrimaryPrefix.jjtGetChild(0);
	            if (!(argumentPrimaryPrefixChild instanceof ASTName))
	                return super.visit(node, data); //The arguments are not simply passed through
	
	            if (formalParameters.jjtGetNumChildren() < i + 1) {
	                return super.visit(node, data); // different number of args
	            }
	
	            ASTName argumentName = (ASTName) argumentPrimaryPrefixChild;
	            ASTFormalParameter formalParameter = (ASTFormalParameter) formalParameters.jjtGetChild(i);
	            ASTVariableDeclaratorId variableId = (ASTVariableDeclaratorId) findFirstDegreeChildrenOfType(formalParameter, ASTVariableDeclaratorId.class).get(0);
	            if (!argumentName.hasImageEqualTo(variableId.getImage())) {
	                return super.visit(node, data); //The arguments are not simply passed through
	            }
	
	        }
	        addViolation(data, node, getMessage()); //All arguments are passed through directly
	    }
	    return super.visit(node, data);
	}

	public Object visit(ASTClassOrInterfaceDeclaration clz, Object data) {
	    if (clz.isInterface()) {
	        return data;
	    }
	    return super.visit(clz, data);
	}

	public Object visit(ASTMethodDeclaration method, Object data) {
	    if (!method.getResultType().returnsArray()) {
	        return data;
	    }
	    List returns = method.findChildrenOfType(ASTReturnStatement.class);
	    ASTTypeDeclaration td = (ASTTypeDeclaration) method.getFirstParentOfType(ASTTypeDeclaration.class);
	    for (Iterator it = returns.iterator(); it.hasNext();) {
	        final ASTReturnStatement ret = (ASTReturnStatement) it.next();
	        final String vn = getReturnedVariableName(ret);
	        if (!isField(vn, td)) {
	            continue;
	        }
	        if (ret.findChildrenOfType(ASTPrimarySuffix.class).size() > 2) {
	            continue;
	        }
	        if (!ret.findChildrenOfType(ASTAllocationExpression.class).isEmpty()) {
	            continue;
	        }
	        if (!isLocalVariable(vn, method)) {
	            addViolation(data, ret, vn);
	        } else {
	            // This is to handle field hiding
	            final ASTPrimaryPrefix pp = (ASTPrimaryPrefix) ret.getFirstChildOfType(ASTPrimaryPrefix.class);
	            if (pp != null && pp.usesThisModifier()) {
	                final ASTPrimarySuffix ps = (ASTPrimarySuffix) ret.getFirstChildOfType(ASTPrimarySuffix.class);
	                if (ps.hasImageEqualTo(vn)) {
	                    addViolation(data, ret, vn);
	                }
	            }
	        }
	    }
	    return data;
	}

	public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
	    if (node.isInterface()) {
	        return data;
	    }
	    return super.visit(node, data);
	}

	public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
	    if (node.isInterface()) {
	        return data;
	    }
	    return super.visit(node, data);
	}

	private static void addCalledMethodsOfNode(AccessNode node, List calledMethods, String className) {
	    List expressions = new ArrayList();
	    node.findChildrenOfType(ASTPrimaryExpression.class, expressions, false);
	    addCalledMethodsOfNodeImpl(expressions, calledMethods, className);
	}

	/**
	 * @return A method call on the class passed in, or null if no method call
	 *         is found.
	 * @todo Need a better way to match the class and package name to the actual
	 * method being called.
	 */
	private static MethodInvocation findMethod(ASTPrimaryExpression node, String className) {
	    if (node.jjtGetNumChildren() > 0
	            && node.jjtGetChild(0).jjtGetNumChildren() > 0
	            && node.jjtGetChild(0).jjtGetChild(0) instanceof ASTLiteral) {
	        return null;
	    }
	    MethodInvocation meth = MethodInvocation.getMethod(node);
	    boolean found = false;
	    //		if(meth != null){
	    //			meth.show();
	    //		}
	    if (meth != null) {
	        //if it's a call on a variable, or on its superclass ignore it.
	        if ((meth.getReferenceNames().size() == 0) && !meth.isSuper()) {
	            //if this list does not contain our class name, then its not referencing our class
	            //this is a cheezy test... but it errs on the side of less false hits.
	            List packClass = meth.getQualifierNames();
	            if (!packClass.isEmpty()) {
	                for (Iterator it = packClass.iterator(); it.hasNext();) {
	                    String name = (String) it.next();
	                    if (name.equals(className)) {
	                        found = true;
	                        break;
	                    }
	                }
	            } else {
	                found = true;
	            }
	        }
	    }
	
	    return found ? meth : null;
	}

	/**
	 * ASTPrimaryPrefix has name in child node of ASTName
	 */
	private static String getNameFromPrefix(ASTPrimaryPrefix node) {
	    String name = null;
	    //should only be 1 child, if more I need more knowledge
	    if (node.jjtGetNumChildren() == 1) { //safety check
	        Node nnode = node.jjtGetChild(0);
	        if (nnode instanceof ASTName) { //just as easy as null check and it should be an ASTName anyway
	            name = ((ASTName) nnode).getImage();
	        }
	    }
	    return name;
	}

	/**
	 * Adds all methods called on this instance from within this Node.
	 */
	private static void addCalledMethodsOfNode(SimpleNode node, List calledMethods, String className) {
	    List expressions = new ArrayList();
	    node.findChildrenOfType(ASTPrimaryExpression.class, expressions);
	    addCalledMethodsOfNodeImpl(expressions, calledMethods, className);
	}

}
