package net.sourceforge.pmd.ast;

import java.util.Arrays;
import java.util.List;
import java.util.Set;

public class AccessNode extends SimpleJavaNode {

    public static final int PUBLIC = 0x0001;
    public static final int PROTECTED = 0x0002;
    public static final int PRIVATE = 0x0004;
    public static final int ABSTRACT = 0x0008;
    public static final int STATIC = 0x0010;
    public static final int FINAL = 0x0020;
    public static final int SYNCHRONIZED = 0x0040;
    public static final int NATIVE = 0x0080;
    public static final int TRANSIENT = 0x0100;
    public static final int VOLATILE = 0x0200;
    public static final int STRICTFP = 0x1000;

    public AccessNode(int i) {
        super(i);
    }

    public AccessNode(JavaParser parser, int i) {
        super(parser, i);
    }

    private int modifiers;

    public void setModifiers(int m) {
        this.modifiers = m;
    }

    public boolean isPublic() {
        return (modifiers & PUBLIC) != 0;
    }

    public boolean isProtected() {
        return (modifiers & PROTECTED) != 0;
    }

    public boolean isPrivate() {
        return (modifiers & PRIVATE) != 0;
    }

    public boolean isStatic() {
        return (modifiers & STATIC) != 0;
    }

    public boolean isAbstract() {
        return (modifiers & ABSTRACT) != 0;
    }

    public boolean isFinal() {
        return (modifiers & FINAL) != 0;
    }

    public boolean isNative() {
        return (modifiers & NATIVE) != 0;
    }

    public boolean isStrictfp() {
        return (modifiers & STRICTFP) != 0;
    }

    public boolean isSynchronized() {
        return (modifiers & SYNCHRONIZED) != 0;
    }

    public boolean isTransient() {
        return (modifiers & TRANSIENT) != 0;
    }

    public boolean isVolatile() {
        return (modifiers & VOLATILE) != 0;
    }

    public void setPublic() {
        modifiers |= PUBLIC;
    }

    public void setPrivate() {
        modifiers |= PRIVATE;
    }

    public void setProtected() {
        modifiers |= PROTECTED;
    }

    public void setSynchronized() {
        modifiers |= SYNCHRONIZED;
    }

    public void setVolatile() {
        modifiers |= VOLATILE;
    }

    public void setAbstract() {
        modifiers |= ABSTRACT;
    }

    public void setStatic() {
        modifiers |= STATIC;
    }

    public void setTransient() {
        modifiers |= TRANSIENT;
    }

    public void setFinal() {
        modifiers |= FINAL;
    }

    public void setNative() {
        modifiers |= NATIVE;
    }

    public void setStrictfp() {
        modifiers |= STRICTFP;
    }

    /**
     * Removes the given modifier.
     */
    static int removeModifier(int modifiers, int mod) {
        return modifiers & ~mod;
    }

    public boolean isPackagePrivate() {
        return !isPrivate() && !isPublic() && !isProtected();
    }

    public String collectDumpedModifiers(String prefix) {
        String out = toString(prefix) + ":";
        if (isPackagePrivate()) {
            out += "(package private)";
        }
        if (isPrivate()) {
            out += "(private)";
        }
        if (isPublic()) {
            out += "(public)";
        }
        if (isProtected()) {
            out += "(protected)";
        }
        if (isAbstract()) {
            out += "(abstract)";
        }
        if (isStatic()) {
            out += "(static)";
        }
        if (isFinal()) {
            out += "(final)";
        }
        if (isSynchronized()) {
            out += "(synchronized)";
        }
        if (isNative()) {
            out += "(native)";
        }
        if (isStrictfp()) {
            out += "(strict)";
        }
        if (isTransient()) {
            out += "(transient)";
        }
        return out;
    }

	public void testVolatile() throws Throwable {
	    String access[] = {"private", "volatile"};
	    ASTFieldDeclaration afd = getFieldDecl(access);
	    assertTrue("Expecting field to be volatile.", afd.isVolatile());
	    assertTrue("Expecting field to be private.", afd.isPrivate());
	}

	public void testTransient() throws Throwable {
	    String access[] = {"private", "transient"};
	    ASTFieldDeclaration afd = getFieldDecl(access);
	    assertTrue("Expecting field to be private.", afd.isPrivate());
	    assertTrue("Expecting field to be transient.", afd.isTransient());
	}

	public void testPrivate() throws Throwable {
	    String access[] = {"private"};
	    ASTMethodDeclaration amd = getMethodDecl(access);
	    assertTrue("Expecting method to be private.", amd.isPrivate());
	}

	public void testNative() throws Throwable {
	    String access[] = {"private", "native"};
	    ASTMethodDeclaration amd = getMethodDecl(access);
	    assertTrue("Expecting method to be native.", amd.isNative());
	    assertTrue("Expecting method to be private.", amd.isPrivate());
	}

	public void testStrict() throws Throwable {
	    String access[] = {"public", "strictfp"};
	    ASTMethodDeclaration amd = getMethodDecl(access);
	    assertTrue("Expecting method to be strict.", amd.isStrictfp());
	    assertTrue("Expecting method to be public.", amd.isPublic());
	}

	public void testProtected() throws Throwable {
	    String access[] = {"protected"};
	    ASTMethodDeclaration amd = getMethodDecl(access);
	    assertTrue("Expecting method to be protected.", amd.isProtected());
	}

	public void testFinal() throws Throwable {
	    String access[] = {"public", "final"};
	    ASTMethodDeclaration amd = getMethodDecl(access);
	    assertTrue("Expecting method to be final.", amd.isFinal());
	    assertTrue("Expecting method to be public.", amd.isPublic());
	}

	public void testSynchronized() throws Throwable {
	    String access[] = {"public", "synchronized"};
	    ASTMethodDeclaration amd = getMethodDecl(access);
	    assertTrue("Expecting method to be synchronized.", amd.isSynchronized());
	    assertTrue("Expecting method to be public.", amd.isPublic());
	}

	public void testPackagePrivate() {
	    AccessNode node = new AccessNode(1);
	    assertTrue("Node should default to package private.", node.isPackagePrivate());
	    node.setPrivate();
	    assertFalse("Node set to private, still package private.", node.isPackagePrivate());
	    node = new AccessNode(1);
	    node.setPublic();
	    assertFalse("Node set to public, still package private.", node.isPackagePrivate());
	    node = new AccessNode(1);
	    node.setProtected();
	    assertFalse("Node set to protected, still package private.", node.isPackagePrivate());
	}

	public void testSynchronized() {
	    AccessNode node = new AccessNode(1);
	    assertFalse("Node should default to not synchronized.", node.isSynchronized());
	    node.setSynchronized();
	    assertTrue("Node set to synchronized, not synchronized.", node.isSynchronized());
	}

	public void testAbstract() {
	    AccessNode node = new AccessNode(1);
	    assertFalse("Node should default to not abstract.", node.isAbstract());
	    node.setAbstract();
	    assertTrue("Node set to abstract, not abstract.", node.isAbstract());
	}

	public void testStatic() {
	    AccessNode node = new AccessNode(1);
	    assertFalse("Node should default to not static.", node.isStatic());
	    node.setStatic();
	    assertTrue("Node set to static, not static.", node.isStatic());
	}

	public void testStrict() {
	    AccessNode node = new AccessNode(1);
	    assertFalse("Node should default to not strict.", node.isStrictfp());
	    node.setStrictfp();
	    assertTrue("Node set to strict, not strict.", node.isStrictfp());
	}

	public void testProtected() {
	    AccessNode node = new AccessNode(1);
	    assertFalse("Node should default to not protected.", node.isProtected());
	    node.setProtected();
	    assertTrue("Node set to protected, not protected.", node.isProtected());
	}

	public void testFinal() {
	    AccessNode node = new AccessNode(1);
	    assertFalse("Node should default to not final.", node.isFinal());
	    node.setFinal();
	    assertTrue("Node set to final, not final.", node.isFinal());
	}

	public void testModifiersOnClassDecl() throws Throwable {
	    Set ops = getNodes(ASTClassOrInterfaceDeclaration.class, TEST1);
	    assertTrue(((ASTClassOrInterfaceDeclaration) (ops.iterator().next())).isPublic());
	}

	public void testPrivate() {
	    AccessNode node = new AccessNode(1);
	    assertFalse("Node should default to not private.", node.isPrivate());
	    node.setPrivate();
	    assertTrue("Node set to private, not private.", node.isPrivate());
	}

	public void testTransient() {
	    AccessNode node = new AccessNode(1);
	    assertFalse("Node should default to not transient.", node.isTransient());
	    node.setTransient();
	    assertTrue("Node set to transient, not transient.", node.isTransient());
	}

	public void testNative() {
	    AccessNode node = new AccessNode(1);
	    assertFalse("Node should default to not native.", node.isNative());
	    node.setNative();
	    assertTrue("Node set to native, not native.", node.isNative());
	}

	public void testPublic() {
	    AccessNode node = new AccessNode(1);
	    assertFalse("Node should default to not public.", node.isPublic());
	    node.setPublic();
	    assertTrue("Node set to public, not public.", node.isPublic());
	}

	public void testVolatile() {
	    AccessNode node = new AccessNode(1);
	    assertFalse("Node should default to not volatile.", node.isVolatile());
	    node.setVolatile();
	    assertTrue("Node set to volatile, not volatile.", node.isVolatile());
	}

	public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
	    ASTImplementsList impl = (ASTImplementsList) node.getFirstChildOfType(ASTImplementsList.class);
	    if (impl != null && impl.jjtGetParent().equals(node)) {
	        for (int ix = 0; ix < impl.jjtGetNumChildren(); ix++) {
	            ASTClassOrInterfaceType type = (ASTClassOrInterfaceType) impl.jjtGetChild(ix);
	            if (type.getType() == null) {
	                if ("Cloneable".equals(type.getImage())) {
	                    return data;
	                }
	            } else if (type.getType().equals(Cloneable.class)) {
	                return data;
	            } else {
	                List implementors = Arrays.asList(type.getType().getInterfaces());
	                if (implementors.contains(Cloneable.class)) {
	                    return data;
	                }
	            }
	        }
	    }
	    if (node.jjtGetNumChildren() != 0 && node.jjtGetChild(0).getClass().equals(ASTExtendsList.class)) {
	        ASTClassOrInterfaceType type = (ASTClassOrInterfaceType) ((SimpleNode) node.jjtGetChild(0)).jjtGetChild(0);
	        Class clazz = type.getType();
	        if (clazz != null && clazz.equals(Cloneable.class)) {
	            return data;
	        }
	        while (clazz != null && !Object.class.equals(clazz)) {
	            if (Arrays.asList(clazz.getInterfaces()).contains(Cloneable.class)) {
	                return data;
	            }
	            clazz = clazz.getSuperclass();
	        }
	    }
	
	    return super.visit(node, data);
	}

	public Object visit(ASTMethodDeclarator node, Object data) {
	    if (!"clone".equals(node.getImage())) {
	        return data;
	    }
	    int countParams = ((ASTFormalParameters) node.jjtGetChild(0)).jjtGetNumChildren();
	    if (countParams != 0) {
	        return data;
	    }
	    addViolation(data, node);
	    return data;
	}
}
