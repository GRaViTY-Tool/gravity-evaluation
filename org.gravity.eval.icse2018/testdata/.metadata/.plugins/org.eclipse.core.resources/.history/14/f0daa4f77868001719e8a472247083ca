/*
LICENSE:
                                                                 
   This program is free software; you can redistribute it and/or modify  
   it under the terms of the GNU General Public License as published by  
   the Free Software Foundation; either version 2 of the License, or     
   (at your option) any later version.                                   
                                                                         
   Copyright (C) 2004, GanttProject Development Team
 */
package net.sourceforge.ganttproject.gui;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.util.Iterator;

import javax.swing.tree.DefaultMutableTreeNode;

import net.sourceforge.ganttproject.GanttCalendar;
import net.sourceforge.ganttproject.GanttGraphicArea.GanttPaintParam;
import net.sourceforge.ganttproject.GanttTask;
import net.sourceforge.ganttproject.document.HttpDocument;
import net.sourceforge.ganttproject.task.Task;

/**
 * Created by IntelliJ IDEA.
 * User: bard
 */
public class UIConfiguration {
    private final Font myMenuFont;
    private final Font myChartMainFont;
    private Color myTaskColor;
	private Color myResColor; //default resource color
    private Color myResOverColor; //overload resoure color
    private boolean isRedlineOn;

    public UIConfiguration(Font menuFont, Font chartMainFont, Color taskColor, boolean isRedlineOn) {
        myMenuFont = menuFont==null ? new Font("Dialog", Font.PLAIN, 12) : menuFont;
        myChartMainFont = chartMainFont==null ? new Font("SansSerif", Font.PLAIN, 9) : chartMainFont;
        this.isRedlineOn = isRedlineOn;
        setTaskColor(taskColor);
		myResColor = new Color(140, 182, 206);
        myResOverColor = new Color(229,50,50);
    }


    public Font getMenuFont(){
        return myMenuFont;
    }

    public Font getChartMainFont() {
        return myChartMainFont;
    }

    public Color getTaskColor() {
        return myTaskColor;
    }

    public void setTaskColor(Color myTaskColor) {
        this.myTaskColor = myTaskColor;
    }
    
    public Color getResourceColor() {
        return myResColor;
    }

    public void setResourceColor(Color myResColor) {
        this.myResColor = myResColor;
    }
    
    
    public Color getResourceOverloadColor() {
        return myResOverColor;
    }

    public void setResourceOverloadColor(Color myResOverColor) {
        this.myResOverColor = myResOverColor;		
    }

    public boolean isRedlineOn() {
        return isRedlineOn;
    }

    public void setRedlineOn(boolean redlineOn) {
        isRedlineOn = redlineOn;
    }


	/** This method check if the value has changed, and assk for commit changes. */
		public boolean applyChanges(boolean askForApply)
		{
			if(getAutomatic() == appli.getOptions().getAutomatic() && 
			   getRedLine() == appli.getUIConfiguration().isRedlineOn() &&
			   getDragTime() == appli.getOptions().getDragTime() && 
			   getLockDAVMinutes() == appli.getOptions().getLockDAVMinutes() && 
			   (getTaskNamePrefix()==null || getTaskNamePrefix().equals(appli.getOptions().getTrueTaskNamePrefix())))
			{
				bHasChange = false;
			}
			else 
			{
				bHasChange = true;
				if(!askForApply || (askForApply && askForApplyChanges()))
				{			
					appli.getOptions().setAutomatic(getAutomatic());
					appli.getUIConfiguration().setRedlineOn(getRedLine());				
					appli.getOptions().setDragTime(getDragTime());
					appli.getOptions().setTaskNamePrefix(getTaskNamePrefix());
					
	//				WebDAV Locking
					appli.getOptions().setLockDAVMinutes(getLockDAVMinutes());
					HttpDocument.setLockDAVMinutes(getLockDAVMinutes());				
				}
			}
			
			return bHasChange;
		}


	/** Initialize the component. */
	public void initialize()
	{
		cbAutomatic.setSelected(appli.getOptions().getAutomatic());
		cbRedLine.setSelected(appli.getUIConfiguration().isRedlineOn());
		cbDrag.setSelected(appli.getOptions().getDragTime());
		tfTaskPrefix.setText(appli.getOptions().getTaskNamePrefix());
		spLockDAV.setValue(new Integer(appli.getOptions().getLockDAVMinutes()));
	}


	/** Draw a monther task */
	  public void paintATaskFather(Graphics g, int x1, int x2, int y, Task task) {
	    int d = y;
	    y = y * 20 + 35 - margY;
	
	    if (y < 20 || y > getHeight()) {
	      return; //Not draw if the task is not on the area
	    }
	    if ( (x1 > getWidth() && x2 > getWidth()) || (x1 < 0 && x2 < 0)) {
	      return;
	    }
	
	    //Black rectangle
	    if (drag == d - 1) {
	      g.setColor(arrayColor[4]);
	    }
	    else {
	      if (task.getColor().equals(myUIConfiguration.getTaskColor())) {
	        g.setColor(Color.black);
	      }
	      else {
	        g.setColor( /*Color.black*/task.getColor());
	      }
	    }
	    g.fillRect(x1, y, x2 - x1, 2);
	
	    //Little triangle at begin and end
	    int xPoints[] = new int[3];
	    int yPoints[] = new int[3];
	    xPoints[0] = x1;
	    xPoints[1] = x1 + 5;
	    xPoints[2] = x1;
	    yPoints[0] = y + 2;
	    yPoints[1] = y + 2;
	    yPoints[2] = y + 6;
	    g.fillPolygon(xPoints, yPoints, 3);
	    xPoints[0] = x2;
	    xPoints[1] = x2 - 5;
	    xPoints[2] = x2;
	    g.fillPolygon(xPoints, yPoints, 3);
	
	    //Draw the resource list after the task
			paintResources (x2+40, y+9, task, g);
	
	  }


	/** Paint all tasks  */
	  public void paintTasks(Graphics g) {
	      int sizex = getWidth();
	      int sizey = getHeight();
	      int headery = 45;
	      float fgra = (float) sizex / (float) getGranit(true);
	
	      g.setFont(myUIConfiguration.getChartMainFont());
	
	      //Get all task
	
	      //Probably optimised on next release
	      listOfParam.clear();
	
	      int y = 0;
	
	      for (Iterator tasks = listOfTask.iterator(); tasks.hasNext();) {
	          DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode) tasks.next();
	          GanttTask task = (GanttTask) treeNode.getUserObject();
	
	//Is the task is visible, the task could be draw
	          if (isVisible(task)) {
	              int x1 = -10, x2 = sizex + 10;
	              int e1; //ecart entre la date de debut de la tache et la date du debut du calendrier
	              int fois;
	              int type = 2;
	              y++;
	
	//difference between the start date of the task and the end
	              e1 = date.diff(task.getStart());
	
	//Calcul start and end pixel of each task
	              float fx1, fx2;
	
	              if (task.isMilestone()) {
	                  fx1 = (float) e1 * fgra *
	                          ((date.compareTo(task.getStart()) == 1) ? -1 : 1);
	                  x1 = (int) fx1;
	              } else {
	                  fx1 = (float) e1 * fgra *
	                          ((date.compareTo(task.getStart()) == 1) ? -1 : 1);
	                  fx2 = fx1 + (float) task.getLength() * fgra;
	                  x1 = (int) fx1;
	                  x2 = (int) fx2;
	              }
	
	              int percent = 0;
	
	//Meeting task
	              if (task.isMilestone()) {
	                  paintATaskBilan(g, x1, y, task);
	                  x2 = x1 + (int) fgra;
	                  type = 0;
	              }
	//A mother task
	              else if (tree.getAllChildTask(treeNode).size() != 0) {
	
	                  //Compute percent-complete
	                  tree.computePercentComplete(treeNode);
	
	                  paintATaskFather(g, x1, x2, y, task);
	                  if (drawPercent) {
	                      percent = paintAdvancement(g, x1, x2, y, task.getCompletionPercentage(), task.getShape(),
	                              task.getColor(), true);
	                  }
	                  type = 1;
	              }
	//A normal task
	              else {
	                  paintATaskChild(g, x1, x2, y, task);
	                  if (drawPercent) {
	
	                      percent = paintAdvancement(g, x1, x2, y, task.getCompletionPercentage(), task.getShape(),
	                              task.getColor(), false);
	                  }
	                  type = 2;
	              }
	
	//Add parameters on the array
	              listOfParam.add(new GanttPaintParam(task.getName(), task.getTaskID(),
	                      x1, x2, percent, y, type));
	          }
	      }
	
	  }


	/** Print the list of tasks */
	private void printTasks(Graphics g){
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
	
		g.setColor(Color.black);
		g.setFont(myUIConfiguration.getChartMainFont());
		
		printTask(g,5,42,getTree().getAllChildTask(getTree().getRoot()));
		
	}


	/** Draw a normal task */
	  public void paintATaskChild(Graphics g, int x1, int x2, int y, Task task) {
	    int d = y;
	    y = y * 20 + 27 - margY;
	
	    if (y < 20 || y > getHeight()) {
	      return; //Not draw if the task is not on the area
	    }
	    if ( (x1 > getWidth() && x2 > getWidth()) || (x1 < 0 && x2 < 0)) {
	      return;
	    }
	
	    //Blue rectangle
	      Color c = ((GanttTask)task).colorDefined() ? task.getColor() :myUIConfiguration.getTaskColor();
	    g.setColor(c);
	    g.fillRect(x1, y, (x2 - x1 - 1), 12);
	
	    //Draw nice border
	    //if(draw3dBorders)
	    {	
	    	if (drag == d - 1) {
	    		g.setColor(arrayColor[0]);
	    	}
	    	else {
	    		g.setColor(Color.black);
	    	}
	    	g.drawRect(x1, y, x2 - x1 - 1, 12);
	    	
	    	//AT
	    	//This code print a gray border around the task
	    	//BTW I've comment it for several reason
	    	//- It' increase the time of rendering
	    	//- when printing the char, this border isn't good
	    	//- for the rendering, it's only beautiful with the default color, but not with another one
	    	//- finally I found it nicer now :)
	    	/*g.setColor(arrayColor[7]);
	    	g.drawLine(x1 + 1, y + 1, (x2 - 1) - 1, y + 1);
	    	g.drawLine(x1 + 1, y + 1, x1 + 1, y + 11);
	    	
	    	g.setColor(arrayColor[8]);
	    	g.drawLine(x1 + 2, y + 11, (x2 - 1) - 2, y + 11);
	    	g.drawLine(x2 - 2, y + 2, x2 - 2, y + 11);*/
	  	}
	    
		//Draw the resource list after the task
		paintResources (x2+40, y+10, task, g);
	
	  }


	/** Paint the vertical bars */
	  public void paintCalendar1(Graphics g) {
			int sizex = getWidth();
	    int sizey = getHeight();	
	    int headery = 45;
	    int gra = sizex / getGranit(false); //The granularity
	    int gra2 = getGranit(false);
	    float fgra = (float) sizex / (float) getGranit(false);
	    int drawDate = -1;
	    GanttCalendar dateToPaint = new GanttCalendar();
			
	
			
	    g.setFont(new Font("SansSerif", Font.PLAIN, 12));
	
	    //Reset the background to white
	    g.setColor(Color.white);
			g.fillRect(0, 0, sizex, sizey);
			
	
	    if(!printRendering) {
				calcProjectBegAndEnd();
			}
	    //end.add(1);
	
	    //Draw Horizontal bar on tasks
	    /*g.setColor(arrayColor[14]);
	       for(int i=-margY-4;i<getHeight();i+=40)
	       {
	     g.fillRect(0,i,sizex,20);
	       }*/
	
	    GanttCalendar tmpdate;
	    if (zoomValue == ONE_WEEK || zoomValue == TWO_WEEK) {
	      tmpdate = date.Clone();
	    }
	    else {
	      tmpdate = new GanttCalendar(date.getYear(), date.getMonth(), 1);
	    }
	    g.setFont(new Font("SansSerif", Font.PLAIN, 10));
	
	
	    //Draw the vertical bars
	    for (int i = 0; i < gra2; i++) {
	      String sDay = tmpdate.getdayWeek();
	      String sMonth = tmpdate.getdayMonth();
	
	      //For each day
	      if (zoomValue < 7) {
	        if (sDay.equals(language.getDay(6))) {
	          g.setColor(arrayColor[0]);
	          g.fillRect( (int) (fgra * i), headery, gra + 1 /*(int)(fgra+0.5)*/,sizey);
	
	          g.setColor(arrayColor[1]);
	          if(draw3dBorders)
	          	g.drawLine( (int) (fgra * i), headery, (int) (fgra * i),sizey + headery);
	
	        }
	        else if (sDay.equals(language.getDay(0))) {
	          g.setColor(arrayColor[0]);
	          g.fillRect( (int) (fgra * i), headery, gra + 1 /*(int)(fgra+0.5)*/,sizey);
	          if (zoomValue == ONE_WEEK || zoomValue == TWO_WEEK) {
	            g.setColor(arrayColor[1]);
	            if(draw3dBorders)
	            	g.drawLine( (int) (fgra * i), headery, (int) (fgra * i),sizey + headery);
	          }
	        }
	
	      }
	      else { //For each month
	
	        if (sMonth.equals(language.getMonth(0))) {
	          g.setColor(arrayColor[0]);
	          g.fillRect( (int) (fgra * i), headery, (int) fgra, sizey);
	        }
	        g.setColor(arrayColor[1]);
	        if(draw3dBorders)
	        	g.drawLine( (int) (fgra * i), headery, (int) (fgra * i),sizey + headery);
	
	      }
	
	      if (zoomValue < 7) {
	        if (tmpdate.compareTo(new GanttCalendar()) == 0) {
	          g.setColor(arrayColor[2]);
	          g.fillRect( (int) (fgra * i), headery, (int) fgra, sizey);
	          g.setColor(arrayColor[3]);
	          if(draw3dBorders)
	          	g.drawLine( (int) (fgra * i), headery, (int) (fgra * i),sizey + headery);
	        }
					// stavrides - red line at all zooms
	        if(myUIConfiguration.isRedlineOn())
					{
						GanttCalendar today = new GanttCalendar();
		        float s = fgra / (float) tmpdate.getNumberOfDay();
		        if (tmpdate.equals(today)) {
		              g.setColor(Color.red);
		              g.drawLine(
		                    (int) (fgra * i) + (int) (s * today.getDay()),      headery,
		                    (int) (fgra * i) + (int) (s * today.getDay()),      sizey + headery);
	        	}
					}
	      }
	      else if(myUIConfiguration.isRedlineOn()){
	        GanttCalendar today = new GanttCalendar();
	        float s = fgra / (float) tmpdate.getNumberOfDay();
	        if (tmpdate.getYear() == today.getYear() &&
	            tmpdate.getMonth() == today.getMonth()) {
		  //stavrides - remove blue box in favor of line
	          //Blue rectange on today
	          //g.setColor(arrayColor[2]);
	          //g.fillRect( (int) (fgra * i) + (int) (s * today.getDay()), headery,
	          //           ( (s < 2) ? 2 : (int) s), sizey);
	          //g.setColor(arrayColor[2]);
	          g.setColor(Color.red);
	          g.drawLine( (int) (fgra * i) + (int) (s * today.getDay()), headery,
	                     (int) (fgra * i) + (int) (s * today.getDay()),
	                     sizey + headery);
	
	        }
	      }
	
	      tmpdate.add(getFoot());
	    }
			
	
	    if (zoomValue == ONE_WEEK || zoomValue == TWO_WEEK) {
	      tmpdate = date.Clone();
	    }
	    else {
	      tmpdate = new GanttCalendar(date.getYear(), date.getMonth(), 1);
	
	      //Draw Miscallenous bars
	    }
	    for (int i = 0; i < gra2; i++) {
	      //Courant day in blue
	      if (zoomValue < 7) {
	        //A line on begin and end of project
	        if (tmpdate.compareTo(beg) == 0 || tmpdate.compareTo(end) == 0) {
	          g.setColor(arrayColor[12]);
	          //g.drawLine((int)(fgra*i),headery,(int)(fgra*i),sizey+headery);
	          drawVerticalLinedash(g, (int) (fgra * i), headery, sizey + headery, 5);
	          if (tmpdate.compareTo(beg) == 0) {
	            drawDate = (int) (fgra * i) - 52;
	            dateToPaint = beg;
	          }
	          else {
	            drawDate = (int) (fgra * i) + 3;
	            dateToPaint = end.newAdd( -1);
	          }
	        }
	      }
	      else {
	
	        float s = fgra / (float) tmpdate.getNumberOfDay();
	        //blue dash line for begin
	        if (tmpdate.getYear() == beg.getYear() &&
	            tmpdate.getMonth() == beg.getMonth()) {
	          g.setColor(arrayColor[12]);
	          //g.drawLine((int)(fgra*i)+(int)(s*beg.getDay()),headery,(int)(fgra*i)+(int)(s*beg.getDay()),sizey+headery);
	          int xValue = (int) (fgra * i) + (int) (s * beg.getDay());
			  		drawVerticalLinedash(g, (int) xValue,
	                               headery, sizey + headery, 5);
	          drawDate = xValue - 52;
	          dateToPaint = beg;
	        }
	        //blue dash line for end
	        else if (tmpdate.getYear() == end.getYear() &&
	                 tmpdate.getMonth() == end.getMonth()) {
	          g.setColor(arrayColor[12]);
	          //g.drawLine((int)(fgra*i)+(int)(s*end.getDay()),headery,(int)(fgra*i)+(int)(s*end.getDay()),sizey+headery);
	          int xValue = (int) (fgra * i) + (int) (s * end.getDay());
			  		drawVerticalLinedash(g, xValue,
	                               headery, sizey + headery, 5);
	          drawDate = xValue;
	          dateToPaint = end.newAdd( -1);
	        }
	      }
	
	      //Draw the date in string on calendar
	      if (drawDate >= 0) {
	        g.setFont(new Font("SansSerif", Font.PLAIN, 9));
	        g.setColor(arrayColor[9]);
	        g.drawString(dateToPaint.toString(), drawDate, headery + 20);
	        drawDate = -1;
	      }
	
	      tmpdate.add(getFoot());
	    }
	  }

}
