/* Generated By:JJTree: Do not edit this line. ASTClassOrInterfaceDeclaration.java */

package net.sourceforge.pmd.ast;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod.MethodHolder;
import net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod.MethodInvocation;

public class ASTClassOrInterfaceDeclaration extends AccessNode {
    public ASTClassOrInterfaceDeclaration(int id) {
        super(id);
    }

    public ASTClassOrInterfaceDeclaration(JavaParser p, int id) {
        super(p, id);
    }

    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(JavaParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    public boolean isNested() {
        return jjtGetParent() instanceof ASTClassOrInterfaceBodyDeclaration;
    }

    private boolean isInterface;

    public boolean isInterface() {
        return this.isInterface;
    }

    public void setInterface() {
        this.isInterface = true;
    }

    public void dump(String prefix) {
        String interfaceStr = isInterface ? "interface" : "class";
        String innerStr = isNested() ? "(nested)" : "";
        System.out.println(toString(prefix) + "(" + getImage() + ")(" + interfaceStr + ")" + innerStr);
        dumpChildren(prefix);
    }

	/**
	 * This check must be evaluated independelty for each class.  Inner classses
	 * get their own EvalPackage in order to perform independent evaluation.
	 */
	public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
	    if (!node.isInterface()) {
	        return visitClassDec(node, data);
	    } else {
	        putEvalPackage(nullEvalPackage);
	        Object o = super.visit(node, data);//interface may have inner classes, possible? if not just skip whole interface
	        removeCurrentEvalPackage();
	        return o;
	    }
	}

	/**
	 * Check the methods called on this class by each of the methods on this
	 * class.  If a method calls an unsafe method, mark the calling method as
	 * unsafe.  This changes the list of unsafe methods which necessitates
	 * another pass.  Keep passing until you make a clean pass in which no
	 * methods are changed to unsafe.
	 * For speed it is possible to limit the number of passes.
	 * <p/>
	 * Impossible to tell type of arguments to method, so forget method matching
	 * on types.  just use name and num of arguments.  will be some false hits,
	 * but oh well.
	 *
	 * @todo investigate limiting the number of passes through config.
	 */
	private boolean evaluateDangerOfMethods(Map classMethodMap) {
	    //check each method if it calls overridable method
	    boolean found = false;
	    for (Iterator methodsIter = classMethodMap.entrySet().iterator(); methodsIter.hasNext();) {
	        Map.Entry entry = (Map.Entry) methodsIter.next();
	
	        MethodHolder h = (MethodHolder) entry.getKey();
	        List calledMeths = (List) entry.getValue();
	        for (Iterator calledMethsIter = calledMeths.iterator(); calledMethsIter.hasNext() && !h.isDangerous();) {
	            //if this method matches one of our dangerous methods, mark it dangerous
	            MethodInvocation meth = (MethodInvocation) calledMethsIter.next();
	            //System.out.println("Called meth is " + meth);
	            for (Iterator innerMethsIter = classMethodMap.keySet().iterator(); innerMethsIter.hasNext();) { //need to skip self here h == h3
	                MethodHolder h3 = (MethodHolder) innerMethsIter.next();
	                if (h3.isDangerous()) {
	                    String matchMethodName = h3.getASTMethodDeclarator().getImage();
	                    int matchMethodParamCount = h3.getASTMethodDeclarator().getParameterCount();
	                    //System.out.println("matching " + matchMethodName + " to " + meth.getName());
	                    if (matchMethodName.equals(meth.getName()) && matchMethodParamCount == meth.getArgumentCount()) {
	                        h.setDangerous();
	                        h.setCalledMethod(matchMethodName);
	                        found = true;
	                        break;
	                    }
	                }
	            }
	        }
	    }
	    return found;
	}

	/**
	 * Adds all methods called on this instance from within this Node.
	 */
	private static void addCalledMethodsOfNode(SimpleNode node, List calledMethods, String className) {
	    List expressions = new ArrayList();
	    node.findChildrenOfType(ASTPrimaryExpression.class, expressions);
	    addCalledMethodsOfNodeImpl(expressions, calledMethods, className);
	}

}
