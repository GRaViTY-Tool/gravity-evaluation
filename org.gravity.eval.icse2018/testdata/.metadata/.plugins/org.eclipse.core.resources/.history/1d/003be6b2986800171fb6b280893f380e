package net.sourceforge.ganttproject.task;

import net.sourceforge.ganttproject.GanttCalendar;
import net.sourceforge.ganttproject.GanttGraphicArea.Arrow;
import net.sourceforge.ganttproject.GanttGraphicArea.GanttPaintParam;
import net.sourceforge.ganttproject.GanttGraphicArea.Notes;
import net.sourceforge.ganttproject.GanttTask;
import net.sourceforge.ganttproject.GanttTaskRelationship;
import net.sourceforge.ganttproject.resource.HumanResource;
import net.sourceforge.ganttproject.roles.Role;
import net.sourceforge.ganttproject.shape.ShapePaint;
import net.sourceforge.ganttproject.shape.ShapeConstants;
import net.sourceforge.ganttproject.task.dependency.*;
import net.sourceforge.ganttproject.task.hierarchy.TaskHierarchyItem;
import net.sourceforge.ganttproject.time.TimeUnitManager;
//import net.sourceforge.ganttproject.resource.ProjectResource;
import net.sourceforge.ganttproject.util.ColorConvertion;

import java.util.List;
import java.util.Vector;

import javax.swing.tree.DefaultMutableTreeNode;

import java.util.ArrayList;
import java.util.Iterator;
import java.awt.*;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;

/**
 * Created by IntelliJ IDEA.
 * @author bard
 * Date: 31.01.2004
 */
public class TaskImpl implements Task {
    private int myID;
    private final TaskManagerImpl myManager;
    private String myName;
    private String myWebLink = new String("http://");
    private boolean isMilestone;
    private int myPriority;
    private GanttCalendar myStart;
    private GanttCalendar myEnd;
    private int myCompletionPercentage;
    private TaskLength myLength;
    private boolean isStartFixed;

	private boolean bExpand;
    
    private TimeUnitManager myTimeUnitManager;
    //private final TaskDependencyCollection myDependencies = new TaskDependencyCollectionImpl();
    private final ResourceAssignmentCollectionImpl myAssignments;
    private final TaskDependencySlice myDependencySlice;
    private final TaskDependencySlice myDependencySliceAsDependant;
    private final TaskDependencySlice myDependencySliceAsDependee;
    private boolean myEventsEnabled;
    private final TaskHierarchyItem myTaskHierarchyItem;
    private ShapePaint myShape;
    private Color myColor;
    private String myNotes;


    protected TaskImpl(TaskManager taskManager) {
        myManager = (TaskManagerImpl) taskManager;
        myID = myManager.getMaxID();
        myManager.increaseMaxID();
        myTimeUnitManager = myManager.getTimeUnitManager();
        myAssignments = new ResourceAssignmentCollectionImpl(this);
        myDependencySlice = new TaskDependencySliceImpl(this, myManager.getDependencyCollection());
        myDependencySliceAsDependant = new TaskDependencySliceAsDependant(this, myManager.getDependencyCollection());
        myDependencySliceAsDependee = new TaskDependencySliceAsDependee(this, myManager.getDependencyCollection());
        myPriority = 1;
        myTaskHierarchyItem = myManager.getHierarchyManager().createItem(this);
        isStartFixed = false;
        myNotes = "";
		bExpand = true;
        myColor=null;
    }

    protected TaskImpl(TaskImpl copy) {
        myManager = copy.myManager;
        myAssignments = copy.myAssignments.copy();
        myID = copy.myID;
        myName = copy.myName;
        myWebLink = copy.myWebLink;
        isMilestone = copy.isMilestone;
        myPriority = copy.myPriority;
        myStart = copy.myStart;
        myEnd = copy.myEnd;
        myCompletionPercentage = copy.myCompletionPercentage;
        myLength = copy.myLength;
        isStartFixed = copy.isStartFixed;
        myShape = copy.myShape;
        myColor = copy.myColor;
        myNotes = copy.myNotes;
		bExpand = copy.bExpand;
        //
        myTimeUnitManager = copy.myTimeUnitManager;
        myDependencySlice = copy.myDependencySlice;
        myDependencySliceAsDependant = copy.myDependencySliceAsDependant;
        myDependencySliceAsDependee = copy.myDependencySliceAsDependee;
        myTaskHierarchyItem = myManager.getHierarchyManager().createItem(this);
    }

    public TaskMutator createMutator() {
        return new MutatorImpl();
    }

    // main properties
    public int getTaskID() {
        return myID;
    }

    public String getName() {
        return myName;
    }
    
    public String getWebLink() {
        return myWebLink;
    }

    public boolean isMilestone() {
        return isMilestone;
    }

    public int getPriority() {
        return myPriority;
    }

    public GanttCalendar getStart() {
        return myStart;
    }

    public GanttCalendar getEnd() {
        if (myEnd==null) {
            myEnd = getStart().Clone();
            myEnd.add((int) getDuration().getLength());
        }
        return myEnd;
    }

    public TaskLength getDuration() {
        //System.err.println("[TaskImp] this="+this+" duration="+myLength+" id="+myID);
        return myLength;
    }

    public int getCompletionPercentage() {
        return myCompletionPercentage;
    }

    public boolean isStartFixed() {
        return isStartFixed;
    }

	public boolean getExpand(){
    	return bExpand;
    }

    public ShapePaint getShape() {
        return myShape==null ?
                new ShapePaint(ShapeConstants.BACKSLASH, getColor() , getColor()) :
                myShape;
    }

    public Color getColor() {
        return myColor==null ? myManager.getConfig().getDefaultColor() : myColor;
    }

    public String getNotes() {
        return myNotes;
    }

    public GanttTaskRelationship[] getPredecessors() {
        return new GanttTaskRelationship[0];  //To change body of implemented methods use Options | File Templates.
    }

    public GanttTaskRelationship[] getSuccessors() {
        return new GanttTaskRelationship[0];  //To change body of implemented methods use Options | File Templates.
    }

    public ResourceAssignment[] getAssignments() {
        return myAssignments.getAssignments();
    }

    public ResourceAssignmentCollection getAssignmentCollection() {
        return myAssignments;
    }

    //
    public Task getSupertask() {
        TaskHierarchyItem container = myTaskHierarchyItem.getContainerItem();
        return container.getTask();
    }

    public Task[] getNestedTasks() {
        TaskHierarchyItem[] nestedItems = myTaskHierarchyItem.getNestedItems();
        Task[] result = new Task[nestedItems.length];
        for (int i=0; i<nestedItems.length; i++) {
            result[i] = nestedItems[i].getTask();
        }
        return result;
    }

    public void move(Task targetSupertask) {
        TaskImpl supertaskImpl = (TaskImpl) targetSupertask;
        TaskHierarchyItem targetItem = supertaskImpl.myTaskHierarchyItem;
        myTaskHierarchyItem.delete();
        targetItem.addNestedItem(myTaskHierarchyItem);
    }

    public TaskDependencySlice getDependencies() {
        return myDependencySlice;
    }

    public TaskDependencySlice getDependenciesAsDependant() {
        return myDependencySliceAsDependant;
    }

    public TaskDependencySlice getDependenciesAsDependee() {
        return myDependencySliceAsDependee;
    }

    public TaskManager getManager() {
        return myManager;
    }

    //TODO: remove this hack. ID must never be changed
    protected void setTaskIDHack(int taskID) {
        myID = taskID;
    }

    protected TimeUnitManager getTimeUnitManager() {
        return myTimeUnitManager;
    }

    private class MutatorImpl implements TaskMutator {
        private final List myCommands = new ArrayList();
        public void commit() {
            for (int i=0; i<myCommands.size(); i++) {
                Runnable next = (Runnable) myCommands.get(i);
                next.run();
            }
            myCommands.clear();
        }

        public void setName(final String name) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setName(name);
                }
            });
        }

        public void setMilestone(final boolean milestone) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setMilestone(milestone);
                }
            });
        }

        public void setPriority(final int priority) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setPriority(priority);
                }
            });
        }

        public void setStart(final GanttCalendar start) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setStart(start);
                }
            });
        }

        public void setEnd(final GanttCalendar end) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setEnd(end);
                }
            });
        }

        public void setDuration(final TaskLength length) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setDuration(length);
                }
            });
        }

		public void setExpand(final boolean expand) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setExpand(expand);
                }
            });
        }
    
        public void setCompletionPercentage(final int percentage) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setCompletionPercentage(percentage);
                }
            });
        }

        public void setStartFixed(final boolean isFixed) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setStartFixed(isFixed);
                }
            });
        }

        public void setShape(final ShapePaint shape) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setShape(shape);
                }
            });
        }

        public void setColor(final Color color) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setColor(color);
                }
            });
        }

        public void setNotes(final String notes) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setNotes(notes);
                }
            });
        }

        public void addNotes(final String notes) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.addNotes(notes);
                }
            });
        }

    }

    public void setName(String name) {

        myName = name;
    }
    public void setWebLink(String webLink) {

        myWebLink = webLink;
    }
    public void setMilestone(boolean milestone) {
        isMilestone = milestone;
    }

    public void setPriority(int priority) {
        myPriority = priority;
    }

    public void setStart(GanttCalendar start) {
        GanttCalendar oldStart = myStart==null ? null : myStart.Clone();
        myStart = start;
        if (areEventsEnabled()) {
            myManager.fireTaskScheduleChanged(this, oldStart, getEnd());
        }
    }

    public void setEnd(GanttCalendar end) {
        GanttCalendar oldFinish = myEnd==null ? null : myEnd.Clone();
        myEnd = end;
        int length = myStart.diff(end);
        myLength = getManager().createLength(myLength.getTimeUnit(), length);
        if (areEventsEnabled()) {
            myManager.fireTaskScheduleChanged(this, myStart.Clone(), oldFinish);
        }
    }

    public void setDuration(TaskLength length) {
        GanttCalendar oldFinish = myEnd==null ? null : myEnd.Clone();
        myLength = length;
        myEnd = myStart.newAdd((int) length.getLength());
        if (areEventsEnabled()) {
            myManager.fireTaskScheduleChanged(this, myStart.Clone(), oldFinish);
        }
    }

    public void setCompletionPercentage(int percentage) {
        myCompletionPercentage = percentage;
    }

    public void setStartFixed(boolean isFixed) {
        isStartFixed = isFixed;
    }

    public void setShape(ShapePaint shape) {
        myShape = shape;
    }

    public void setColor(Color color) {
        myColor = color;
    }

    public void setNotes(String notes) {
        myNotes = notes;
	}
    
    public void setExpand(boolean expand){
    	bExpand = expand;
    }

    public void addNotes(String notes) {
        myNotes += notes;
    }

    protected void enableEvents(boolean enabled) {
        myEventsEnabled = enabled;
    }

    protected boolean areEventsEnabled() {
        return myEventsEnabled;
    }

    /**
     * Allows to determine, if a special shape is defined for this task.
     * @return true, if this task has its own shape defined.
     */
    public boolean shapeDefined()
    {
      return (myShape != null);
    }

    /**
     * Allows to determine, if a special color is defined for this task.
     * @return true, if this task has its own color defined.
     */

    public boolean colorDefined() {

      return (myColor != null);

    }

	/** Simple write information of tasks */
	  public void writeTask(Writer fout, DefaultMutableTreeNode node, String space) {
	    String space2 = s + space;
	    try {
	      
	      GanttTask task = (GanttTask)node.getUserObject();
	      
	      if(task.getTaskID()==-1) throw new RuntimeException("A task can not has a number equal to -1");
	      
	      
	      int id=task.getTaskID();
	      
	      /*if (id >= lot.size()) {
	        return;
	      }*/
	      
	      
	      boolean haschild = false;
	
	      ArrayList child = tree.getAllChildTask(node);
	      if (child.size() != 0) {
	        haschild = true;
	
	      }
	
	      number.add(new Integer(id));
	      cpt++;
	
	//      boolean one = (task.getSuccessorsOld().size() != 0 || (task.getNotes() != null && task.getNotes().length()>=0) ||
	//                     haschild);
		
		boolean one = (task.getSuccessorsOld().size()==0 && (task.getNotes() == null || task.getNotes().length()==0) && !haschild);
	
	
	      //Writes data of task
	      fout.write(space + "<task id=\"" + task.getTaskID() + //lots.indexOf(task.toString()) + //By CL
	                 "\" ");
	      fout.write("name=\"" + correct(task.getName()) + "\" ");
	
	      if (task.colorDefined()) {
	        /*fout.write("color=\"#");
	        if (task.getColor().getRed() <= 15) {
	          fout.write("0");
	        }
	        fout.write(Integer.toHexString(task.getColor().getRed()));
	        if (task.getColor().getGreen() <= 15) {
	          fout.write("0");
	        }
	        fout.write(Integer.toHexString(task.getColor().getGreen()));
	        if (task.getColor().getBlue() <= 15) {
	          fout.write("0");
	        }
	        fout.write(Integer.toHexString(task.getColor().getBlue()));
	        fout.write("\" ");*/
			fout.write("color=\""+ColorConvertion.getColor(task.getColor())+"\" ");
	      }
	
	      if (task.shapeDefined() && 
	      		task.getShape() != new ShapePaint(ShapeConstants.BACKSLASH, 
	      				task.getColor() , task.getColor())) {
		  fout.write("shape=\"" + task.getShape().getArray()+ "\" ");
	      }
	
	      fout.write("meeting=\"" + ( (task.isMilestone()) ? "true" : "false") +
	                 "\" ");
	      fout.write("start=\"" + task.getStart().toXMLString() + "\" ");
	      fout.write("duration=\"" + task.getLength() + "\" ");
	      fout.write("complete=\"" + task.getCompletionPercentage() + "\" ");
	        fout.write("fixed-start=\"" + (task.isStartFixed() ? "true" : "false") + "\" ");
	      fout.write("priority=\"" + task.getPriority() + "\"");
	      
	      //write the web link of the task
	      String sWebLink = task.getWebLink();
	      if(sWebLink != null && !sWebLink.equals("") && !sWebLink.equals("http://"))
	      	fout.write(" webLink=\"" + sWebLink + "\"");
	      
	      //write if the task is expand or collapse      
	      fout.write(" expand=\"" + task.getExpand() + "\"");
		  	
	      if (!one) {
	        fout.write(">\n");
	      }
	      else {
	        fout.write("/>\n");
	        //fout.writeBytes(">\n");
	
	        //Write notes
	      }
	      if (task.getNotes() != null && task.getNotes().length()>0) {
	        fout.write(space2 + "<notes>");
	        fout.write("\n" + space2 + s + correct(replaceAll(task.getNotes(), "\n", "\n" + space2 + s)));
	        fout.write("\n" + space2 + "</notes>\n");
	      }
	
	      //Write the depends of the task
	      /*
	      if (task.getDepend().size() != 0) {
	        //fout.writeBytes(space2+"<depends>\n");
	        for (int i = 0; i < task.getDepend().size(); i++) {
	          fout.write(space2 + "<depend id=\"" +
	                     tree.getTask( (String) task.getDepend().get(i)).getTaskID() + // changed By CL
	                     //lots.indexOf( (String) task.getDepend().get(i)) +
	                     "\"/>\n");
	          //fout.writeBytes(space2+"</depends>\n");
	        }
	      }*/
	
	      //use successors to write depends information
	      Vector successors = task.getSuccessorsOld();
	      for (int i = 0; i < successors.size(); i++) {
	        GanttTaskRelationship relationship
	            = (GanttTaskRelationship) successors.get(i);
	        fout.write(space2 /*+s*/ + "<depend id=\"" +
	                   relationship.getSuccessorTaskID()+"\""
	                   +" type=\""
	                   +relationship.getRelationshipType()
	                   +"\"/>\n");
	      }
	
	      //Write the child of the task
	      if (haschild) {
	        for (int i = 0; i < child.size(); i++) {
	          Task task2 = (Task) ( (DefaultMutableTreeNode) child.get(i)).
	              getUserObject();
	          int newid = -1; //lot.lastIndexOf(task2);
	
	          for (int j = 0; j < lot.size(); j++) {
	            String a = task2.toString();
	            String b = lot.get(j).toString();
	
	            if (a.equals(b)) {
	              newid = j;
	            }
	          }
	          writeTask(fout, (DefaultMutableTreeNode)child.get(i), space + s);
	        }
	
	      }
	
	      //end of task section
	      if (!one) {
	        fout.write(space + "</task>\n");
	        //fout.writeBytes(space+"</task>\n");
	
	      }
	      //      if (tree.getNode(task.toString()).isLeaf() &&
	      //          !tree.getFatherNode(task).isRoot()) {
	      //        return;
	      //      }
	
	      //      if (id == lot.size() - 1) {
	      //        return;
	      //      }
	      //      else {
	      //        writeTask(fout, cpt, space);
	      //
	      //      }
	
	    }
	    catch (Exception e) {
	      System.out.println(e);
	    }
	  }

	/**@return the link of the task. */
	private String getWebLink(GanttTask task)
	{
		return (task.getWebLink().equals("http://")?"":task.getWebLink());
	}

	/**set the maximum size for all strings. */
	void getMaxSize()
	{
		iMaxSize = 0;
		for(Iterator it=lot.iterator(); it.hasNext();)
	    {
			DefaultMutableTreeNode node = (DefaultMutableTreeNode) it.next();
			if(!node.isRoot())
			{
				GanttTask task = (GanttTask)(node.getUserObject());
	
				if(csvOptions.bExportTaskID){
					String s=""+task.getTaskID();
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskName){
					String s=""+getName(node, task);
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskStartDate){
					String s=""+task.getStart();
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskEndDate){
					String s=""+task.getEnd();
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskDuration){
					String s=""+task.getLength();
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskPercent){
					String s=""+task.getCompletionPercentage();
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskWebLink){
					String s=""+getWebLink(task);
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskResources){
					String s=""+getAssignments(task);
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}
				
				if(csvOptions.bExportTaskNotes){
					String s=""+task.getNotes();
					if(s.length()>iMaxSize)iMaxSize=s.length();
				}	
				
			}
	    }
		
		//parse all resources
		for (int i = 0; i < resources.size(); i++)
		{
		   	HumanResource p = (HumanResource) resources.get(i);
		   	
		   	if(csvOptions.bExportResourceID){
				String s=""+p.getId();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
		   	if(csvOptions.bExportResourceName){
				String s=""+p.getName();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
		   	if(csvOptions.bExportResourceMail){
				String s=""+p.getMail();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
		   	if(csvOptions.bExportResourcePhone){
				String s=""+p.getPhone();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
		   	if(csvOptions.bExportResourceRole){
		   		Role role = p.getRole();
		        String sRoleID = "0";
		        if(role != null) sRoleID = role.getPersistentID();
				String s=""+sRoleID;
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
		}
		
	} //get maxIndentation end

	/** Write all tasks. */
		private void writeTasks(OutputStreamWriter out) throws IOException 
		{
	//		parse all tasks	
		    for(Iterator it=lot.iterator(); it.hasNext();)
			{
				DefaultMutableTreeNode node = (DefaultMutableTreeNode) it.next();
				if(!node.isRoot())
				{
					GanttTask task = (GanttTask)(node.getUserObject());
					
					//ID
					if(csvOptions.bExportTaskID)
						out.write(correctField(""+task.getTaskID())+
								(bFixedSize?"":csvOptions.sSeparatedChar));
						
					//Name
					if(csvOptions.bExportTaskName)
						out.write((bFixedSize?"":csvOptions.sSeparatedTextChar)+
								correctField(getName(node, task))+
								(bFixedSize?"":csvOptions.sSeparatedTextChar+
								csvOptions.sSeparatedChar));
					
					//Start Date
					if(csvOptions.bExportTaskStartDate)
						out.write(correctField(task.getStart().toString())+
								(bFixedSize?"":csvOptions.sSeparatedChar));
					
					//End Date
					if(csvOptions.bExportTaskEndDate)
						out.write(correctField(task.getEnd().toString())+
								(bFixedSize?"":csvOptions.sSeparatedChar));
					
					//Duration
					if(csvOptions.bExportTaskDuration)
						out.write(correctField(""+task.getLength())+
								(bFixedSize?"":csvOptions.sSeparatedChar));
					
					//Percent complete
					if(csvOptions.bExportTaskPercent)
						out.write(correctField(""+task.getCompletionPercentage())+
								(bFixedSize?"":csvOptions.sSeparatedChar));				
	
					//Web Link
					if(csvOptions.bExportTaskWebLink)
						out.write((bFixedSize?"":csvOptions.sSeparatedTextChar)+
								correctField(getWebLink(task))+
								(bFixedSize?"":csvOptions.sSeparatedTextChar+
								csvOptions.sSeparatedChar));				
					
					//associated resources
					if(csvOptions.bExportTaskResources) {
						out.write((bFixedSize?"":csvOptions.sSeparatedTextChar));					
						out.write(correctField(getAssignments(task)));					
						out.write((bFixedSize?"":csvOptions.sSeparatedTextChar+
								csvOptions.sSeparatedChar));
					}
					
					//Notes
					if(csvOptions.bExportTaskNotes)
						out.write((bFixedSize?"":csvOptions.sSeparatedTextChar)+
								correctField(task.getNotes())+
								(bFixedSize?"":csvOptions.sSeparatedTextChar+
								csvOptions.sSeparatedChar));
					
					out.write("\n");
				}
			}	    
		} //end of write tasks

	/** @return the list of the assignment for the resources. */
	private String getAssignments(GanttTask task)
	{
		String res = "";
		ResourceAssignment[] assignment = task.getAssignments();
		for(int i=0;i<assignment.length;i++)
			res+=(assignment[i].getResource()+(i==assignment.length-1?"":
					csvOptions.sSeparatedChar.equals(";")?",":";"));
		return res;
	}

	/**@return the name of task with the correct level.*/
	private String getName(DefaultMutableTreeNode node, GanttTask task)
	{
		if(bFixedSize) return task.getName();
		String res="";
		for(int i=0;i<node.getLevel();i++)
			res+="  ";
		return res+task.getName();
	}

	/** Draw a normal task */
	  public void paintATaskChild(Graphics g, int x1, int x2, int y, Task task) {
	    int d = y;
	    y = y * 20 + 27 - margY;
	
	    if (y < 20 || y > getHeight()) {
	      return; //Not draw if the task is not on the area
	    }
	    if ( (x1 > getWidth() && x2 > getWidth()) || (x1 < 0 && x2 < 0)) {
	      return;
	    }
	
	    //Blue rectangle
	      Color c = ((GanttTask)task).colorDefined() ? task.getColor() :myUIConfiguration.getTaskColor();
	    g.setColor(c);
	    g.fillRect(x1, y, (x2 - x1 - 1), 12);
	
	    //Draw nice border
	    //if(draw3dBorders)
	    {	
	    	if (drag == d - 1) {
	    		g.setColor(arrayColor[0]);
	    	}
	    	else {
	    		g.setColor(Color.black);
	    	}
	    	g.drawRect(x1, y, x2 - x1 - 1, 12);
	    	
	    	//AT
	    	//This code print a gray border around the task
	    	//BTW I've comment it for several reason
	    	//- It' increase the time of rendering
	    	//- when printing the char, this border isn't good
	    	//- for the rendering, it's only beautiful with the default color, but not with another one
	    	//- finally I found it nicer now :)
	    	/*g.setColor(arrayColor[7]);
	    	g.drawLine(x1 + 1, y + 1, (x2 - 1) - 1, y + 1);
	    	g.drawLine(x1 + 1, y + 1, x1 + 1, y + 11);
	    	
	    	g.setColor(arrayColor[8]);
	    	g.drawLine(x1 + 2, y + 11, (x2 - 1) - 2, y + 11);
	    	g.drawLine(x2 - 2, y + 2, x2 - 2, y + 11);*/
	  	}
	    
		//Draw the resource list after the task
		paintResources (x2+40, y+10, task, g);
	
	  }

	/** Paint all tasks  */
	  public void paintTasks(Graphics g) {
	      int sizex = getWidth();
	      int sizey = getHeight();
	      int headery = 45;
	      float fgra = (float) sizex / (float) getGranit(true);
	
	      g.setFont(myUIConfiguration.getChartMainFont());
	
	      //Get all task
	
	      //Probably optimised on next release
	      listOfParam.clear();
	
	      int y = 0;
	
	      for (Iterator tasks = listOfTask.iterator(); tasks.hasNext();) {
	          DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode) tasks.next();
	          GanttTask task = (GanttTask) treeNode.getUserObject();
	
	//Is the task is visible, the task could be draw
	          if (isVisible(task)) {
	              int x1 = -10, x2 = sizex + 10;
	              int e1; //ecart entre la date de debut de la tache et la date du debut du calendrier
	              int fois;
	              int type = 2;
	              y++;
	
	//difference between the start date of the task and the end
	              e1 = date.diff(task.getStart());
	
	//Calcul start and end pixel of each task
	              float fx1, fx2;
	
	              if (task.isMilestone()) {
	                  fx1 = (float) e1 * fgra *
	                          ((date.compareTo(task.getStart()) == 1) ? -1 : 1);
	                  x1 = (int) fx1;
	              } else {
	                  fx1 = (float) e1 * fgra *
	                          ((date.compareTo(task.getStart()) == 1) ? -1 : 1);
	                  fx2 = fx1 + (float) task.getLength() * fgra;
	                  x1 = (int) fx1;
	                  x2 = (int) fx2;
	              }
	
	              int percent = 0;
	
	//Meeting task
	              if (task.isMilestone()) {
	                  paintATaskBilan(g, x1, y, task);
	                  x2 = x1 + (int) fgra;
	                  type = 0;
	              }
	//A mother task
	              else if (tree.getAllChildTask(treeNode).size() != 0) {
	
	                  //Compute percent-complete
	                  tree.computePercentComplete(treeNode);
	
	                  paintATaskFather(g, x1, x2, y, task);
	                  if (drawPercent) {
	                      percent = paintAdvancement(g, x1, x2, y, task.getCompletionPercentage(), task.getShape(),
	                              task.getColor(), true);
	                  }
	                  type = 1;
	              }
	//A normal task
	              else {
	                  paintATaskChild(g, x1, x2, y, task);
	                  if (drawPercent) {
	
	                      percent = paintAdvancement(g, x1, x2, y, task.getCompletionPercentage(), task.getShape(),
	                              task.getColor(), false);
	                  }
	                  type = 2;
	              }
	
	//Add parameters on the array
	              listOfParam.add(new GanttPaintParam(task.getName(), task.getTaskID(),
	                      x1, x2, percent, y, type));
	          }
	      }
	
	  }

	/** Draw the arrows for depends */
	  public void paintDepend(Graphics g) {
	  
	  
	  	//for paint triangles
	    int xPoints[] = new int[3];
	    int yPoints[] = new int[3];
		
	  
	  	//Set the color to black
	     g.setColor(Color.black);
		
		//Parsing all tasks
		for(Iterator tasks=listOfTask.iterator(); tasks.hasNext(); ) {
			//Get the task
			GanttTask task = (GanttTask)(((DefaultMutableTreeNode)tasks.next()).getUserObject());
			//Only if the task is visible
			if(isVisible(task)) {
				//Get all sucessors for the task
				Vector successors = task.getSuccessorsOld();
				//Parsing the sucessors
				for(Iterator suc=successors.iterator(); suc.hasNext();){
					//Get the relashionship
					GanttTaskRelationship relationship = (GanttTaskRelationship)suc.next();
					//Get the second task
					Task task2 = relationship.getSuccessorTask();
					//Only if the second task is visible
					if (this.isVisible(task2)) {
						//Get the start index and end index for param values
	          int index1 = this.indexOf(listOfParam, task.getTaskID());
	          int index2 = this.indexOf(listOfParam, task2.getTaskID());
						
						//System.out.println(task+"  "+task2+"  "+index1+" "+index2);
						try{
						//Y coords
						int yt1 = ( (GanttPaintParam) listOfParam.get(index1)).y;
	          int yt2 = ( (GanttPaintParam) listOfParam.get(index2)).y;
						yt1 = yt1 * 20 + 32 - margY;
						yt2 = yt2 * 20 + 32 - margY;
						
						//Start-Start relashion
						if(relationship.getRelationshipType()==GanttTaskRelationship.SS) {
							//Get x coord
							int x1t1 = ( (GanttPaintParam) listOfParam.get(index1)).x1;
							int x1t2 = ( (GanttPaintParam) listOfParam.get(index2)).x1;
							
							int xa=(x1t1<x1t2)?x1t1-7:x1t2-7;
							
							//Draw Lines
							g.drawLine(x1t1, yt1, xa, yt1);
				            g.drawLine(xa, yt1, xa, yt2);
							g.drawLine(xa, yt2, x1t2, yt2);
							
							//Traiangle for task 1
							/*x1t1--;
							xPoints[0] = x1t1;
	              			xPoints[1] = x1t1 - 3;
				            xPoints[2] = x1t1 - 3;
							yPoints[0] = yt1;
							yPoints[1] = yt1 - 4;
							yPoints[2] = yt1 + 4;
							g.fillPolygon(xPoints, yPoints, 3);*/
							//Traiangle for task 2
							x1t2--;
							xPoints[0] = x1t2;
	              			xPoints[1] = x1t2 - 3;
				            xPoints[2] = x1t2 - 3;
							yPoints[0] = yt2;
							yPoints[1] = yt2 - 4;
							yPoints[2] = yt2 + 4;
							g.fillPolygon(xPoints, yPoints, 3);
						
						//Finish-Start relashion
						} else if(relationship.getRelationshipType()==GanttTaskRelationship.FS) {
							//Get x coord
							int x2t1 = ( (GanttPaintParam) listOfParam.get(index1)).x2;
							int x1t2 = ( (GanttPaintParam) listOfParam.get(index2)).x1;
							
							x1t2 += 2;
							
							xPoints[0] = x1t2;
	              			xPoints[1] = x1t2 + 3;
				            xPoints[2] = x1t2 - 3;
	
				            if (yt1 > yt2) {
				              yt2 += 7;
				              yPoints[1] = yt2 + 4;
				              yPoints[2] = yt2 + 4;
				            }
				            else {
				              yt2 -= 6;
				              yPoints[1] = yt2 - 4;
				              yPoints[2] = yt2 - 4;
				            }
				            yPoints[0] = yt2;
				
							g.fillPolygon(xPoints, yPoints, 3);
				            g.drawLine(x2t1, yt1, x1t2, yt1);
				            g.drawLine(x1t2, yt1, x1t2, yt2);
						
						//Finish-Finish relashion
						} else if(relationship.getRelationshipType()==GanttTaskRelationship.FF) {
							//Get x coord
							int x2t1 = ( (GanttPaintParam) listOfParam.get(index1)).x2;
							int x2t2 = ( (GanttPaintParam) listOfParam.get(index2)).x2;
							
							int xa=(x2t1>x2t2)?x2t1+7:x2t2+7;
							
							//Draw Lines
							g.drawLine(x2t1, yt1, xa, yt1);
				            g.drawLine(xa, yt1, xa, yt2);
							g.drawLine(xa, yt2, x2t2, yt2);
							
							//Traiangle for task 1
							/*x2t1++;
							xPoints[0] = x2t1;
	              			xPoints[1] = x2t1 + 3;
				            xPoints[2] = x2t1 + 3;
							yPoints[0] = yt1;
							yPoints[1] = yt1 - 4;
							yPoints[2] = yt1 + 4;
							g.fillPolygon(xPoints, yPoints, 3);*/
							//Traiangle for task 2
							x2t2++;
							xPoints[0] = x2t2;
	              			xPoints[1] = x2t2 + 3;
				            xPoints[2] = x2t2 + 3;
							yPoints[0] = yt2;
							yPoints[1] = yt2 - 4;
							yPoints[2] = yt2 + 4;
							g.fillPolygon(xPoints, yPoints, 3);
						
						//Start-Finish relashion
						} else if(relationship.getRelationshipType()==GanttTaskRelationship.SF) {
							//Get x coord
							int x1t1 = ( (GanttPaintParam) listOfParam.get(index1)).x1;
							int x2t2 = ( (GanttPaintParam) listOfParam.get(index2)).x2;
						
							x2t2 -= 3;
							
							xPoints[0] = x2t2;
	              			xPoints[1] = x2t2 + 3;
				            xPoints[2] = x2t2 - 3;
	
				            if (yt1 > yt2) {
				              yt2 += 7;
				              yPoints[1] = yt2 + 4;
				              yPoints[2] = yt2 + 4;
				            }
				            else {
				              yt2 -= 6;
				              yPoints[1] = yt2 - 4;
				              yPoints[2] = yt2 - 4;
				            }
				            yPoints[0] = yt2;
				
							g.fillPolygon(xPoints, yPoints, 3);
				            g.drawLine(x1t1, yt1, x2t2, yt1);
				            g.drawLine(x2t2, yt1, x2t2, yt2);
						
						}
						
						}catch(Exception e){}
					
					}//End of visible Task2			
				}//End of parsing the successors
			}//End of isVisible Task1
		}//End of parsing the iterator
		
	  } //Enf of paintDepend function

	/** Detect if the position of the mouse is on a special place (return -1 if nothing or the numer of the task*/
	  public int detectPosition(int mx, int my, boolean all) {
	    for (int i = 0; i < listOfParam.size(); i++) {
	      GanttPaintParam param = (GanttPaintParam) listOfParam.get(i);
	      if ( ( (param.type == 2 || param.type == 0) && !all) || all) {
	        int y = param.y * 20 + 27 - margY;
	        int x1 = param.x1;
	        int x2 = param.x2;
	        int x3 = param.x3;
	
	        if ( (my >= y && my <= y + 12)) {
	          //The end of the task
	          if (mx >= x2 /*-2*/ && mx <= x2 + 2) {
	            typeSeletion = 0;
	            setTaskToMove(i);
	            GanttCalendar enddate = taskToMove.getEnd().newAdd( -1);
	            notes = new Notes(enddate.toString(), mx, y - 30);
	            arrow.setDraw(false);
	            return i;
	          }
	          //the start of the task
	          else if (mx >= x1 - 2 && mx <= x1 /*+2*/) {
	            typeSeletion = 1;
	            setTaskToMove(i);
	            notes = new Notes(taskToMove.getStart().toString(), mx, y - 30);
	            arrow.setDraw(false);
				      return i;
	          }
	          //the percent length
	          else if (mx >= x3 - 2 && mx <= x3 + 2) {
	            typeSeletion = 3;
	            setTaskToMove(i);
	            notes = new Notes("  " + taskToMove.getCompletionPercentage() + "%", mx, y - 30);
	            arrow.setDraw(false);
	            return i;
	          }
	
	          //A depend
	          else if (mx > x1 + 3 && mx < x2 - 3) {
	            typeSeletion = 2;
	
	            if (param.type != 0) {
	              arrow = new Arrow(mx, y + 6, mx, y + 6);
	              notes.setDraw(false);
	            }
	            else {
	              setTaskToMove(i);
	              notes = new Notes(taskToMove.getStart().toString(), mx, y - 30);
	            }
	
	            return i;
	          }
	        }
	      }
	    }
	    return -1;
	  }

}
