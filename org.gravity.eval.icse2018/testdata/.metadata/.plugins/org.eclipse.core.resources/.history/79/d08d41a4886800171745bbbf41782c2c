/* Generated By:JJTree: Do not edit this line. ASTElement.java */

package net.sourceforge.pmd.jsp.ast;

public class ASTElement extends SimpleNode {

/* BEGIN CUSTOM CODE */

    /**
     * Name of the element-tag. Cannot be null.
     */
    private String name;

    /**
     * Flag indicating that the element consists of one tag ("<... />").
     */
    private boolean empty; //


    /**
     * @return boolean - true if the element has a namespace-prefix, false otherwise
     */
    public boolean isHasNamespacePrefix() {
        return (name.indexOf(':') >= 0);
    }

    /**
     * @return String - the part of the name that is before the (first) colon (":")
     */
    public String getNamespacePrefix() {
        int colonIndex = name.indexOf(':');
        return ((colonIndex >= 0)
                ? name.substring(0, colonIndex)
                : "");
    }

    /**
     * @return String - The part of the name that is after the first colon (":").
     *         If the name does not contain a colon, the full name is returned.
     */
    public String getLocalName() {
        int colonIndex = name.indexOf(':');
        return ((colonIndex >= 0)
                ? name.substring(colonIndex + 1)
                : name);
    }

    /**
     * @return Returns the name.
     */
    public String getName() {
        return name;
    }

    /**
     * @param name The name to set.
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * @return Returns the empty.
     */
    public boolean isEmpty() {
        return empty;
    }

    /**
     * @param empty The empty to set.
     */
    public void setEmpty(boolean empty) {
        this.empty = empty;
    }

    /* (non-Javadoc)
     * @see com.applicationengineers.pmd4jsp.ast.SimpleNode#toString(java.lang.String)
     */
    public String toString(String prefix) {
        return super.toString(prefix) + " name=[" + name + "] ";
    }
/* END CUSTOM CODE */



    public ASTElement(int id) {
        super(id);
    }

    public ASTElement(JspParser p, int id) {
        super(p, id);
    }


    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(JspParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

	final public String UnparsedText() throws ParseException {
	 /*@bgen(jjtree) UnparsedText */
	  ASTUnparsedText jjtn000 = new ASTUnparsedText(this, JJTUNPARSEDTEXT);
	  boolean jjtc000 = true;
	  jjtree.openNodeScope(jjtn000);Token t;
	    try {
	      t = jj_consume_token(UNPARSED_TEXT);
	          jjtree.closeNodeScope(jjtn000, true);
	          jjtc000 = false;
	                jjtn000.setImage(t.image);
	                {if (true) return t.image;}
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	    throw new RuntimeException("Missing return statement in function");
	  }

	/**
	 * Text that contains no single quotes, and that does not contain the start
	 * of a EL expression or value binding.
	 */
	  final public String UnparsedTextNoSingleQuotes() throws ParseException {
	 /*@bgen(jjtree) UnparsedText */
	  ASTUnparsedText jjtn000 = new ASTUnparsedText(this, JJTUNPARSEDTEXT);
	  boolean jjtc000 = true;
	  jjtree.openNodeScope(jjtn000);Token t;
	    try {
	      t = jj_consume_token(UNPARSED_TEXT_NO_SINGLE_QUOTES);
	          jjtree.closeNodeScope(jjtn000, true);
	          jjtc000 = false;
	                jjtn000.setImage(t.image);
	                {if (true) return t.image;}
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	    throw new RuntimeException("Missing return statement in function");
	  }

	/**
	 * The value of an attribute of an element.
	 * EL expressions, JSF value bindings, and JSP expressions
	 * are parsed as sub-nodes of the AttributeValue node.
	 */
	  final public void AttributeValue() throws ParseException {
	 /*@bgen(jjtree) AttributeValue */
	        ASTAttributeValue jjtn000 = new ASTAttributeValue(this, JJTATTRIBUTEVALUE);
	        boolean jjtc000 = true;
	        jjtree.openNodeScope(jjtn000);StringBuffer content = new StringBuffer();
	        String tmp;
	        Token t;
	    try {
	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	      case DOUBLE_QUOTE:
	        jj_consume_token(DOUBLE_QUOTE);
	        label_8:
	        while (true) {
	          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	          case EL_EXPRESSION_IN_ATTRIBUTE:
	          case VALUE_BINDING_IN_ATTRIBUTE:
	          case JSP_EXPRESSION_IN_ATTRIBUTE:
	          case UNPARSED_TEXT_NO_DOUBLE_QUOTES:
	            ;
	            break;
	          default:
	            jj_la1[15] = jj_gen;
	            break label_8;
	          }
	          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	          case UNPARSED_TEXT_NO_DOUBLE_QUOTES:
	            tmp = UnparsedTextNoDoubleQuotes();
	            break;
	          case EL_EXPRESSION_IN_ATTRIBUTE:
	          case VALUE_BINDING_IN_ATTRIBUTE:
	          case JSP_EXPRESSION_IN_ATTRIBUTE:
	            tmp = QuoteIndependentAttributeValueContent();
	            break;
	          default:
	            jj_la1[16] = jj_gen;
	            jj_consume_token(-1);
	            throw new ParseException();
	          }
	                            content.append(tmp);
	        }
	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	        case ENDING_DOUBLE_QUOTE:
	          jj_consume_token(ENDING_DOUBLE_QUOTE);
	          break;
	        case DOLLAR_OR_HASH_DOUBLE_QUOTE:
	          t = jj_consume_token(DOLLAR_OR_HASH_DOUBLE_QUOTE);
	                                                                    content.append(t.image.substring(0, 1));
	          break;
	        default:
	          jj_la1[17] = jj_gen;
	          jj_consume_token(-1);
	          throw new ParseException();
	        }
	        break;
	      case SINGLE_QUOTE:
	        jj_consume_token(SINGLE_QUOTE);
	        label_9:
	        while (true) {
	          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	          case EL_EXPRESSION_IN_ATTRIBUTE:
	          case VALUE_BINDING_IN_ATTRIBUTE:
	          case JSP_EXPRESSION_IN_ATTRIBUTE:
	          case UNPARSED_TEXT_NO_SINGLE_QUOTES:
	            ;
	            break;
	          default:
	            jj_la1[18] = jj_gen;
	            break label_9;
	          }
	          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	          case UNPARSED_TEXT_NO_SINGLE_QUOTES:
	            tmp = UnparsedTextNoSingleQuotes();
	            break;
	          case EL_EXPRESSION_IN_ATTRIBUTE:
	          case VALUE_BINDING_IN_ATTRIBUTE:
	          case JSP_EXPRESSION_IN_ATTRIBUTE:
	            tmp = QuoteIndependentAttributeValueContent();
	            break;
	          default:
	            jj_la1[19] = jj_gen;
	            jj_consume_token(-1);
	            throw new ParseException();
	          }
	                            content.append(tmp);
	        }
	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	        case ENDING_SINGLE_QUOTE:
	          jj_consume_token(ENDING_SINGLE_QUOTE);
	          break;
	        case DOLLAR_OR_HASH_SINGLE_QUOTE:
	          t = jj_consume_token(DOLLAR_OR_HASH_SINGLE_QUOTE);
	                                                                 content.append(t.image.substring(0, 1));
	          break;
	        default:
	          jj_la1[20] = jj_gen;
	          jj_consume_token(-1);
	          throw new ParseException();
	        }
	        break;
	      default:
	        jj_la1[21] = jj_gen;
	        jj_consume_token(-1);
	        throw new ParseException();
	      }
	          jjtree.closeNodeScope(jjtn000, true);
	          jjtc000 = false;
	          jjtn000.setImage( content.toString() );
	    } catch (Throwable jjte000) {
	          if (jjtc000) {
	            jjtree.clearNodeScope(jjtn000);
	            jjtc000 = false;
	          } else {
	            jjtree.popNode();
	          }
	          if (jjte000 instanceof RuntimeException) {
	            {if (true) throw (RuntimeException)jjte000;}
	          }
	          if (jjte000 instanceof ParseException) {
	            {if (true) throw (ParseException)jjte000;}
	          }
	          {if (true) throw (Error)jjte000;}
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	  }

	/**
	 * Text that contains no double quotes, and that does not contain the start
	 * of a EL expression or value binding.
	 */
	  final public String UnparsedTextNoDoubleQuotes() throws ParseException {
	 /*@bgen(jjtree) UnparsedText */
	  ASTUnparsedText jjtn000 = new ASTUnparsedText(this, JJTUNPARSEDTEXT);
	  boolean jjtc000 = true;
	  jjtree.openNodeScope(jjtn000);Token t;
	    try {
	      t = jj_consume_token(UNPARSED_TEXT_NO_DOUBLE_QUOTES);
	          jjtree.closeNodeScope(jjtn000, true);
	          jjtc000 = false;
	                jjtn000.setImage(t.image);
	                {if (true) return t.image;}
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	    throw new RuntimeException("Missing return statement in function");
	  }

	final public void JspExpression() throws ParseException {
	 /*@bgen(jjtree) JspExpression */
	        ASTJspExpression jjtn000 = new ASTJspExpression(this, JJTJSPEXPRESSION);
	        boolean jjtc000 = true;
	        jjtree.openNodeScope(jjtn000);Token t;
	    try {
	      jj_consume_token(JSP_EXPRESSION_START);
	      t = jj_consume_token(JSP_EXPRESSION);
	                               jjtn000.setImage(t.image.trim());
	      jj_consume_token(JSP_EXPRESSION_END);
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	  }

	final public String ElExpressionInAttribute() throws ParseException {
	 /*@bgen(jjtree) ElExpression */
	        ASTElExpression jjtn000 = new ASTElExpression(this, JJTELEXPRESSION);
	        boolean jjtc000 = true;
	        jjtree.openNodeScope(jjtn000);Token t;
	    try {
	      t = jj_consume_token(EL_EXPRESSION_IN_ATTRIBUTE);
	          jjtree.closeNodeScope(jjtn000, true);
	          jjtc000 = false;
	                jjtn000.setImage(expressionContent(t.image));
	                {if (true) return t.image;}
	    } finally {
	          if (jjtc000) {
	            jjtree.closeNodeScope(jjtn000, true);
	          }
	    }
	    throw new RuntimeException("Missing return statement in function");
	  }
}
