package net.sf.jabref.util;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.*;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;

import net.sf.jabref.*;
import tests.net.sf.jabref.FileBasedTestCase;
import tests.net.sf.jabref.util.XMPUtilTest;

import org.jempbox.impl.XMLUtil;
import org.jempbox.xmp.XMPMetadata;
import org.jempbox.xmp.XMPSchema;
import org.jempbox.xmp.XMPSchemaDublinCore;
import org.pdfbox.pdmodel.PDDocument;
import org.pdfbox.pdmodel.PDDocumentCatalog;
import org.pdfbox.pdmodel.common.PDMetadata;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class XMPSchemaBibtex extends XMPSchema {

	/**
	 * The namespace of this schema.
	 */
	public static final String NAMESPACE = "http://jabref.sourceforge.net/bibteXMP/";

	public static final String KEY = "bibtex";

	/**
	 * Create a new empty XMPSchemaBibtex as a child in the given XMPMetadata.
	 * 
	 * @param parent
	 */
	public XMPSchemaBibtex(XMPMetadata parent) {
		super(parent, KEY, NAMESPACE);
	}

	/**
	 * Create schema from an existing XML element.
	 * 
	 * @param element
	 *            The existing XML element.
	 */
	public XMPSchemaBibtex(Element e, String namespace) {
		super(e, KEY);
	}

	protected String makeProperty(String propertyName) {
		return KEY + ":" + propertyName;
	}

	/**
	 * 
	 * @param field
	 * @return
	 * @derived Uses XMPSchema methods
	 */
	public List<String> getPersonList(String field) {
		return getSequenceList(field);
	}

	/**
	 * 
	 * @param field
	 * @param value
	 * @derived Uses XMPSchema methods
	 */
	public void setPersonList(String field, String value) {
		AuthorList list = AuthorList.getAuthorList(value);

		int n = list.size();
		for (int i = 0; i < n; i++) {
			addSequenceValue(field, list.getAuthor(i).getFirstLast(false));
		}
	}

	public String getTextProperty(String field) {
		return super.getTextProperty(makeProperty(field));
	}

	public void setTextProperty(String field, String value) {
		super.setTextProperty(makeProperty(field), value);
	}

	@SuppressWarnings("unchecked")
	public List<String> getBagList(String bagName) {
		return super.getBagList(makeProperty(bagName));
	}

	public void removeBagValue(String bagName, String value) {
		super.removeBagValue(makeProperty(bagName), value);
	}

	public void addBagValue(String bagName, String value) {
		super.addBagValue(makeProperty(bagName), value);
	}

	@SuppressWarnings("unchecked")
	public List<String> getSequenceList(String seqName) {
		return super.getSequenceList(makeProperty(seqName));
	}

	public void removeSequenceValue(String seqName, String value) {
		super.removeSequenceValue(makeProperty(seqName), value);
	}

	public void addSequenceValue(String seqName, String value) {
		super.addSequenceValue(makeProperty(seqName), value);
	}

	@SuppressWarnings("unchecked")
	public List<String> getSequenceDateList(String seqName) throws IOException {
		return super.getSequenceDateList(makeProperty(seqName));
	}

	public void removeSequenceDateValue(String seqName, Calendar date) {
		super.removeSequenceDateValue(makeProperty(seqName), date);
	}

	public void addSequenceDateValue(String field, Calendar date) {
		super.addSequenceDateValue(makeProperty(field), date);
	}

	public static String getContents(NodeList seqList) {

		Element seqNode = (Element) seqList.item(0);
		StringBuffer seq = null;

		NodeList items = seqNode.getElementsByTagName("rdf:li");
		for (int j = 0; j < items.getLength(); j++) {
			Element li = (Element) items.item(j);
			if (seq == null) {
				seq = new StringBuffer();
			} else {
				seq.append(" and ");
			}
			seq.append(getTextContent(li));
		}
		if (seq != null) {
			return seq.toString();
		}
		return null;
	}

	/**
	 * Returns a map of all properties and their values. LIs and bags in seqs
	 * are concatenated using " and ".
	 * 
	 * @return Map from name of textproperty (String) to value (String). For
	 *         instance: "year" => "2005". Empty map if none found.
	 * @throws TransformerException
	 */
	public static Map<String, String> getAllProperties(XMPSchema schema, String namespaceName) {
		NodeList nodes = schema.getElement().getChildNodes();

		Map<String, String> result = new HashMap<String, String>();

		if (nodes == null) {
			return result;
		}

		// Check child-nodes first
		int n = nodes.getLength();

		for (int i = 0; i < n; i++) {
			Node node = nodes.item(i);
			if (node.getNodeType() != Node.ATTRIBUTE_NODE
				&& node.getNodeType() != Node.ELEMENT_NODE)
				continue;

			String nodeName = node.getNodeName();

			String[] split = nodeName.split(":");

			if (split.length == 2 && split[0].equals(namespaceName)) {
				NodeList seqList = ((Element) node).getElementsByTagName("rdf:Seq");
				if (seqList.getLength() > 0) {

					String seq = getContents(seqList);

					if (seq != null) {
						result.put(split[1], seq);
					}
				} else {
					NodeList bagList = ((Element) node).getElementsByTagName("rdf:Bag");
					if (bagList.getLength() > 0) {

						String seq = getContents(bagList);

						if (seq != null) {
							result.put(split[1], seq);
						}
					} else {
						result.put(split[1], getTextContent(node));
					}
				}
			}
		}

		// Then check Attributes
		NamedNodeMap attrs = schema.getElement().getAttributes();
		int m = attrs.getLength();
		for (int j = 0; j < m; j++) {
			Node attr = attrs.item(j);

			String nodeName = attr.getNodeName();
			String[] split = nodeName.split(":");
			if (split.length == 2 && split[0].equals(namespaceName)) {
				result.put(split[1], attr.getNodeValue());
			}
		}

		/*
		 * Collapse Whitespace
		 * 
		 * Quoting from
		 * http://www.gerg.ca/software/btOOL/doc/bt_postprocess.html: <cite>
		 * "The exact rules for collapsing whitespace are simple: non-space
		 * whitespace characters (tabs and newlines mainly) are converted to
		 * space, any strings of more than one space within are collapsed to a
		 * single space, and any leading or trailing spaces are deleted."
		 * </cite>
		 */
		
		for (Map.Entry<String, String> entry : result.entrySet()){
			String key = entry.getKey();
			if (preserveWhiteSpace.contains(key))
				continue;
			entry.setValue(entry.getValue().replaceAll("\\s+", " ").trim());
		}

		return result;
	}

	public static HashSet<String> preserveWhiteSpace = new HashSet<String>();
	static {
		preserveWhiteSpace.add("abstract");
		preserveWhiteSpace.add("note");
		preserveWhiteSpace.add("review");
	}

	public void setBibtexEntry(BibtexEntry entry) {
		setBibtexEntry(entry, null);
	}
	
	/**
	 * 
	 * @param entry
	 * @param database maybenull
	 */
	public void setBibtexEntry(BibtexEntry entry, BibtexDatabase database) {
		// Set all the values including key and entryType
		Set<String> fields = entry.getAllFields();
		
		JabRefPreferences prefs = JabRefPreferences.getInstance();
		if (prefs.getBoolean("useXmpPrivacyFilter")) {
			TreeSet<String> filters = new TreeSet<String>(Arrays.asList(prefs.getStringArray("xmpPrivacyFilters")));
			fields.removeAll(filters);
		}
		
		for (String field : fields){
			String value = BibtexDatabase.getResolvedField(field, entry, database);
			if (field.equals("author") || field.equals("editor")) {
				setPersonList(field, value);
			} else {
				setTextProperty(field, value);
			}
		}
		setTextProperty("entrytype", entry.getType().getName());
	}

	public BibtexEntry getBibtexEntry() {

		String type = getTextProperty("entrytype");
		BibtexEntryType t;
		if (type != null)
			t = BibtexEntryType.getStandardType(type);
		else
			t = BibtexEntryType.OTHER;

		BibtexEntry e = new BibtexEntry(Util.createNeutralId(), t);

		// Get Text Properties
		Map<String, String> text = getAllProperties(this, "bibtex");
		text.remove("entrytype");
		e.setField(text);
		return e;
	}

	public void testSetGetBagListString() throws IOException {
	
		XMPMetadata xmp = new XMPMetadata();
		XMPSchemaBibtex bibtex = new XMPSchemaBibtex(xmp);
	
		bibtex.addBagValue("author", "Tom DeMarco");
		bibtex.addBagValue("author", "Kent Beck");
		{
	
			List<String> l = bibtex.getBagList("author");
	
			assertEquals(2, l.size());
	
			assertTrue(l.get(0).equals("Tom DeMarco")
				|| l.get(1).equals("Tom DeMarco"));
			assertTrue(l.get(0).equals("Kent Beck")
				|| l.get(1).equals("Kent Beck"));
		}
		{
			bibtex.removeBagValue("author", "Kent Beck");
			List<String> l = bibtex.getBagList("author");
			assertEquals(1, l.size());
			assertTrue(l.get(0).equals("Tom DeMarco"));
		}
		{ // Already removed
			bibtex.removeBagValue("author", "Kent Beck");
			List<String> l = bibtex.getBagList("author");
			assertEquals(1, l.size());
			assertTrue(l.get(0).equals("Tom DeMarco"));
		}
		{ // Duplicates allowed!
			bibtex.addBagValue("author", "Tom DeMarco");
			List<String> l = bibtex.getBagList("author");
			assertEquals(2, l.size());
			assertTrue(l.get(0).equals("Tom DeMarco"));
			assertTrue(l.get(1).equals("Tom DeMarco"));
		}
		{ // Removes both
			bibtex.removeBagValue("author", "Tom DeMarco");
			List<String> l = bibtex.getBagList("author");
			assertEquals(0, l.size());
		}
	}

	public void testSetGetTextPropertyString() throws IOException {
		XMPMetadata xmp = new XMPMetadata();
		XMPSchemaBibtex bibtex = new XMPSchemaBibtex(xmp);
	
		bibtex.setTextProperty("title",
			"The advanced Flux-Compensation for Delawney-Separation");
	
		Element e = bibtex.getElement();
		assertEquals("The advanced Flux-Compensation for Delawney-Separation",
			e.getAttribute("bibtex:title"));
	
		assertEquals("The advanced Flux-Compensation for Delawney-Separation",
			bibtex.getTextProperty("title"));
	
		bibtex.setTextProperty("title",
			"The advanced Flux-Correlation for Delawney-Separation");
	
		e = bibtex.getElement();
		assertEquals("The advanced Flux-Correlation for Delawney-Separation", e
			.getAttribute("bibtex:title"));
	
		assertEquals("The advanced Flux-Correlation for Delawney-Separation",
			bibtex.getTextProperty("title"));
	
		bibtex
			.setTextProperty(
				"abstract",
				"   The abstract\n can go \n \n on several \n lines with \n many \n\n empty ones in \n between.");
		assertEquals(
			"   The abstract\n can go \n \n on several \n lines with \n many \n\n empty ones in \n between.",
			bibtex.getTextProperty("abstract"));
	}

	public void testGetTextContent() throws IOException {
		String bibtexString = "<bibtex:year>2003</bibtex:year>\n"
			+ "<bibtex:title>\n   "
			+ "Beach sand convolution by surf-wave optimzation\n"
			+ "</bibtex:title>\n"
			+ "<bibtex:bibtexkey>OezbekC06</bibtex:bibtexkey>\n";
	
		bibtexString = XMPUtilTest.bibtexXPacket(XMPUtilTest
			.bibtexDescription(bibtexString));
	
		Document d = XMLUtil.parse(new ByteArrayInputStream(bibtexString
			.getBytes()));
	
		assertEquals("Beach sand convolution by surf-wave optimzation",
			XMPSchemaBibtex.getTextContent(
				d.getElementsByTagName("bibtex:title").item(0)).trim());
	
	}

	public void testSetBibtexEntry() throws IOException {
	
		XMPMetadata xmp = new XMPMetadata();
		XMPSchemaBibtex bibtex = new XMPSchemaBibtex(xmp);
	
		BibtexEntry e = FileBasedTestCase.getBibtexEntry();
		bibtex.setBibtexEntry(e, null);
	
		BibtexEntry e2 = bibtex.getBibtexEntry();
	
		assertEquals(e, e2);
	}

	public void testXMPSchemaBibtexXMPMetadata() throws IOException {
	
		XMPMetadata xmp = new XMPMetadata();
		XMPSchemaBibtex bibtex = new XMPSchemaBibtex(xmp);
	
		assertNotNull(bibtex.getElement());
		assertEquals("rdf:Description", bibtex.getElement().getTagName());
	
	}

	public void testGetSequenceListString() throws IOException {
	
		XMPMetadata xmp = new XMPMetadata();
		XMPSchemaBibtex bibtex = new XMPSchemaBibtex(xmp);
	
		bibtex.addSequenceValue("author", "Tom DeMarco");
		bibtex.addSequenceValue("author", "Kent Beck");
		{
	
			List<String> l = bibtex.getSequenceList("author");
	
			assertEquals(2, l.size());
	
			assertEquals("Tom DeMarco", l.get(0));
			assertEquals("Kent Beck", l.get(1));
		}
		{
			bibtex.removeSequenceValue("author", "Tom DeMarco");
			List<String> l = bibtex.getSequenceList("author");
			assertEquals(1, l.size());
			assertTrue(l.get(0).equals("Kent Beck"));
		}
		{ // Already removed
			bibtex.removeSequenceValue("author", "Tom DeMarco");
			List<String> l = bibtex.getSequenceList("author");
			assertEquals(1, l.size());
			assertTrue(l.get(0).equals("Kent Beck"));
		}
		{ // Duplicates allowed!
			bibtex.addSequenceValue("author", "Kent Beck");
			List<String> l = bibtex.getSequenceList("author");
			assertEquals(2, l.size());
			assertTrue(l.get(0).equals("Kent Beck"));
			assertTrue(l.get(1).equals("Kent Beck"));
		}
		{ // Remvoes all
			bibtex.removeSequenceValue("author", "Kent Beck");
			List<String> l = bibtex.getSequenceList("author");
			assertEquals(0, l.size());
		}
	}

	public void testGetAllProperties() throws IOException {
		XMPMetadata xmp = new XMPMetadata();
		XMPSchemaBibtex bibtex = new XMPSchemaBibtex(xmp);
	
		bibtex.setTextProperty("title", "BlaBla Ta Ta\nHello World");
		bibtex.setTextProperty("abstract", "BlaBla Ta Ta\nHello World");
		bibtex.setTextProperty("review", "BlaBla Ta Ta\nHello World");
		bibtex.setTextProperty("note", "BlaBla Ta Ta\nHello World");
		bibtex.setPersonList("author", "Mouse, Mickey and Bond, James");
	
		Map<String, String> s = XMPSchemaBibtex.getAllProperties(bibtex,
			"bibtex");
	
		assertEquals(5, s.size());
		assertTrue(s.containsKey("title"));
		assertTrue(s.containsKey("author"));
	
		assertEquals("BlaBla Ta Ta Hello World", s.get("title"));
		assertEquals("BlaBla Ta Ta\nHello World", s.get("abstract"));
		assertEquals("BlaBla Ta Ta\nHello World", s.get("review"));
		assertEquals("BlaBla Ta Ta\nHello World", s.get("note"));
		assertEquals("Mickey Mouse and James Bond", s.get("author"));
	}

	public void testGetSetPersonList() throws IOException {
		XMPMetadata xmp = new XMPMetadata();
		XMPSchemaBibtex bibtex = new XMPSchemaBibtex(xmp);
	
		bibtex.setPersonList("author", "Tom DeMarco and Kent Beck");
	
		Element e = bibtex.getElement();
	
		NodeList l1 = e.getElementsByTagName("bibtex:author");
		assertEquals(1, l1.getLength());
	
		NodeList l = e.getElementsByTagName("rdf:li");
	
		assertEquals(2, l.getLength());
	
		assertEquals("Tom DeMarco", XMLUtil
			.getStringValue(((Element) l.item(0))));
		assertEquals("Kent Beck", XMLUtil.getStringValue(((Element) l.item(1))));
	
		List<String> authors = bibtex.getPersonList("author");
		assertEquals(2, authors.size());
	
		assertEquals("Tom DeMarco", authors.get(0));
		assertEquals("Kent Beck", authors.get(1));
	}

	public void testXMPSchemaBibtexElement()
		throws ParserConfigurationException {
		DocumentBuilderFactory builderFactory = DocumentBuilderFactory
			.newInstance();
		DocumentBuilder builder = builderFactory.newDocumentBuilder();
		Element e = builder.newDocument().createElement("rdf:Description");
	
		XMPSchemaBibtex bibtex = new XMPSchemaBibtex(e, "bibtex");
	
		assertEquals(e, bibtex.getElement());
		assertEquals("rdf:Description", bibtex.getElement().getTagName());
	}

	@SuppressWarnings("unchecked")
	public void testReadWriteDC() throws IOException, TransformerException {
		List<BibtexEntry> l = new LinkedList<BibtexEntry>();
		l.add(t3BibtexEntry());
	
		XMPUtil.writeXMP(pdfFile, l, null, true);
	
		PDDocument document = PDDocument.load(pdfFile.getAbsoluteFile());
		try {
			if (document.isEncrypted()) {
				System.err
						.println("Error: Cannot add metadata to encrypted document.");
				System.exit(1);
			}
	
			assertEquals("Kelly Clarkson and Ozzy Osbourne", document
					.getDocumentInformation().getAuthor());
			assertEquals("Hypersonic ultra-sound", document
					.getDocumentInformation().getTitle());
			assertEquals("Huey Duck and Dewey Duck and Louie Duck", document
					.getDocumentInformation().getCustomMetadataValue(
							"bibtex/editor"));
			assertEquals("Clarkson06", document.getDocumentInformation()
					.getCustomMetadataValue("bibtex/bibtexkey"));
			assertEquals("peanut,butter,jelly", document
					.getDocumentInformation().getKeywords());
	
			assertEquals(t3BibtexEntry(), XMPUtil
					.getBibtexEntryFromDocumentInformation(document
							.getDocumentInformation()));
	
			PDDocumentCatalog catalog = document.getDocumentCatalog();
			PDMetadata metaRaw = catalog.getMetadata();
	
			if (metaRaw == null) {
				fail();
				return;
			}
	
			XMPMetadata meta = new XMPMetadata(XMLUtil.parse(metaRaw
					.createInputStream()));
			meta.addXMLNSMapping(XMPSchemaBibtex.NAMESPACE,
					XMPSchemaBibtex.class);
	
			// Check Dublin Core
			List<XMPSchema> schemas = meta
					.getSchemasByNamespaceURI("http://purl.org/dc/elements/1.1/");
			assertEquals(1, schemas.size());
	
			XMPSchemaDublinCore dcSchema = (XMPSchemaDublinCore) schemas
					.iterator().next();
			assertNotNull(dcSchema);
	
			assertEquals("Hypersonic ultra-sound", dcSchema.getTitle());
			assertEquals("1982-07", dcSchema.getSequenceList("dc:date").get(0));
			assertEquals("Kelly Clarkson", dcSchema.getCreators().get(0));
			assertEquals("Ozzy Osbourne", dcSchema.getCreators().get(1));
			assertEquals("Huey Duck", dcSchema.getContributors().get(0));
			assertEquals("Dewey Duck", dcSchema.getContributors().get(1));
			assertEquals("Louie Duck", dcSchema.getContributors().get(2));
			assertEquals("Inproceedings", dcSchema.getTypes().get(0));
			assertEquals("bibtex/bibtexkey/Clarkson06", dcSchema
					.getRelationships().get(0));
			assertEquals("peanut", dcSchema.getSubjects().get(0));
			assertEquals("butter", dcSchema.getSubjects().get(1));
			assertEquals("jelly", dcSchema.getSubjects().get(2));
	
			/**
			 * Bibtexkey, Journal, pdf, booktitle
			 */
			assertEquals(4, dcSchema.getRelationships().size());
	
			assertEquals(t3BibtexEntry(), XMPUtil
					.getBibtexEntryFromDublinCore(dcSchema));
	
		} finally {
			document.close();
		}
	
	}

	/**
	 * Taken from DOM2Utils.java:
	 * 
	 * JBoss, the OpenSource EJB server
	 * 
	 * Distributable under LGPL license. See terms of license at gnu.org.
	 */
	public static String getTextContent(Node node) {
		boolean hasTextContent = false;
		StringBuffer buffer = new StringBuffer();
		NodeList nlist = node.getChildNodes();
		for (int i = 0; i < nlist.getLength(); i++) {
			Node child = nlist.item(i);
			if (child.getNodeType() == Node.TEXT_NODE) {
				buffer.append(child.getNodeValue());
				hasTextContent = true;
			}
		}
		return (hasTextContent ? buffer.toString() : "");
	}

}
