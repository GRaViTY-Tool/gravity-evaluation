/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.log4j;

import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OnlyOnceErrorHandler;
import org.apache.log4j.net.SyslogAppender;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.Socket;
import java.util.Date;

import javax.jms.JMSException;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.Transport;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.InternetHeaders;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMultipart;
import javax.mail.internet.MimeUtility;

import org.apache.log4j.helpers.LogLog;


/** 
 * Abstract superclass of the other appenders in the package.
 *  
 *  This class provides the code for common functionality, such as
 *  support for threshold filtering and support for general filters.
 *
 * @since 0.8.1
 * @author Ceki G&uuml;lc&uuml; 
 * */
public abstract class AppenderSkeleton implements Appender, OptionHandler {

  /** The layout variable does not need to be set if the appender
      implementation has its own layout. */
  protected Layout layout;

  /** Appenders are named. */
  protected String name;

  /**
     There is no level threshold filtering by default.  */
  protected Priority threshold;

  /** 
      It is assumed and enforced that errorHandler is never null.
  */
  protected ErrorHandler errorHandler = new OnlyOnceErrorHandler();

  /** The first filter in the filter chain. Set to <code>null</code>
      initially. */
  protected Filter headFilter;
  /** The last filter in the filter chain. */
  protected Filter tailFilter;

  /**
     Is this appender closed? 
   */
  protected boolean closed = false;

    /**
     * Create new instance.
     */
    public AppenderSkeleton() {
        super();
    }

    /**
     * Create new instance.
     * Provided for compatibility with log4j 1.3.
     *
     * @param isActive true if appender is ready for use upon construction.
     *                 Not used in log4j 1.2.x.
     * @since 1.2.15
     */
    protected AppenderSkeleton(final boolean isActive) {
        super();
    }



  /**
     Derived appenders should override this method if option structure
     requires it.  */
  public
  void activateOptions() {
  }


  /**
     Add a filter to end of the filter list.

     @since 0.9.0
   */
  public
  void addFilter(Filter newFilter) {
    if(headFilter == null) {
      headFilter = tailFilter = newFilter;
    } else {
      tailFilter.setNext(newFilter);
      tailFilter = newFilter;    
    }
  }

  /**
     Subclasses of <code>AppenderSkeleton</code> should implement this
     method to perform actual logging. See also {@link #doAppend
     AppenderSkeleton.doAppend} method.

     @since 0.9.0
  */
  abstract
  protected
  void append(LoggingEvent event);


  /**
     Clear the filters chain.
     
     @since 0.9.0 */
  public
  void clearFilters() {
    headFilter = tailFilter = null;
  }

  /**
     Finalize this appender by calling the derived class'
     <code>close</code> method.

     @since 0.8.4 */
  public
  void finalize() {
    // An appender might be closed then garbage collected. There is no
    // point in closing twice.
    if(this.closed) 
      return;

    LogLog.debug("Finalizing appender named ["+name+"].");
    close();
  }


  /** 
      Return the currently set {@link ErrorHandler} for this
      Appender.  

      @since 0.9.0 */
  public
  ErrorHandler getErrorHandler() {
    return this.errorHandler;
  }


  /**
     Returns the head Filter.
     
     @since 1.1
  */
  public
  Filter getFilter() {
    return headFilter;
  }

  /** 
      Return the first filter in the filter chain for this
      Appender. The return value may be <code>null</code> if no is
      filter is set.
      
  */
  public
  final
  Filter getFirstFilter() {
    return headFilter;
  }

  /**
     Returns the layout of this appender. The value may be null.
  */
  public
  Layout getLayout() {
    return layout;
  }


  /**
     Returns the name of this appender.
     @return name, may be null.
   */
  public
  final
  String getName() {
    return this.name;
  }

  /**
     Returns this appenders threshold level. See the {@link
     #setThreshold} method for the meaning of this option.
     
     @since 1.1 */
  public
  Priority getThreshold() {
    return threshold;
  }


  /**
     Check whether the message level is below the appender's
     threshold. If there is no threshold set, then the return value is
     always <code>true</code>.

  */
  public
  boolean isAsSevereAsThreshold(Priority priority) {
    return ((threshold == null) || priority.isGreaterOrEqual(threshold));
  }


  /**
    * This method performs threshold checks and invokes filters before
    * delegating actual logging to the subclasses specific {@link
    * AppenderSkeleton#append} method.
    * */
  public
  synchronized 
  void doAppend(LoggingEvent event) {
    if(closed) {
      LogLog.error("Attempted to append to closed appender named ["+name+"].");
      return;
    }
    
    if(!isAsSevereAsThreshold(event.getLevel())) {
      return;
    }

    Filter f = this.headFilter;
    
    FILTER_LOOP:
    while(f != null) {
      switch(f.decide(event)) {
      case Filter.DENY: return;
      case Filter.ACCEPT: break FILTER_LOOP;
      case Filter.NEUTRAL: f = f.getNext();
      }
    }
    
    this.append(event);    
  }

  /** 
      Set the {@link ErrorHandler} for this Appender.
      @since 0.9.0
  */
  public
  synchronized
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      // We do not throw exception here since the cause is probably a
      // bad config file.
      LogLog.warn("You have tried to set a null error-handler.");
    } else {
      this.errorHandler = eh;
    }
  }

  /**
     Set the layout for this appender. Note that some appenders have
     their own (fixed) layouts or do not use one. For example, the
     {@link org.apache.log4j.net.SocketAppender} ignores the layout set
     here. 
  */
  public
  void setLayout(Layout layout) {
    this.layout = layout;
  }

  
  /**
     Set the name of this Appender.
   */
  public
  void setName(String name) {
    this.name = name;
  }


  /**
     Set the threshold level. All log events with lower level
     than the threshold level are ignored by the appender.
     
     <p>In configuration files this option is specified by setting the
     value of the <b>Threshold</b> option to a level
     string, such as "DEBUG", "INFO" and so on.
     
     @since 0.8.3 */
  public
  void setThreshold(Priority threshold) {
    this.threshold = threshold;
  }

/**
     * Test prediction of check period.
     */
  public
  void testComputeCheckPeriod() {
    DailyRollingFileAppender drfa = new DailyRollingFileAppender();
    drfa.setName("testComputeCheckPeriod");
    drfa.setDatePattern("yyyy-MM-dd.'log'");
    drfa.activateOptions();

    drfa.computeCheckPeriod();
    assertEquals(drfa.computeCheckPeriod(),
         DailyRollingFileAppender.TOP_OF_DAY);

    drfa.setDatePattern("yyyy-MM-dd mm.'log'");
    assertEquals(drfa.computeCheckPeriod(),
         DailyRollingFileAppender.TOP_OF_MINUTE);

    drfa.setDatePattern("yyyy-MM-dd a.'log'");
    assertEquals(drfa.computeCheckPeriod(),
         DailyRollingFileAppender.HALF_DAY);

    drfa.setDatePattern("yyyy-MM-dd HH.'log'");
    assertEquals(drfa.computeCheckPeriod(),
         DailyRollingFileAppender.TOP_OF_HOUR);

    drfa.setDatePattern("yyyy-MM.'log'");
    assertEquals(drfa.computeCheckPeriod(),
         DailyRollingFileAppender.TOP_OF_MONTH);

    drfa.setDatePattern("'log'HH'log'");
    assertEquals(drfa.computeCheckPeriod(),
         DailyRollingFileAppender.TOP_OF_HOUR);
  }

InternetAddress[] parseAddress(String addressStr) {
    try {
      return InternetAddress.parse(addressStr, true);
    } catch(AddressException e) {
      errorHandler.error("Could not parse address ["+addressStr+"].", e,
			 ErrorCode.ADDRESS_PARSE_FAILURE);
      return null;
    }
  }

InternetAddress getAddress(String addressStr) {
    try {
      return new InternetAddress(addressStr);
    } catch(AddressException e) {
      errorHandler.error("Could not parse address ["+addressStr+"].", e,
			 ErrorCode.ADDRESS_PARSE_FAILURE);
      return null;
    }
  }

/**
     Send the contents of the cyclic buffer as an e-mail message.
   */
  protected
  void sendBuffer() {

    try {
      String s = formatBody();
      boolean allAscii = true;
      for(int i = 0; i < s.length() && allAscii; i++) {
          allAscii = s.charAt(i) <= 0x7F;
      }
      MimeBodyPart part;
      if (allAscii) {
          part = new MimeBodyPart();
          part.setContent(s, layout.getContentType());
      } else {
          try {
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            Writer writer = new OutputStreamWriter(
                    MimeUtility.encode(os, "quoted-printable"), "UTF-8");
            writer.write(s);
            writer.close();
            InternetHeaders headers = new InternetHeaders();
            headers.setHeader("Content-Type", layout.getContentType() + "; charset=UTF-8");
            headers.setHeader("Content-Transfer-Encoding", "quoted-printable");
            part = new MimeBodyPart(headers, os.toByteArray());
          } catch(Exception ex) {
              StringBuffer sbuf = new StringBuffer(s);
              for (int i = 0; i < sbuf.length(); i++) {
                  if (sbuf.charAt(i) >= 0x80) {
                      sbuf.setCharAt(i, '?');
                  }
              }
              part = new MimeBodyPart();
              part.setContent(sbuf.toString(), layout.getContentType());
          }
      }



      Multipart mp = new MimeMultipart();
      mp.addBodyPart(part);
      msg.setContent(mp);

      msg.setSentDate(new Date());
      Transport.send(msg);
    } catch(MessagingException e) {
      LogLog.error("Error occured while sending e-mail notification.", e);
    } catch(RuntimeException e) {
      LogLog.error("Error occured while sending e-mail notification.", e);
    }
  }

synchronized
  public
  void close() {
    this.closed = true;
    if (sendOnClose && cb.length() > 0) {
        sendBuffer();
    }
  }

/**
   * Layout body of email message.
   * @since 1.2.16  
   */
  protected String formatBody() {
	  
	  // Note: this code already owns the monitor for this
	  // appender. This frees us from needing to synchronize on 'cb'.
	  
      StringBuffer sbuf = new StringBuffer();
      String t = layout.getHeader();
      if(t != null)
	sbuf.append(t);
      int len =  cb.length();
      for(int i = 0; i < len; i++) {
	//sbuf.append(MimeUtility.encodeText(layout.format(cb.get())));
	LoggingEvent event = cb.get();
	sbuf.append(layout.format(event));
	if(layout.ignoresThrowable()) {
	  String[] s = event.getThrowableStrRep();
	  if (s != null) {
	    for(int j = 0; j < s.length; j++) {
	      sbuf.append(s[j]);
	      sbuf.append(Layout.LINE_SEP);
	    }
	  }
	}
      }
      t = layout.getFooter();
      if(t != null) {
	    sbuf.append(t);
      }
      
      return sbuf.toString();
  }

/**
     This method determines if there is a sense in attempting to append.

     <p>It checks whether there is a set output target and also if
     there is a set layout. If these checks fail, then the boolean
     value <code>false</code> is returned. */
  protected
  boolean checkEntryConditions() {
    if(this.msg == null) {
      errorHandler.error("Message object not configured.");
      return false;
    }

    if(this.evaluator == null) {
      errorHandler.error("No TriggeringEventEvaluator is set for appender ["+
			 name+"].");
      return false;
    }


    if(this.layout == null) {
      errorHandler.error("No layout set for appender named ["+name+"].");
      return false;
    }
    return true;
  }

protected boolean checkEntryConditions() {
    String fail = null;

    if(this.topicConnection == null) {
      fail = "No TopicConnection";
    } else if(this.topicSession == null) {
      fail = "No TopicSession";
    } else if(this.topicPublisher == null) {
      fail = "No TopicPublisher";
    }

    if(fail != null) {
      errorHandler.error(fail +" for JMSAppender named ["+name+"].");
      return false;
    } else {
      return true;
    }
  }

/**
     Close this JMSAppender. Closing releases all resources used by the
     appender. A closed appender cannot be re-opened. */
  public synchronized void close() {
    // The synchronized modifier avoids concurrent append and close operations

    if(this.closed)
      return;

    LogLog.debug("Closing appender ["+name+"].");
    this.closed = true;

    try {
      if(topicSession != null)
	topicSession.close();
      if(topicConnection != null)
	topicConnection.close();
    } catch(JMSException e) {
      LogLog.error("Error while closing JMSAppender ["+name+"].", e);
    } catch(RuntimeException e) {
      LogLog.error("Error while closing JMSAppender ["+name+"].", e);
    }
    // Help garbage collection
    topicPublisher = null;
    topicSession = null;
    topicConnection = null;
  }

/**
   * Test three parameter constructor.
   */
  public void testThreeParamConstructor() {
    Layout layout = new PatternLayout();
    SyslogAppender appender =
      new SyslogAppender(layout, "syslog.example.org", 24);
    assertEquals("daemon", appender.getFacility());
    assertEquals(false, appender.getFacilityPrinting());
    assertEquals(layout, appender.getLayout());
    assertEquals("syslog.example.org", appender.getSyslogHost());
    assertTrue(appender.requiresLayout());
  }

/**
   * Test two parameter constructor with unexpected facility.
   */
  public void testTwoParamConstructorBadFacility() {
    Layout layout = new PatternLayout();
    SyslogAppender appender = new SyslogAppender(layout, 25);
    assertEquals("user", appender.getFacility());
    assertEquals(false, appender.getFacilityPrinting());
    assertEquals(layout, appender.getLayout());
    assertNull(appender.getSyslogHost());
    assertTrue(appender.requiresLayout());
  }

/**
   * Tests that append method drops messages below threshold.
   * Can't reach isSevereAsThreshold call in SyslogAppender.append
   * since it is checked in AppenderSkeleton.doAppend.
   */
  public void testAppendBelowThreshold() {
    SyslogAppender appender = new SyslogAppender();
    appender.setThreshold(Level.ERROR);
    appender.activateOptions();

    Logger logger = Logger.getRootLogger();
    logger.addAppender(appender);
    logger.info(
      "Should not be logged by SyslogAppenderTest.testAppendBelowThreshold.");
  }

/**
   * Test default constructor.
   */
  public void testDefaultConstructor() {
    SyslogAppender appender = new SyslogAppender();
    assertEquals("user", appender.getFacility());
    assertEquals(false, appender.getFacilityPrinting());
    assertNull(appender.getLayout());
    assertNull(appender.getSyslogHost());
    assertTrue(appender.requiresLayout());
  }

/**
   * Test two parameter constructor.
   */
  public void testTwoParamConstructor() {
    Layout layout = new PatternLayout();
    SyslogAppender appender = new SyslogAppender(layout, 24);
    assertEquals("daemon", appender.getFacility());
    assertEquals(false, appender.getFacilityPrinting());
    assertEquals(layout, appender.getLayout());
    assertNull(appender.getSyslogHost());
    assertTrue(appender.requiresLayout());
  }

/**
   * Tests that append method drops messages below threshold.
   */
  public void testAppendNoHost() {
    SyslogAppender appender = new SyslogAppender();
    appender.setName("foo");
    appender.setThreshold(Level.INFO);

    VectorErrorHandler errorHandler = new VectorErrorHandler();
    appender.setErrorHandler(errorHandler);
    appender.setLayout(new PatternLayout("%m%n"));
    appender.activateOptions();

    Logger logger = Logger.getRootLogger();
    logger.addAppender(appender);
    logger.info(
      "Should not be logged by SyslogAppenderTest.testAppendNoHost.");
    assertEquals(1, errorHandler.size());

    //
    //  Appender is misspelled in implementation
    //
    assertEquals(
      "No syslog host is set for SyslogAppedender named \"foo\".",
      errorHandler.getMessage(0));
  }

/**
   * Tests calling setFacility after appender has been activated.
   */
  public void testSetFacilityAfterActivation() {
    SyslogAppender appender = new SyslogAppender();
    appender.setName("foo");
    appender.setThreshold(Level.INFO);
    appender.setSyslogHost("localhost");
    appender.setFacility("user");
    appender.setLayout(new PatternLayout("%m%n"));

    VectorErrorHandler errorHandler = new VectorErrorHandler();
    appender.setErrorHandler(errorHandler);
    appender.activateOptions();
    appender.setFacility("kern");
    assertEquals("kern", appender.getFacility());
  }

/**
 * Tests that syslog packets do not exceed 1024 bytes.
 * See bug 42087.
 * @throws Exception if exception during test.
 */
public void testBigPackets() throws Exception {
    DatagramSocket ds = new DatagramSocket();
    ds.setSoTimeout(2000);

  SyslogAppender appender = new SyslogAppender();
  appender.setSyslogHost("localhost:" + ds.getLocalPort());
  appender.setName("name");
  appender.setHeader(false);
  PatternLayout pl = new PatternLayout("%m");
  appender.setLayout(pl);
  appender.activateOptions();

  Logger l = Logger.getRootLogger();
  l.addAppender(appender);
  StringBuffer msgbuf = new StringBuffer();
  while(msgbuf.length() < 8000) {
      msgbuf.append("0123456789");
  }
  String msg = msgbuf.toString();
  l.info(msg);
  appender.close();
  String[] s = new String[8];
  byte[] buf = new byte[1200];
  for(int i = 0; i < 8; i++) {
      DatagramPacket p = new DatagramPacket(buf, 0, buf.length);
      ds.receive(p);
      assertTrue(p.getLength() <= 1024);
      s[i] = new String(p.getData(), 0, p.getLength());
  }
  ds.close();
  StringBuffer rcvbuf = new StringBuffer(s[0]);
  rcvbuf.delete(0, 4);
  for(int i = 1; i < 8; i++) {
      rcvbuf.setLength(rcvbuf.length() - 3);
      rcvbuf.append(s[i].substring(s[i].indexOf("...") + 3));
  }
  assertEquals(msg.length(), rcvbuf.length());
  assertEquals(msg, rcvbuf.toString());
}

/**
   * Tests append method under normal conditions.
   */
  public void testAppend() {
    SyslogAppender appender = new SyslogAppender();
    appender.setName("foo");
    appender.setThreshold(Level.INFO);
    appender.setSyslogHost("localhost");
    appender.setFacility("user");
    appender.setLayout(new PatternLayout("%m%n"));

    VectorErrorHandler errorHandler = new VectorErrorHandler();
    appender.setErrorHandler(errorHandler);
    appender.activateOptions();

    //
    //  wrap SyslogAppender with an Async since appender may
    //    hang if syslogd is not accepting network messages
    //
    AsyncAppender asyncAppender = new AsyncAppender();
    asyncAppender.addAppender(appender);
    asyncAppender.activateOptions();

    Logger logger = Logger.getRootLogger();
    logger.addAppender(asyncAppender);

    Exception e =
      new Exception("Expected exception from SyslogAppenderTest.testAppend");
    logger.info(
      "Expected message from log4j unit test SyslogAppenderTest.testAppend.", e);
    assertEquals(0, errorHandler.size());
  }

/**
 * Tests that any header or footer in layout is sent.
 * @throws Exception if exception during test.
 */
public void testLayoutHeader() throws Exception {
    DatagramSocket ds = new DatagramSocket();
    ds.setSoTimeout(2000);

  SyslogAppender appender = new SyslogAppender();
  appender.setSyslogHost("localhost:" + ds.getLocalPort());
  appender.setName("name");
  appender.setHeader(false);
  HTMLLayout pl = new HTMLLayout();
  appender.setLayout(pl);
  appender.activateOptions();

  Logger l = Logger.getRootLogger();
  l.addAppender(appender);
  l.info("Hello, World");
  appender.close();
  String[] s = new String[3];
  byte[] buf = new byte[1000];
  for(int i = 0; i < 3; i++) {
      DatagramPacket p = new DatagramPacket(buf, 0, buf.length);
      ds.receive(p);
      s[i] = new String(p.getData(), 0, p.getLength());
  }
  ds.close();
  assertEquals("<14><!DOCTYPE", s[0].substring(0,13));
  assertEquals("<14></table>", s[2].substring(0,12));
}

void connect(InetAddress address, int port) {
    if(this.address == null)
      return;
    try {
      // First, close the previous connection if any.
      cleanUp();
      oos = new ObjectOutputStream(new Socket(address, port).getOutputStream());
    } catch(IOException e) {
      if (e instanceof InterruptedIOException) {
          Thread.currentThread().interrupt();
      }
      String msg = "Could not connect to remote log4j server at ["
	+address.getHostName()+"].";
      if(reconnectionDelay > 0) {
        msg += " We will try again later.";
	fireConnector(); // fire the connector thread
      } else {
          msg += " We are not retrying.";
          errorHandler.error(msg, e, ErrorCode.GENERIC_FAILURE);
      } 
      LogLog.error(msg);
    }
  }

/**
   * Close this appender.  
   *
   * <p>This will mark the appender as closed and call then {@link
   * #cleanUp} method.
   * */
  synchronized public void close() {
    if(closed)
      return;

    this.closed = true;
    if (advertiseViaMulticastDNS) {
      zeroConf.unadvertise();
    }

    cleanUp();
  }

private static String[] log(final boolean header,
                            final String msg,
                            final Exception ex,
                            final int packets) throws Exception {
    DatagramSocket ds = new DatagramSocket();
    ds.setSoTimeout(2000);

  SyslogAppender appender = new SyslogAppender();
  appender.setSyslogHost("localhost:" + ds.getLocalPort());
  appender.setName("name");
  appender.setHeader(header);
  PatternLayout pl = new PatternLayout("%m");
  appender.setLayout(pl);
  appender.activateOptions();

  Logger l = Logger.getRootLogger();
  l.addAppender(appender);
  if (ex == null) {
    l.info(msg);
  } else {
    l.error(msg, ex);
  }
  appender.close();
  String[] retval = new String[packets];
  byte[] buf = new byte[1000];
  for(int i = 0; i < packets; i++) {
      DatagramPacket p = new DatagramPacket(buf, 0, buf.length);
      ds.receive(p);
      retval[i] = new String(p.getData(), 0, p.getLength());
  }
  ds.close();
  return retval;
}  
}
