/* Generated By:JJTree: Do not edit this line. ASTConstructorDeclaration.java */

package net.sourceforge.pmd.ast;

import java.util.Iterator;
import java.util.List;
import java.util.Map;

import net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod.ConstructorHolder;
import net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod.ConstructorInvocation;

public class ASTConstructorDeclaration extends AccessNode {
    public ASTConstructorDeclaration(int id) {
        super(id);
    }

    public ASTConstructorDeclaration(JavaParser p, int id) {
        super(p, id);
    }

    public ASTFormalParameters getParameters() {
        return (ASTFormalParameters) (jjtGetChild(0) instanceof ASTFormalParameters?jjtGetChild(0):jjtGetChild(1));
    }

    public int getParameterCount() {
        return getParameters().getParameterCount();
    }


    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(JavaParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    private boolean containsComment;

    public boolean containsComment() {
        return this.containsComment;
    }

    public void setContainsComment() {
        this.containsComment = true;
    }

    public void dump(String prefix) {
        System.out.println(collectDumpedModifiers(prefix));
        dumpChildren(prefix);
    }

	/**
	 * Constructor map should contain a key for each private constructor, and
	 * maps to a List which contains all called constructors of that key.
	 * marks dangerous if call dangerous private constructor
	 * we ignore all non-private constructors here.  That is, the map passed in
	 * should not contain any non-private constructors.
	 * we return boolean in order to limit the number of passes through this method
	 * but it seems as if we can forgo that and just process it till its done.
	 */
	private boolean evaluateDangerOfConstructors2(Map classConstructorMap) {
	    boolean found = false;//triggers on danger state change
	    //check each constructor in the class
	    for (Iterator constIter = classConstructorMap.keySet().iterator(); constIter.hasNext();) {
	        ConstructorHolder ch = (ConstructorHolder) constIter.next();
	        ConstructorInvocation calledC = ch.getCalledConstructor();
	        if (calledC == null || ch.isDangerous()) {
	            continue;
	        }
	        //if its not dangerous then evaluate if it should be
	        //if it calls dangerous constructor mark it as dangerous
	        int cCount = calledC.getArgumentCount();
	        for (Iterator innerConstIter = classConstructorMap.keySet().iterator(); innerConstIter.hasNext() && !ch.isDangerous();) { //forget skipping self because that introduces another check for each, but only 1 hit
	            ConstructorHolder h2 = (ConstructorHolder) innerConstIter.next();
	            if (h2.isDangerous()) {
	                int matchConstArgCount = h2.getASTConstructorDeclaration().getParameterCount();
	                if (matchConstArgCount == cCount) {
	                    ch.setDangerous(true);
	                    found = true;
	                    //System.out.println("evaluateDangerOfConstructors2 setting dangerous constructor with " + ch.getASTConstructorDeclaration().getParameterCount() + " params");
	                }
	            }
	        }
	    }
	    return found;
	}

	public Object visit(ASTMethodDeclaration node, Object data) {
	    final ASTFormalParameters params = (ASTFormalParameters) node.getFirstChildOfType(ASTFormalParameters.class);
	    ASTFormalParameter[] arrs = getArrays(params);
	    if (arrs != null) {
	        checkAll(data, arrs, node.findChildrenOfType(ASTBlockStatement.class));
	    }
	    return data;
	}

	/**
	 * Checks if the variable designed in parameter is written to a field (not local variable) in the statements.
	 */
	private boolean checkForDirectAssignment(Object ctx, final ASTFormalParameter parameter, final List bs) {
	    final ASTVariableDeclaratorId vid = (ASTVariableDeclaratorId) parameter.getFirstChildOfType(ASTVariableDeclaratorId.class);
	    final String varName = vid.getImage();
	    for (Iterator it = bs.iterator(); it.hasNext();) {
	        final ASTBlockStatement b = (ASTBlockStatement) it.next();
	        if (b.containsChildOfType(ASTAssignmentOperator.class)) {
	            final ASTStatementExpression se = (ASTStatementExpression) b.getFirstChildOfType(ASTStatementExpression.class);
	            if (se == null || !(se.jjtGetChild(0) instanceof ASTPrimaryExpression)) {
	                continue;
	            }
	            ASTPrimaryExpression pe = (ASTPrimaryExpression) se.jjtGetChild(0);
	            String assignedVar = getFirstNameImage(pe);
	            if (assignedVar == null) {
	                ASTPrimarySuffix suffix = (ASTPrimarySuffix) se.getFirstChildOfType(ASTPrimarySuffix.class);
	                if (suffix == null) {
	                    continue;
	                }
	                assignedVar = suffix.getImage();
	            }
	
	            SimpleNode n = (ASTMethodDeclaration) pe.getFirstParentOfType(ASTMethodDeclaration.class);
	            if (n == null) {
					n = (ASTConstructorDeclaration) pe.getFirstParentOfType(ASTConstructorDeclaration.class);
					if (n == null) {
						continue;
					}
				}
	            if (!isLocalVariable(assignedVar, n)) {
	                // TODO could this be more clumsy?  We really
	                // need to build out the PMD internal framework more
	                // to support simply queries like "isAssignedTo()" or something
	                if (se.jjtGetNumChildren() < 3) {
	                    continue;
	                }
	                ASTExpression e = (ASTExpression) se.jjtGetChild(2);
	                if (e.findChildrenOfType(ASTEqualityExpression.class).size() > 0) {
	                    continue;
	                }
	                String val = getFirstNameImage(e);
	                if (val == null) {
	                    ASTPrimarySuffix foo = (ASTPrimarySuffix) se.getFirstChildOfType(ASTPrimarySuffix.class);
	                    if (foo == null) {
	                        continue;
	                    }
	                    val = foo.getImage();
	                }
	                if (val == null) {
	                    continue;
	                }
	                ASTPrimarySuffix foo = (ASTPrimarySuffix) se.getFirstChildOfType(ASTPrimarySuffix.class);
	                if (foo != null && foo.isArrayDereference()) {
	                    continue;
	                }
	
	                if (val.equals(varName)) {
	                    SimpleNode md = (ASTMethodDeclaration) parameter.getFirstParentOfType(ASTMethodDeclaration.class);
	                    if (md == null) {
	                    	md = (ASTConstructorDeclaration) pe.getFirstParentOfType(ASTConstructorDeclaration.class);
	    				}
	                    if (!isLocalVariable(varName, md)) {
	                        addViolation(ctx, parameter, varName);
	                    }
	                }
	            }
	        }
	    }
	    return false;
	}

	public Object visit(ASTConstructorDeclaration node, Object data) {
	    ASTFormalParameter[] arrs = getArrays(node.getParameters());
	    if (arrs != null) {
	        //TODO check if one of these arrays is stored in a non local variable
	        List bs = node.findChildrenOfType(ASTBlockStatement.class);
	        checkAll(data, arrs, bs);
	    }
	    return data;
	}

}
