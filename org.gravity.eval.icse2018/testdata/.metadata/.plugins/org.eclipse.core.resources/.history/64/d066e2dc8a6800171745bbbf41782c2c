/*
Copyright (C) 2003 Morten O. Alver

All programs in this directory and
subdirectories are published under the GNU General Public License as
described below.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA

Further information about the GNU GPL is available at:
http://www.gnu.org/copyleft/gpl.ja.html

*/

package net.sf.jabref;

import java.util.*;

import net.sf.jabref.collab.EntryAddChange;
import net.sf.jabref.collab.EntryChange;
import net.sf.jabref.collab.EntryDeleteChange;

public class EntrySorter implements DatabaseChangeListener {

    //TreeSet set;
    final ArrayList<BibtexEntry> set;
    Comparator<BibtexEntry> comp;
    String[] idArray;
    BibtexEntry[] entryArray;
    //static BibtexEntry[] DUMMY = new BibtexEntry[0];
    private boolean outdated = false;
    private boolean changed = false;

    public EntrySorter(Map<String, BibtexEntry> entries, Comparator<BibtexEntry> comp) {
	    //set = new TreeSet(comp);
        set = new ArrayList<BibtexEntry>();
        this.comp = comp;
        Set<String> keySet = entries.keySet();
	    if (keySet != null) {
    	    Iterator<String> i = keySet.iterator();
    	    while (i.hasNext()) {
    		    set.add(entries.get(i.next()));
            }
            //Collections.sort(set, comp);
            changed = true;
            index();
	    }
    }

    public void index() {

        /*  Old version, from when set was a TreeSet.

        // The boolean "changing" is true in the situation that an entry is about to change,
        // and has temporarily been removed from the entry set in this sorter. So, if we index
        // now, we will cause exceptions other places because one entry has been left out of
        // the indexed array. Simply waiting foth this to change can lead to deadlocks,
        // so we have no other choice than to return without indexing.
        if (changing)
            return;
        */


        synchronized(set) {

            // Resort if necessary:
            if (changed) {
                Collections.sort(set, comp);
                changed = false;
            }

            // Create an array of IDs for quick access, since getIdAt() is called by
            // getValueAt() in EntryTableModel, which *has* to be efficient.

	        int count = set.size();
            idArray = new String[count];
            entryArray = new BibtexEntry[count];
	        int piv = 0;
	        for (Iterator<BibtexEntry> i=set.iterator(); i.hasNext();) {
	            //        for (int i=0; i<idArray.length; i++) {
    	        BibtexEntry entry = i.next();
    	        idArray[piv] = entry.getId();
    	        entryArray[piv] = entry;
    	        piv++;
            }
        }
    }

    public boolean isOutdated() {
	return outdated;
    }

    public String getIdAt(int pos) {
        synchronized(set) {
            return idArray[pos];
        }
	//return ((BibtexEntry)(entryArray[pos])).getId();
    }

    public BibtexEntry getEntryAt(int pos) {
        synchronized(set) {
            return entryArray[pos];
        }
    }

    public int getEntryCount() {
        synchronized(set) {
	        if (entryArray != null)
	            return entryArray.length;
	        else
	        return 0;
        }
    }

    public void databaseChanged(DatabaseChangeEvent e) {
        synchronized(set) {
	        if (e.getType() == DatabaseChangeEvent.ADDED_ENTRY) {
                int pos = -Collections.binarySearch(set, e.getEntry(), comp) - 1;
                set.add(pos, e.getEntry());
                //addEntry(e.getEntry());
                //set.add(e.getEntry());
                //changed = true;
                //Collections.sort(set, comp);
            }
	        else if (e.getType() == DatabaseChangeEvent.REMOVED_ENTRY) {
	            set.remove(e.getEntry());
                changed = true;
            }
	        else if (e.getType() == DatabaseChangeEvent.CHANGED_ENTRY) {
                // Entry changed. Resort list:
                //Collections.sort(set, comp);
                int pos = Collections.binarySearch(set, e.getEntry(), comp);
                int posOld = set.indexOf(e.getEntry());
                if (pos < 0) {
                    set.remove(posOld);
                    set.add(-pos-1, e.getEntry());
                }
                //changed = true;
            }

    	}

    }

	private void scanEntries(EntrySorter mem, EntrySorter tmp, EntrySorter disk) {
	
	    // Create pointers that are incremented as the entries of each base are used in
	    // successive order from the beginning. Entries "further down" in the "disk" base
	    // can also be matched.
	    int piv1 = 0, piv2 = 0;
	
	    // Create a HashSet where we can put references to entry numbers in the "disk"
	    // database that we have matched. This is to avoid matching them twice.
	    HashSet<String> used = new HashSet<String>(disk.getEntryCount());
	    HashSet<Integer> notMatched = new HashSet<Integer>(tmp.getEntryCount());
	
	    // Loop through the entries of the "tmp" database, looking for exact matches in the "disk" one.
	    // We must finish scanning for exact matches before looking for near matches, to avoid an exact
	    // match being "stolen" from another entry.
	    mainLoop: for (piv1=0; piv1<tmp.getEntryCount(); piv1++) {
	
	        // First check if the similarly placed entry in the other base matches exactly.
	        double comp = -1;
	        // (if there are not any entries left in the "disk" database, comp will stay at -1,
	        // and this entry will be marked as nonmatched).
	        if (!used.contains(""+piv2) && (piv2<disk.getEntryCount())) {
	            comp = DuplicateCheck.compareEntriesStrictly(tmp.getEntryAt(piv1), disk.getEntryAt(piv2));
	        }
	        if (comp > 1) {
	            used.add(""+piv2);
	            piv2++;
	            continue mainLoop;
	        }
	
	        // No? Then check if another entry matches exactly.
	        if (piv2 < disk.getEntryCount()-1) {
	            for (int i = piv2+1; i < disk.getEntryCount(); i++) {
	                if (!used.contains(""+i))
	                    comp = DuplicateCheck.compareEntriesStrictly(tmp.getEntryAt(piv1), disk.getEntryAt(i));
	                else
	                    comp = -1;
	
	                if (comp > 1) {
	                    used.add("" + i);
	                    continue mainLoop;
	                }
	            }
	        }
	
	        // No? Add this entry to the list of nonmatched entries.
	        notMatched.add(new Integer(piv1));
	    }
	
	
	    // Now we've found all exact matches, look through the remaining entries, looking
	    // for close matches.
	    if (notMatched.size() > 0) {
	
	        for (Iterator<Integer> it=notMatched.iterator(); it.hasNext();) {
	
	            Integer integ = it.next();
	            piv1 = integ.intValue();
	
	
	            // These two variables will keep track of which entry most closely matches the
	            // one we're looking at, in case none matches completely.
	            int bestMatchI = -1;
	            double bestMatch = 0;
	            double comp = -1;
	
	            if (piv2 < disk.getEntryCount()-1) {
	                for (int i = piv2; i < disk.getEntryCount(); i++) {
	                    if (!used.contains(""+i)) {
	                        comp = DuplicateCheck.compareEntriesStrictly(tmp.getEntryAt(piv1),
	                        disk.getEntryAt(i));
	                    }
	                    else
	                        comp = -1;
	
	                    if (comp > bestMatch) {
	                        bestMatch = comp;
	                        bestMatchI = i;
	                    }
	                }
	            }
	
	            if (bestMatch > MATCH_THRESHOLD) {
	                used.add(""+bestMatchI);
	                it.remove();
	
	                EntryChange ec = new EntryChange(bestFit(tmp, mem, piv1), tmp.getEntryAt(piv1),
	                disk.getEntryAt(bestMatchI));
	                changes.add(ec);
	
	                // Create an undo edit to represent this change:
	                //NamedCompound ce = new NamedCompound("Modified entry");
	                //ce.addEdit(new UndoableRemoveEntry(inMem, disk.getEntryAt(bestMatchI), panel));
	                //ce.addEdit(new UndoableInsertEntry(inMem, tmp.getEntryAt(piv1), panel));
	                //ce.end();
	                //changes.add(ce);
	
	                //System.out.println("Possible match for entry:");
	                //System.out.println("----------------------------------------------");
	
	            }
	            else {
	                EntryDeleteChange ec = new EntryDeleteChange(bestFit(tmp, mem, piv1), tmp.getEntryAt(piv1));
	                changes.add(ec);
	      /*NamedCompound ce = new NamedCompound("Removed entry");
	      ce.addEdit(new UndoableInsertEntry(inMem, tmp.getEntryAt(piv1), panel));
	      ce.end();
	      changes.add(ce);*/
	
	            }
	
	        }
	
	    }
	
	    // Finally, look if there are still untouched entries in the disk database. These
	    // mayhave been added.
	    if (used.size() < disk.getEntryCount()) {
	        for (int i=0; i<disk.getEntryCount(); i++) {
	            if (!used.contains(""+i)) {
	
	                // See if there is an identical dupe in the mem database:
	                boolean hasAlready = false;
	                for (int j = 0; j < mem.getEntryCount(); j++) {
	                    if (DuplicateCheck.compareEntriesStrictly(mem.getEntryAt(j),
	                        disk.getEntryAt(i)) >= 1) {
	                        hasAlready = true;
	                        break;
	                    }
	                }
	                if (!hasAlready) {
	                    EntryAddChange ec = new EntryAddChange(disk.getEntryAt(i));
	                    changes.add(ec);
	                }
	      /*NamedCompound ce = new NamedCompound("Added entry");
	      ce.addEdit(new UndoableRemoveEntry(inMem, disk.getEntryAt(i), panel));
	      ce.end();
	      changes.add(ce);*/
	            }
	        }
	        //System.out.println("Suspected new entries in file: "+(disk.getEntryCount()-used.size()));
	    }
	}
}
