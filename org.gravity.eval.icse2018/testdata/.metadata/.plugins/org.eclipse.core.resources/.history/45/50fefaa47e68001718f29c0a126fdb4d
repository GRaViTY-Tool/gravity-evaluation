/***************************************************************************
                           GanttTask.java  -  description
                             -------------------
    begin                : dec 2002
    copyright            : (C) 2002 by Thomas Alexandre
    email                : alexthomas(at)ganttproject.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

package net.sourceforge.ganttproject;

import net.sourceforge.ganttproject.resource.HumanResource;
import net.sourceforge.ganttproject.roles.Role;
import net.sourceforge.ganttproject.task.TaskImpl;
import net.sourceforge.ganttproject.task.TaskManager;
import net.sourceforge.ganttproject.task.TaskMutator;
import net.sourceforge.ganttproject.task.dependency.TaskDependency;
import net.sourceforge.ganttproject.time.TimeUnit;
import net.sourceforge.ganttproject.time.TimeUnitManager;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Serializable;
import java.util.Iterator;
import java.util.Vector;

import javax.swing.tree.DefaultMutableTreeNode;

/**
 * Class that generate a task
 */

public class GanttTask extends TaskImpl

    implements Serializable {

  public static int LOW = 0;

  public static int NORMAL = 1;

  public static int HIGHT = 2;


/////////////////////////////////////////////////////////////////////////////////

  /** Constructor */

  public GanttTask(String name, GanttCalendar start, long length, TaskManager taskManager) {
      super(taskManager);
      TimeUnitManager timeManager = getTimeUnitManager();
      TaskMutator mutator = createMutator();
      mutator.setName(name);
      mutator.setStart(start);
      mutator.setDuration(taskManager.createLength(timeManager.getTimeUnit(TimeUnit.DAY), length));
      mutator.commit();
      enableEvents(true);
  }


    private GanttTask(GanttTask copy) {
        super(copy);
//        for (int i = 0; i < getPredecessorsOld().size(); i++) {
//          GanttTaskRelationship tempRel = (GanttTaskRelationship) ( (
//              GanttTaskRelationship) getPredecessorsOld().get(i)).clone();
//          addPredecessor(tempRel);
//        }

//        for (int i = 0; i < successors.size(); i++) {
//          GanttTaskRelationship tempRel = (GanttTaskRelationship) ( (
//              GanttTaskRelationship) successors.get(i)).clone();
//          addSuccessor(tempRel);
//        }
        enableEvents(true);

    }


  /**
   * @return a clone of the Task
   */
  public GanttTask Clone() {
      return new GanttTask(this);
  }

  /** Return the name. */
  public String toString() {
    return getName();
    //return getName();
  }

  /** Return the shape of the task */


  /** Return the duration */

  public int getLength() {

    return (int) getDuration().getLength();

  }


  /** Change the duration */
  public void setLength(int l) {
      TaskMutator mutator = createMutator();
      mutator.setDuration(getManager().createLength(getDuration().getTimeUnit(), l));
      mutator.commit();
  }



  /**whether the time relationship between this task and other has been checked. property will be used in scheduling check*/

  private boolean checked = false;


  public Vector getPredecessorsOld() {
      TaskDependency[] deps = getDependenciesAsDependant().toArray();
      Vector result = new Vector(deps.length);
      for (int i=0; i<deps.length; i++) {
          TaskDependency next = deps[i];
          GanttTaskRelationship rel = new GanttTaskRelationship(next.getDependee().getTaskID(), getTaskID(), next.getConstraint().getID(), getManager());
          result.add(rel);
      }
    return result;
  }

    public Vector getSuccessorsOld() {
        TaskDependency[] deps = getDependenciesAsDependee().toArray();
        Vector result = new Vector(deps.length);
        for (int i=0; i<deps.length; i++) {
            TaskDependency next = deps[i];
            GanttTaskRelationship rel = new GanttTaskRelationship(getTaskID(), next.getDependant().getTaskID(), next.getConstraint().getID(), getManager());
            result.add(rel);
        }
        return result;
    }


  /** Unlink the task from all relationship */
  public void unlink () {
      getDependencies().clear();

  }
  
  /**return true if the realtionship between this task and others has been checked*/

  public boolean isChecked() {

    return checked;

  }

  /**set the checked state of task: true if the relationship has been check. or else, false*/

  public void setChecked(boolean checked) {

    this.checked = checked;

  }

  /**
       *set the task ID. the uniquness of ID should be check before using this method
   * @param taskID
   */
  public void setTaskID(int taskID) {
      setTaskIDHack(taskID);
  }


/** Write all tasks. */
	private void writeTasks(OutputStreamWriter out) throws IOException 
	{
//		parse all tasks	
	    for(Iterator it=lot.iterator(); it.hasNext();)
		{
			DefaultMutableTreeNode node = (DefaultMutableTreeNode) it.next();
			if(!node.isRoot())
			{
				GanttTask task = (GanttTask)(node.getUserObject());
				
				//ID
				if(csvOptions.bExportTaskID)
					out.write(correctField(""+task.getTaskID())+
							(bFixedSize?"":csvOptions.sSeparatedChar));
					
				//Name
				if(csvOptions.bExportTaskName)
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar)+
							correctField(getName(node, task))+
							(bFixedSize?"":csvOptions.sSeparatedTextChar+
							csvOptions.sSeparatedChar));
				
				//Start Date
				if(csvOptions.bExportTaskStartDate)
					out.write(correctField(task.getStart().toString())+
							(bFixedSize?"":csvOptions.sSeparatedChar));
				
				//End Date
				if(csvOptions.bExportTaskEndDate)
					out.write(correctField(task.getEnd().toString())+
							(bFixedSize?"":csvOptions.sSeparatedChar));
				
				//Duration
				if(csvOptions.bExportTaskDuration)
					out.write(correctField(""+task.getLength())+
							(bFixedSize?"":csvOptions.sSeparatedChar));
				
				//Percent complete
				if(csvOptions.bExportTaskPercent)
					out.write(correctField(""+task.getCompletionPercentage())+
							(bFixedSize?"":csvOptions.sSeparatedChar));				

				//Web Link
				if(csvOptions.bExportTaskWebLink)
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar)+
							correctField(getWebLink(task))+
							(bFixedSize?"":csvOptions.sSeparatedTextChar+
							csvOptions.sSeparatedChar));				
				
				//associated resources
				if(csvOptions.bExportTaskResources) {
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar));					
					out.write(correctField(getAssignments(task)));					
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar+
							csvOptions.sSeparatedChar));
				}
				
				//Notes
				if(csvOptions.bExportTaskNotes)
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar)+
							correctField(task.getNotes())+
							(bFixedSize?"":csvOptions.sSeparatedTextChar+
							csvOptions.sSeparatedChar));
				
				out.write("\n");
			}
		}	    
	} //end of write tasks


/**set the maximum size for all strings. */
void getMaxSize()
{
	iMaxSize = 0;
	for(Iterator it=lot.iterator(); it.hasNext();)
    {
		DefaultMutableTreeNode node = (DefaultMutableTreeNode) it.next();
		if(!node.isRoot())
		{
			GanttTask task = (GanttTask)(node.getUserObject());

			if(csvOptions.bExportTaskID){
				String s=""+task.getTaskID();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskName){
				String s=""+getName(node, task);
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskStartDate){
				String s=""+task.getStart();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskEndDate){
				String s=""+task.getEnd();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskDuration){
				String s=""+task.getLength();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskPercent){
				String s=""+task.getCompletionPercentage();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskWebLink){
				String s=""+getWebLink(task);
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskResources){
				String s=""+getAssignments(task);
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskNotes){
				String s=""+task.getNotes();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}	
			
		}
    }
	
	//parse all resources
	for (int i = 0; i < resources.size(); i++)
	{
	   	HumanResource p = (HumanResource) resources.get(i);
	   	
	   	if(csvOptions.bExportResourceID){
			String s=""+p.getId();
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	   	if(csvOptions.bExportResourceName){
			String s=""+p.getName();
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	   	if(csvOptions.bExportResourceMail){
			String s=""+p.getMail();
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	   	if(csvOptions.bExportResourcePhone){
			String s=""+p.getPhone();
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	   	if(csvOptions.bExportResourceRole){
	   		Role role = p.getRole();
	        String sRoleID = "0";
	        if(role != null) sRoleID = role.getPersistentID();
			String s=""+sRoleID;
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	}
	
} //get maxIndentation end


/**@return the link of the task. */
private String getWebLink(GanttTask task)
{
	return (task.getWebLink().equals("http://")?"":task.getWebLink());
}
}
