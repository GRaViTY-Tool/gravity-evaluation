package net.sourceforge.ganttproject.task;

import net.sourceforge.ganttproject.GanttCalendar;
import net.sourceforge.ganttproject.GanttGraphicArea.Arrow;
import net.sourceforge.ganttproject.GanttGraphicArea.GanttPaintParam;
import net.sourceforge.ganttproject.GanttGraphicArea.Notes;
import net.sourceforge.ganttproject.GanttTask;
import net.sourceforge.ganttproject.GanttTaskRelationship;
import net.sourceforge.ganttproject.shape.ShapePaint;
import net.sourceforge.ganttproject.shape.ShapeConstants;
import net.sourceforge.ganttproject.task.dependency.*;
import net.sourceforge.ganttproject.task.hierarchy.TaskHierarchyItem;
import net.sourceforge.ganttproject.time.TimeUnitManager;
//import net.sourceforge.ganttproject.resource.ProjectResource;

import java.util.List;
import java.util.Vector;

import javax.swing.tree.DefaultMutableTreeNode;

import java.util.ArrayList;
import java.util.Iterator;
import java.awt.*;

/**
 * Created by IntelliJ IDEA.
 * @author bard
 * Date: 31.01.2004
 */
public class TaskImpl implements Task {
    private int myID;
    private final TaskManagerImpl myManager;
    private String myName;
    private String myWebLink = new String("http://");
    private boolean isMilestone;
    private int myPriority;
    private GanttCalendar myStart;
    private GanttCalendar myEnd;
    private int myCompletionPercentage;
    private TaskLength myLength;
    private boolean isStartFixed;

	private boolean bExpand;
    
    private TimeUnitManager myTimeUnitManager;
    //private final TaskDependencyCollection myDependencies = new TaskDependencyCollectionImpl();
    private final ResourceAssignmentCollectionImpl myAssignments;
    private final TaskDependencySlice myDependencySlice;
    private final TaskDependencySlice myDependencySliceAsDependant;
    private final TaskDependencySlice myDependencySliceAsDependee;
    private boolean myEventsEnabled;
    private final TaskHierarchyItem myTaskHierarchyItem;
    private ShapePaint myShape;
    private Color myColor;
    private String myNotes;


    protected TaskImpl(TaskManager taskManager) {
        myManager = (TaskManagerImpl) taskManager;
        myID = myManager.getMaxID();
        myManager.increaseMaxID();
        myTimeUnitManager = myManager.getTimeUnitManager();
        myAssignments = new ResourceAssignmentCollectionImpl(this);
        myDependencySlice = new TaskDependencySliceImpl(this, myManager.getDependencyCollection());
        myDependencySliceAsDependant = new TaskDependencySliceAsDependant(this, myManager.getDependencyCollection());
        myDependencySliceAsDependee = new TaskDependencySliceAsDependee(this, myManager.getDependencyCollection());
        myPriority = 1;
        myTaskHierarchyItem = myManager.getHierarchyManager().createItem(this);
        isStartFixed = false;
        myNotes = "";
		bExpand = true;
        myColor=null;
    }

    protected TaskImpl(TaskImpl copy) {
        myManager = copy.myManager;
        myAssignments = copy.myAssignments.copy();
        myID = copy.myID;
        myName = copy.myName;
        myWebLink = copy.myWebLink;
        isMilestone = copy.isMilestone;
        myPriority = copy.myPriority;
        myStart = copy.myStart;
        myEnd = copy.myEnd;
        myCompletionPercentage = copy.myCompletionPercentage;
        myLength = copy.myLength;
        isStartFixed = copy.isStartFixed;
        myShape = copy.myShape;
        myColor = copy.myColor;
        myNotes = copy.myNotes;
		bExpand = copy.bExpand;
        //
        myTimeUnitManager = copy.myTimeUnitManager;
        myDependencySlice = copy.myDependencySlice;
        myDependencySliceAsDependant = copy.myDependencySliceAsDependant;
        myDependencySliceAsDependee = copy.myDependencySliceAsDependee;
        myTaskHierarchyItem = myManager.getHierarchyManager().createItem(this);
    }

    public TaskMutator createMutator() {
        return new MutatorImpl();
    }

    // main properties
    public int getTaskID() {
        return myID;
    }

    public String getName() {
        return myName;
    }
    
    public String getWebLink() {
        return myWebLink;
    }

    public boolean isMilestone() {
        return isMilestone;
    }

    public int getPriority() {
        return myPriority;
    }

    public GanttCalendar getStart() {
        return myStart;
    }

    public GanttCalendar getEnd() {
        if (myEnd==null) {
            myEnd = getStart().Clone();
            myEnd.add((int) getDuration().getLength());
        }
        return myEnd;
    }

    public TaskLength getDuration() {
        //System.err.println("[TaskImp] this="+this+" duration="+myLength+" id="+myID);
        return myLength;
    }

    public int getCompletionPercentage() {
        return myCompletionPercentage;
    }

    public boolean isStartFixed() {
        return isStartFixed;
    }

	public boolean getExpand(){
    	return bExpand;
    }

    public ShapePaint getShape() {
        return myShape==null ?
                new ShapePaint(ShapeConstants.BACKSLASH, getColor() , getColor()) :
                myShape;
    }

    public Color getColor() {
        return myColor==null ? myManager.getConfig().getDefaultColor() : myColor;
    }

    public String getNotes() {
        return myNotes;
    }

    public GanttTaskRelationship[] getPredecessors() {
        return new GanttTaskRelationship[0];  //To change body of implemented methods use Options | File Templates.
    }

    public GanttTaskRelationship[] getSuccessors() {
        return new GanttTaskRelationship[0];  //To change body of implemented methods use Options | File Templates.
    }

    public ResourceAssignment[] getAssignments() {
        return myAssignments.getAssignments();
    }

    public ResourceAssignmentCollection getAssignmentCollection() {
        return myAssignments;
    }

    //
    public Task getSupertask() {
        TaskHierarchyItem container = myTaskHierarchyItem.getContainerItem();
        return container.getTask();
    }

    public Task[] getNestedTasks() {
        TaskHierarchyItem[] nestedItems = myTaskHierarchyItem.getNestedItems();
        Task[] result = new Task[nestedItems.length];
        for (int i=0; i<nestedItems.length; i++) {
            result[i] = nestedItems[i].getTask();
        }
        return result;
    }

    public void move(Task targetSupertask) {
        TaskImpl supertaskImpl = (TaskImpl) targetSupertask;
        TaskHierarchyItem targetItem = supertaskImpl.myTaskHierarchyItem;
        myTaskHierarchyItem.delete();
        targetItem.addNestedItem(myTaskHierarchyItem);
    }

    public TaskDependencySlice getDependencies() {
        return myDependencySlice;
    }

    public TaskDependencySlice getDependenciesAsDependant() {
        return myDependencySliceAsDependant;
    }

    public TaskDependencySlice getDependenciesAsDependee() {
        return myDependencySliceAsDependee;
    }

    public TaskManager getManager() {
        return myManager;
    }

    //TODO: remove this hack. ID must never be changed
    protected void setTaskIDHack(int taskID) {
        myID = taskID;
    }

    protected TimeUnitManager getTimeUnitManager() {
        return myTimeUnitManager;
    }

    private class MutatorImpl implements TaskMutator {
        private final List myCommands = new ArrayList();
        public void commit() {
            for (int i=0; i<myCommands.size(); i++) {
                Runnable next = (Runnable) myCommands.get(i);
                next.run();
            }
            myCommands.clear();
        }

        public void setName(final String name) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setName(name);
                }
            });
        }

        public void setMilestone(final boolean milestone) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setMilestone(milestone);
                }
            });
        }

        public void setPriority(final int priority) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setPriority(priority);
                }
            });
        }

        public void setStart(final GanttCalendar start) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setStart(start);
                }
            });
        }

        public void setEnd(final GanttCalendar end) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setEnd(end);
                }
            });
        }

        public void setDuration(final TaskLength length) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setDuration(length);
                }
            });
        }

		public void setExpand(final boolean expand) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setExpand(expand);
                }
            });
        }
    
        public void setCompletionPercentage(final int percentage) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setCompletionPercentage(percentage);
                }
            });
        }

        public void setStartFixed(final boolean isFixed) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setStartFixed(isFixed);
                }
            });
        }

        public void setShape(final ShapePaint shape) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setShape(shape);
                }
            });
        }

        public void setColor(final Color color) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setColor(color);
                }
            });
        }

        public void setNotes(final String notes) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.setNotes(notes);
                }
            });
        }

        public void addNotes(final String notes) {
            myCommands.add(new Runnable() {
                public void run() {
                    TaskImpl.this.addNotes(notes);
                }
            });
        }

    }

    public void setName(String name) {

        myName = name;
    }
    public void setWebLink(String webLink) {

        myWebLink = webLink;
    }
    public void setMilestone(boolean milestone) {
        isMilestone = milestone;
    }

    public void setPriority(int priority) {
        myPriority = priority;
    }

    public void setStart(GanttCalendar start) {
        GanttCalendar oldStart = myStart==null ? null : myStart.Clone();
        myStart = start;
        if (areEventsEnabled()) {
            myManager.fireTaskScheduleChanged(this, oldStart, getEnd());
        }
    }

    public void setEnd(GanttCalendar end) {
        GanttCalendar oldFinish = myEnd==null ? null : myEnd.Clone();
        myEnd = end;
        int length = myStart.diff(end);
        myLength = getManager().createLength(myLength.getTimeUnit(), length);
        if (areEventsEnabled()) {
            myManager.fireTaskScheduleChanged(this, myStart.Clone(), oldFinish);
        }
    }

    public void setDuration(TaskLength length) {
        GanttCalendar oldFinish = myEnd==null ? null : myEnd.Clone();
        myLength = length;
        myEnd = myStart.newAdd((int) length.getLength());
        if (areEventsEnabled()) {
            myManager.fireTaskScheduleChanged(this, myStart.Clone(), oldFinish);
        }
    }

    public void setCompletionPercentage(int percentage) {
        myCompletionPercentage = percentage;
    }

    public void setStartFixed(boolean isFixed) {
        isStartFixed = isFixed;
    }

    public void setShape(ShapePaint shape) {
        myShape = shape;
    }

    public void setColor(Color color) {
        myColor = color;
    }

    public void setNotes(String notes) {
        myNotes = notes;
	}
    
    public void setExpand(boolean expand){
    	bExpand = expand;
    }

    public void addNotes(String notes) {
        myNotes += notes;
    }

    protected void enableEvents(boolean enabled) {
        myEventsEnabled = enabled;
    }

    protected boolean areEventsEnabled() {
        return myEventsEnabled;
    }

    /**
     * Allows to determine, if a special shape is defined for this task.
     * @return true, if this task has its own shape defined.
     */
    public boolean shapeDefined()
    {
      return (myShape != null);
    }

    /**
     * Allows to determine, if a special color is defined for this task.
     * @return true, if this task has its own color defined.
     */

    public boolean colorDefined() {

      return (myColor != null);

    }

	/** Paint all tasks  */
	  public void paintTasks(Graphics g) {
	      int sizex = getWidth();
	      int sizey = getHeight();
	      int headery = 45;
	      float fgra = (float) sizex / (float) getGranit(true);
	
	      g.setFont(myUIConfiguration.getChartMainFont());
	
	      //Get all task
	
	      //Probably optimised on next release
	      listOfParam.clear();
	
	      int y = 0;
	
	      for (Iterator tasks = listOfTask.iterator(); tasks.hasNext();) {
	          DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode) tasks.next();
	          GanttTask task = (GanttTask) treeNode.getUserObject();
	
	//Is the task is visible, the task could be draw
	          if (isVisible(task)) {
	              int x1 = -10, x2 = sizex + 10;
	              int e1; //ecart entre la date de debut de la tache et la date du debut du calendrier
	              int fois;
	              int type = 2;
	              y++;
	
	//difference between the start date of the task and the end
	              e1 = date.diff(task.getStart());
	
	//Calcul start and end pixel of each task
	              float fx1, fx2;
	
	              if (task.isMilestone()) {
	                  fx1 = (float) e1 * fgra *
	                          ((date.compareTo(task.getStart()) == 1) ? -1 : 1);
	                  x1 = (int) fx1;
	              } else {
	                  fx1 = (float) e1 * fgra *
	                          ((date.compareTo(task.getStart()) == 1) ? -1 : 1);
	                  fx2 = fx1 + (float) task.getLength() * fgra;
	                  x1 = (int) fx1;
	                  x2 = (int) fx2;
	              }
	
	              int percent = 0;
	
	//Meeting task
	              if (task.isMilestone()) {
	                  paintATaskBilan(g, x1, y, task);
	                  x2 = x1 + (int) fgra;
	                  type = 0;
	              }
	//A mother task
	              else if (tree.getAllChildTask(treeNode).size() != 0) {
	
	                  //Compute percent-complete
	                  tree.computePercentComplete(treeNode);
	
	                  paintATaskFather(g, x1, x2, y, task);
	                  if (drawPercent) {
	                      percent = paintAdvancement(g, x1, x2, y, task.getCompletionPercentage(), task.getShape(),
	                              task.getColor(), true);
	                  }
	                  type = 1;
	              }
	//A normal task
	              else {
	                  paintATaskChild(g, x1, x2, y, task);
	                  if (drawPercent) {
	
	                      percent = paintAdvancement(g, x1, x2, y, task.getCompletionPercentage(), task.getShape(),
	                              task.getColor(), false);
	                  }
	                  type = 2;
	              }
	
	//Add parameters on the array
	              listOfParam.add(new GanttPaintParam(task.getName(), task.getTaskID(),
	                      x1, x2, percent, y, type));
	          }
	      }
	
	  }

	/** Detect if the position of the mouse is on a special place (return -1 if nothing or the numer of the task*/
	  public int detectPosition(int mx, int my, boolean all) {
	    for (int i = 0; i < listOfParam.size(); i++) {
	      GanttPaintParam param = (GanttPaintParam) listOfParam.get(i);
	      if ( ( (param.type == 2 || param.type == 0) && !all) || all) {
	        int y = param.y * 20 + 27 - margY;
	        int x1 = param.x1;
	        int x2 = param.x2;
	        int x3 = param.x3;
	
	        if ( (my >= y && my <= y + 12)) {
	          //The end of the task
	          if (mx >= x2 /*-2*/ && mx <= x2 + 2) {
	            typeSeletion = 0;
	            setTaskToMove(i);
	            GanttCalendar enddate = taskToMove.getEnd().newAdd( -1);
	            notes = new Notes(enddate.toString(), mx, y - 30);
	            arrow.setDraw(false);
	            return i;
	          }
	          //the start of the task
	          else if (mx >= x1 - 2 && mx <= x1 /*+2*/) {
	            typeSeletion = 1;
	            setTaskToMove(i);
	            notes = new Notes(taskToMove.getStart().toString(), mx, y - 30);
	            arrow.setDraw(false);
				      return i;
	          }
	          //the percent length
	          else if (mx >= x3 - 2 && mx <= x3 + 2) {
	            typeSeletion = 3;
	            setTaskToMove(i);
	            notes = new Notes("  " + taskToMove.getCompletionPercentage() + "%", mx, y - 30);
	            arrow.setDraw(false);
	            return i;
	          }
	
	          //A depend
	          else if (mx > x1 + 3 && mx < x2 - 3) {
	            typeSeletion = 2;
	
	            if (param.type != 0) {
	              arrow = new Arrow(mx, y + 6, mx, y + 6);
	              notes.setDraw(false);
	            }
	            else {
	              setTaskToMove(i);
	              notes = new Notes(taskToMove.getStart().toString(), mx, y - 30);
	            }
	
	            return i;
	          }
	        }
	      }
	    }
	    return -1;
	  }

	/** Draw a normal task */
	  public void paintATaskChild(Graphics g, int x1, int x2, int y, Task task) {
	    int d = y;
	    y = y * 20 + 27 - margY;
	
	    if (y < 20 || y > getHeight()) {
	      return; //Not draw if the task is not on the area
	    }
	    if ( (x1 > getWidth() && x2 > getWidth()) || (x1 < 0 && x2 < 0)) {
	      return;
	    }
	
	    //Blue rectangle
	      Color c = ((GanttTask)task).colorDefined() ? task.getColor() :myUIConfiguration.getTaskColor();
	    g.setColor(c);
	    g.fillRect(x1, y, (x2 - x1 - 1), 12);
	
	    //Draw nice border
	    //if(draw3dBorders)
	    {	
	    	if (drag == d - 1) {
	    		g.setColor(arrayColor[0]);
	    	}
	    	else {
	    		g.setColor(Color.black);
	    	}
	    	g.drawRect(x1, y, x2 - x1 - 1, 12);
	    	
	    	//AT
	    	//This code print a gray border around the task
	    	//BTW I've comment it for several reason
	    	//- It' increase the time of rendering
	    	//- when printing the char, this border isn't good
	    	//- for the rendering, it's only beautiful with the default color, but not with another one
	    	//- finally I found it nicer now :)
	    	/*g.setColor(arrayColor[7]);
	    	g.drawLine(x1 + 1, y + 1, (x2 - 1) - 1, y + 1);
	    	g.drawLine(x1 + 1, y + 1, x1 + 1, y + 11);
	    	
	    	g.setColor(arrayColor[8]);
	    	g.drawLine(x1 + 2, y + 11, (x2 - 1) - 2, y + 11);
	    	g.drawLine(x2 - 2, y + 2, x2 - 2, y + 11);*/
	  	}
	    
		//Draw the resource list after the task
		paintResources (x2+40, y+10, task, g);
	
	  }

	/** Draw the arrows for depends */
	  public void paintDepend(Graphics g) {
	  
	  
	  	//for paint triangles
	    int xPoints[] = new int[3];
	    int yPoints[] = new int[3];
		
	  
	  	//Set the color to black
	     g.setColor(Color.black);
		
		//Parsing all tasks
		for(Iterator tasks=listOfTask.iterator(); tasks.hasNext(); ) {
			//Get the task
			GanttTask task = (GanttTask)(((DefaultMutableTreeNode)tasks.next()).getUserObject());
			//Only if the task is visible
			if(isVisible(task)) {
				//Get all sucessors for the task
				Vector successors = task.getSuccessorsOld();
				//Parsing the sucessors
				for(Iterator suc=successors.iterator(); suc.hasNext();){
					//Get the relashionship
					GanttTaskRelationship relationship = (GanttTaskRelationship)suc.next();
					//Get the second task
					Task task2 = relationship.getSuccessorTask();
					//Only if the second task is visible
					if (this.isVisible(task2)) {
						//Get the start index and end index for param values
	          int index1 = this.indexOf(listOfParam, task.getTaskID());
	          int index2 = this.indexOf(listOfParam, task2.getTaskID());
						
						//System.out.println(task+"  "+task2+"  "+index1+" "+index2);
						try{
						//Y coords
						int yt1 = ( (GanttPaintParam) listOfParam.get(index1)).y;
	          int yt2 = ( (GanttPaintParam) listOfParam.get(index2)).y;
						yt1 = yt1 * 20 + 32 - margY;
						yt2 = yt2 * 20 + 32 - margY;
						
						//Start-Start relashion
						if(relationship.getRelationshipType()==GanttTaskRelationship.SS) {
							//Get x coord
							int x1t1 = ( (GanttPaintParam) listOfParam.get(index1)).x1;
							int x1t2 = ( (GanttPaintParam) listOfParam.get(index2)).x1;
							
							int xa=(x1t1<x1t2)?x1t1-7:x1t2-7;
							
							//Draw Lines
							g.drawLine(x1t1, yt1, xa, yt1);
				            g.drawLine(xa, yt1, xa, yt2);
							g.drawLine(xa, yt2, x1t2, yt2);
							
							//Traiangle for task 1
							/*x1t1--;
							xPoints[0] = x1t1;
	              			xPoints[1] = x1t1 - 3;
				            xPoints[2] = x1t1 - 3;
							yPoints[0] = yt1;
							yPoints[1] = yt1 - 4;
							yPoints[2] = yt1 + 4;
							g.fillPolygon(xPoints, yPoints, 3);*/
							//Traiangle for task 2
							x1t2--;
							xPoints[0] = x1t2;
	              			xPoints[1] = x1t2 - 3;
				            xPoints[2] = x1t2 - 3;
							yPoints[0] = yt2;
							yPoints[1] = yt2 - 4;
							yPoints[2] = yt2 + 4;
							g.fillPolygon(xPoints, yPoints, 3);
						
						//Finish-Start relashion
						} else if(relationship.getRelationshipType()==GanttTaskRelationship.FS) {
							//Get x coord
							int x2t1 = ( (GanttPaintParam) listOfParam.get(index1)).x2;
							int x1t2 = ( (GanttPaintParam) listOfParam.get(index2)).x1;
							
							x1t2 += 2;
							
							xPoints[0] = x1t2;
	              			xPoints[1] = x1t2 + 3;
				            xPoints[2] = x1t2 - 3;
	
				            if (yt1 > yt2) {
				              yt2 += 7;
				              yPoints[1] = yt2 + 4;
				              yPoints[2] = yt2 + 4;
				            }
				            else {
				              yt2 -= 6;
				              yPoints[1] = yt2 - 4;
				              yPoints[2] = yt2 - 4;
				            }
				            yPoints[0] = yt2;
				
							g.fillPolygon(xPoints, yPoints, 3);
				            g.drawLine(x2t1, yt1, x1t2, yt1);
				            g.drawLine(x1t2, yt1, x1t2, yt2);
						
						//Finish-Finish relashion
						} else if(relationship.getRelationshipType()==GanttTaskRelationship.FF) {
							//Get x coord
							int x2t1 = ( (GanttPaintParam) listOfParam.get(index1)).x2;
							int x2t2 = ( (GanttPaintParam) listOfParam.get(index2)).x2;
							
							int xa=(x2t1>x2t2)?x2t1+7:x2t2+7;
							
							//Draw Lines
							g.drawLine(x2t1, yt1, xa, yt1);
				            g.drawLine(xa, yt1, xa, yt2);
							g.drawLine(xa, yt2, x2t2, yt2);
							
							//Traiangle for task 1
							/*x2t1++;
							xPoints[0] = x2t1;
	              			xPoints[1] = x2t1 + 3;
				            xPoints[2] = x2t1 + 3;
							yPoints[0] = yt1;
							yPoints[1] = yt1 - 4;
							yPoints[2] = yt1 + 4;
							g.fillPolygon(xPoints, yPoints, 3);*/
							//Traiangle for task 2
							x2t2++;
							xPoints[0] = x2t2;
	              			xPoints[1] = x2t2 + 3;
				            xPoints[2] = x2t2 + 3;
							yPoints[0] = yt2;
							yPoints[1] = yt2 - 4;
							yPoints[2] = yt2 + 4;
							g.fillPolygon(xPoints, yPoints, 3);
						
						//Start-Finish relashion
						} else if(relationship.getRelationshipType()==GanttTaskRelationship.SF) {
							//Get x coord
							int x1t1 = ( (GanttPaintParam) listOfParam.get(index1)).x1;
							int x2t2 = ( (GanttPaintParam) listOfParam.get(index2)).x2;
						
							x2t2 -= 3;
							
							xPoints[0] = x2t2;
	              			xPoints[1] = x2t2 + 3;
				            xPoints[2] = x2t2 - 3;
	
				            if (yt1 > yt2) {
				              yt2 += 7;
				              yPoints[1] = yt2 + 4;
				              yPoints[2] = yt2 + 4;
				            }
				            else {
				              yt2 -= 6;
				              yPoints[1] = yt2 - 4;
				              yPoints[2] = yt2 - 4;
				            }
				            yPoints[0] = yt2;
				
							g.fillPolygon(xPoints, yPoints, 3);
				            g.drawLine(x1t1, yt1, x2t2, yt1);
				            g.drawLine(x2t2, yt1, x2t2, yt2);
						
						}
						
						}catch(Exception e){}
					
					}//End of visible Task2			
				}//End of parsing the successors
			}//End of isVisible Task1
		}//End of parsing the iterator
		
	  } //Enf of paintDepend function

}
