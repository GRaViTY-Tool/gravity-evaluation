/***************************************************************************
                           GanttTask.java  -  description
                             -------------------
    begin                : dec 2002
    copyright            : (C) 2002 by Thomas Alexandre
    email                : alexthomas(at)ganttproject.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

package net.sourceforge.ganttproject;

import net.sourceforge.ganttproject.resource.HumanResource;
import net.sourceforge.ganttproject.roles.Role;
import net.sourceforge.ganttproject.shape.ShapeConstants;
import net.sourceforge.ganttproject.shape.ShapePaint;
import net.sourceforge.ganttproject.task.ResourceAssignment;
import net.sourceforge.ganttproject.task.Task;
import net.sourceforge.ganttproject.task.TaskImpl;
import net.sourceforge.ganttproject.task.TaskManager;
import net.sourceforge.ganttproject.task.TaskMutator;
import net.sourceforge.ganttproject.task.dependency.TaskDependency;
import net.sourceforge.ganttproject.time.TimeUnit;
import net.sourceforge.ganttproject.time.TimeUnitManager;
import net.sourceforge.ganttproject.util.ColorConvertion;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Serializable;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Vector;

import javax.swing.tree.DefaultMutableTreeNode;

/**
 * Class that generate a task
 */

public class GanttTask extends TaskImpl

    implements Serializable {

  public static int LOW = 0;

  public static int NORMAL = 1;

  public static int HIGHT = 2;


/////////////////////////////////////////////////////////////////////////////////

  /** Constructor */

  public GanttTask(String name, GanttCalendar start, long length, TaskManager taskManager) {
      super(taskManager);
      TimeUnitManager timeManager = getTimeUnitManager();
      TaskMutator mutator = createMutator();
      mutator.setName(name);
      mutator.setStart(start);
      mutator.setDuration(taskManager.createLength(timeManager.getTimeUnit(TimeUnit.DAY), length));
      mutator.commit();
      enableEvents(true);
  }


    private GanttTask(GanttTask copy) {
        super(copy);
//        for (int i = 0; i < getPredecessorsOld().size(); i++) {
//          GanttTaskRelationship tempRel = (GanttTaskRelationship) ( (
//              GanttTaskRelationship) getPredecessorsOld().get(i)).clone();
//          addPredecessor(tempRel);
//        }

//        for (int i = 0; i < successors.size(); i++) {
//          GanttTaskRelationship tempRel = (GanttTaskRelationship) ( (
//              GanttTaskRelationship) successors.get(i)).clone();
//          addSuccessor(tempRel);
//        }
        enableEvents(true);

    }


  /**
   * @return a clone of the Task
   */
  public GanttTask Clone() {
      return new GanttTask(this);
  }

  /** Return the name. */
  public String toString() {
    return getName();
    //return getName();
  }

  /** Return the shape of the task */


  /** Return the duration */

  public int getLength() {

    return (int) getDuration().getLength();

  }


  /** Change the duration */
  public void setLength(int l) {
      TaskMutator mutator = createMutator();
      mutator.setDuration(getManager().createLength(getDuration().getTimeUnit(), l));
      mutator.commit();
  }



  /**whether the time relationship between this task and other has been checked. property will be used in scheduling check*/

  private boolean checked = false;


  public Vector getPredecessorsOld() {
      TaskDependency[] deps = getDependenciesAsDependant().toArray();
      Vector result = new Vector(deps.length);
      for (int i=0; i<deps.length; i++) {
          TaskDependency next = deps[i];
          GanttTaskRelationship rel = new GanttTaskRelationship(next.getDependee().getTaskID(), getTaskID(), next.getConstraint().getID(), getManager());
          result.add(rel);
      }
    return result;
  }

    public Vector getSuccessorsOld() {
        TaskDependency[] deps = getDependenciesAsDependee().toArray();
        Vector result = new Vector(deps.length);
        for (int i=0; i<deps.length; i++) {
            TaskDependency next = deps[i];
            GanttTaskRelationship rel = new GanttTaskRelationship(getTaskID(), next.getDependant().getTaskID(), next.getConstraint().getID(), getManager());
            result.add(rel);
        }
        return result;
    }


  /** Unlink the task from all relationship */
  public void unlink () {
      getDependencies().clear();

  }
  
  /**return true if the realtionship between this task and others has been checked*/

  public boolean isChecked() {

    return checked;

  }

  /**set the checked state of task: true if the relationship has been check. or else, false*/

  public void setChecked(boolean checked) {

    this.checked = checked;

  }

  /**
       *set the task ID. the uniquness of ID should be check before using this method
   * @param taskID
   */
  public void setTaskID(int taskID) {
      setTaskIDHack(taskID);
  }


/** Write all tasks. */
	private void writeTasks(OutputStreamWriter out) throws IOException 
	{
//		parse all tasks	
	    for(Iterator it=lot.iterator(); it.hasNext();)
		{
			DefaultMutableTreeNode node = (DefaultMutableTreeNode) it.next();
			if(!node.isRoot())
			{
				GanttTask task = (GanttTask)(node.getUserObject());
				
				//ID
				if(csvOptions.bExportTaskID)
					out.write(correctField(""+task.getTaskID())+
							(bFixedSize?"":csvOptions.sSeparatedChar));
					
				//Name
				if(csvOptions.bExportTaskName)
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar)+
							correctField(getName(node, task))+
							(bFixedSize?"":csvOptions.sSeparatedTextChar+
							csvOptions.sSeparatedChar));
				
				//Start Date
				if(csvOptions.bExportTaskStartDate)
					out.write(correctField(task.getStart().toString())+
							(bFixedSize?"":csvOptions.sSeparatedChar));
				
				//End Date
				if(csvOptions.bExportTaskEndDate)
					out.write(correctField(task.getEnd().toString())+
							(bFixedSize?"":csvOptions.sSeparatedChar));
				
				//Duration
				if(csvOptions.bExportTaskDuration)
					out.write(correctField(""+task.getLength())+
							(bFixedSize?"":csvOptions.sSeparatedChar));
				
				//Percent complete
				if(csvOptions.bExportTaskPercent)
					out.write(correctField(""+task.getCompletionPercentage())+
							(bFixedSize?"":csvOptions.sSeparatedChar));				

				//Web Link
				if(csvOptions.bExportTaskWebLink)
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar)+
							correctField(getWebLink(task))+
							(bFixedSize?"":csvOptions.sSeparatedTextChar+
							csvOptions.sSeparatedChar));				
				
				//associated resources
				if(csvOptions.bExportTaskResources) {
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar));					
					out.write(correctField(getAssignments(task)));					
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar+
							csvOptions.sSeparatedChar));
				}
				
				//Notes
				if(csvOptions.bExportTaskNotes)
					out.write((bFixedSize?"":csvOptions.sSeparatedTextChar)+
							correctField(task.getNotes())+
							(bFixedSize?"":csvOptions.sSeparatedTextChar+
							csvOptions.sSeparatedChar));
				
				out.write("\n");
			}
		}	    
	} //end of write tasks


/**set the maximum size for all strings. */
void getMaxSize()
{
	iMaxSize = 0;
	for(Iterator it=lot.iterator(); it.hasNext();)
    {
		DefaultMutableTreeNode node = (DefaultMutableTreeNode) it.next();
		if(!node.isRoot())
		{
			GanttTask task = (GanttTask)(node.getUserObject());

			if(csvOptions.bExportTaskID){
				String s=""+task.getTaskID();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskName){
				String s=""+getName(node, task);
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskStartDate){
				String s=""+task.getStart();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskEndDate){
				String s=""+task.getEnd();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskDuration){
				String s=""+task.getLength();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskPercent){
				String s=""+task.getCompletionPercentage();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskWebLink){
				String s=""+getWebLink(task);
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskResources){
				String s=""+getAssignments(task);
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}
			
			if(csvOptions.bExportTaskNotes){
				String s=""+task.getNotes();
				if(s.length()>iMaxSize)iMaxSize=s.length();
			}	
			
		}
    }
	
	//parse all resources
	for (int i = 0; i < resources.size(); i++)
	{
	   	HumanResource p = (HumanResource) resources.get(i);
	   	
	   	if(csvOptions.bExportResourceID){
			String s=""+p.getId();
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	   	if(csvOptions.bExportResourceName){
			String s=""+p.getName();
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	   	if(csvOptions.bExportResourceMail){
			String s=""+p.getMail();
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	   	if(csvOptions.bExportResourcePhone){
			String s=""+p.getPhone();
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	   	if(csvOptions.bExportResourceRole){
	   		Role role = p.getRole();
	        String sRoleID = "0";
	        if(role != null) sRoleID = role.getPersistentID();
			String s=""+sRoleID;
			if(s.length()>iMaxSize)iMaxSize=s.length();
		}
	}
	
} //get maxIndentation end


/**@return the link of the task. */
private String getWebLink(GanttTask task)
{
	return (task.getWebLink().equals("http://")?"":task.getWebLink());
}


/**@return the name of task with the correct level.*/
private String getName(DefaultMutableTreeNode node, GanttTask task)
{
	if(bFixedSize) return task.getName();
	String res="";
	for(int i=0;i<node.getLevel();i++)
		res+="  ";
	return res+task.getName();
}


/** @return the list of the assignment for the resources. */
private String getAssignments(GanttTask task)
{
	String res = "";
	ResourceAssignment[] assignment = task.getAssignments();
	for(int i=0;i<assignment.length;i++)
		res+=(assignment[i].getResource()+(i==assignment.length-1?"":
				csvOptions.sSeparatedChar.equals(";")?",":";"));
	return res;
}


/** Simple write information of tasks */
  public void writeTask(Writer fout, DefaultMutableTreeNode node, String space) {
    String space2 = s + space;
    try {
      
      GanttTask task = (GanttTask)node.getUserObject();
      
      if(task.getTaskID()==-1) throw new RuntimeException("A task can not has a number equal to -1");
      
      
      int id=task.getTaskID();
      
      /*if (id >= lot.size()) {
        return;
      }*/
      
      
      boolean haschild = false;

      ArrayList child = tree.getAllChildTask(node);
      if (child.size() != 0) {
        haschild = true;

      }

      number.add(new Integer(id));
      cpt++;

//      boolean one = (task.getSuccessorsOld().size() != 0 || (task.getNotes() != null && task.getNotes().length()>=0) ||
//                     haschild);
	
	boolean one = (task.getSuccessorsOld().size()==0 && (task.getNotes() == null || task.getNotes().length()==0) && !haschild);


      //Writes data of task
      fout.write(space + "<task id=\"" + task.getTaskID() + //lots.indexOf(task.toString()) + //By CL
                 "\" ");
      fout.write("name=\"" + correct(task.getName()) + "\" ");

      if (task.colorDefined()) {
        /*fout.write("color=\"#");
        if (task.getColor().getRed() <= 15) {
          fout.write("0");
        }
        fout.write(Integer.toHexString(task.getColor().getRed()));
        if (task.getColor().getGreen() <= 15) {
          fout.write("0");
        }
        fout.write(Integer.toHexString(task.getColor().getGreen()));
        if (task.getColor().getBlue() <= 15) {
          fout.write("0");
        }
        fout.write(Integer.toHexString(task.getColor().getBlue()));
        fout.write("\" ");*/
		fout.write("color=\""+ColorConvertion.getColor(task.getColor())+"\" ");
      }

      if (task.shapeDefined() && 
      		task.getShape() != new ShapePaint(ShapeConstants.BACKSLASH, 
      				task.getColor() , task.getColor())) {
	  fout.write("shape=\"" + task.getShape().getArray()+ "\" ");
      }

      fout.write("meeting=\"" + ( (task.isMilestone()) ? "true" : "false") +
                 "\" ");
      fout.write("start=\"" + task.getStart().toXMLString() + "\" ");
      fout.write("duration=\"" + task.getLength() + "\" ");
      fout.write("complete=\"" + task.getCompletionPercentage() + "\" ");
        fout.write("fixed-start=\"" + (task.isStartFixed() ? "true" : "false") + "\" ");
      fout.write("priority=\"" + task.getPriority() + "\"");
      
      //write the web link of the task
      String sWebLink = task.getWebLink();
      if(sWebLink != null && !sWebLink.equals("") && !sWebLink.equals("http://"))
      	fout.write(" webLink=\"" + sWebLink + "\"");
      
      //write if the task is expand or collapse      
      fout.write(" expand=\"" + task.getExpand() + "\"");
	  	
      if (!one) {
        fout.write(">\n");
      }
      else {
        fout.write("/>\n");
        //fout.writeBytes(">\n");

        //Write notes
      }
      if (task.getNotes() != null && task.getNotes().length()>0) {
        fout.write(space2 + "<notes>");
        fout.write("\n" + space2 + s + correct(replaceAll(task.getNotes(), "\n", "\n" + space2 + s)));
        fout.write("\n" + space2 + "</notes>\n");
      }

      //Write the depends of the task
      /*
      if (task.getDepend().size() != 0) {
        //fout.writeBytes(space2+"<depends>\n");
        for (int i = 0; i < task.getDepend().size(); i++) {
          fout.write(space2 + "<depend id=\"" +
                     tree.getTask( (String) task.getDepend().get(i)).getTaskID() + // changed By CL
                     //lots.indexOf( (String) task.getDepend().get(i)) +
                     "\"/>\n");
          //fout.writeBytes(space2+"</depends>\n");
        }
      }*/

      //use successors to write depends information
      Vector successors = task.getSuccessorsOld();
      for (int i = 0; i < successors.size(); i++) {
        GanttTaskRelationship relationship
            = (GanttTaskRelationship) successors.get(i);
        fout.write(space2 /*+s*/ + "<depend id=\"" +
                   relationship.getSuccessorTaskID()+"\""
                   +" type=\""
                   +relationship.getRelationshipType()
                   +"\"/>\n");
      }

      //Write the child of the task
      if (haschild) {
        for (int i = 0; i < child.size(); i++) {
          Task task2 = (Task) ( (DefaultMutableTreeNode) child.get(i)).
              getUserObject();
          int newid = -1; //lot.lastIndexOf(task2);

          for (int j = 0; j < lot.size(); j++) {
            String a = task2.toString();
            String b = lot.get(j).toString();

            if (a.equals(b)) {
              newid = j;
            }
          }
          writeTask(fout, (DefaultMutableTreeNode)child.get(i), space + s);
        }

      }

      //end of task section
      if (!one) {
        fout.write(space + "</task>\n");
        //fout.writeBytes(space+"</task>\n");

      }
      //      if (tree.getNode(task.toString()).isLeaf() &&
      //          !tree.getFatherNode(task).isRoot()) {
      //        return;
      //      }

      //      if (id == lot.size() - 1) {
      //        return;
      //      }
      //      else {
      //        writeTask(fout, cpt, space);
      //
      //      }

    }
    catch (Exception e) {
      System.out.println(e);
    }
  }
}
