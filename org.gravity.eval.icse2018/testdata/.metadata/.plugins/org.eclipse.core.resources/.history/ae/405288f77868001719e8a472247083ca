/*
LICENSE:
                                                                 
   This program is free software; you can redistribute it and/or modify  
   it under the terms of the GNU General Public License as published by  
   the Free Software Foundation; either version 2 of the License, or     
   (at your option) any later version.                                   
                                                                         
   Copyright (C) 2004, GanttProject Development Team
 */
package net.sourceforge.ganttproject.gui;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.util.Iterator;

import javax.swing.tree.DefaultMutableTreeNode;

import net.sourceforge.ganttproject.GanttGraphicArea.GanttPaintParam;
import net.sourceforge.ganttproject.GanttTask;
import net.sourceforge.ganttproject.document.HttpDocument;
import net.sourceforge.ganttproject.task.Task;

/**
 * Created by IntelliJ IDEA.
 * User: bard
 */
public class UIConfiguration {
    private final Font myMenuFont;
    private final Font myChartMainFont;
    private Color myTaskColor;
	private Color myResColor; //default resource color
    private Color myResOverColor; //overload resoure color
    private boolean isRedlineOn;

    public UIConfiguration(Font menuFont, Font chartMainFont, Color taskColor, boolean isRedlineOn) {
        myMenuFont = menuFont==null ? new Font("Dialog", Font.PLAIN, 12) : menuFont;
        myChartMainFont = chartMainFont==null ? new Font("SansSerif", Font.PLAIN, 9) : chartMainFont;
        this.isRedlineOn = isRedlineOn;
        setTaskColor(taskColor);
		myResColor = new Color(140, 182, 206);
        myResOverColor = new Color(229,50,50);
    }


    public Font getMenuFont(){
        return myMenuFont;
    }

    public Font getChartMainFont() {
        return myChartMainFont;
    }

    public Color getTaskColor() {
        return myTaskColor;
    }

    public void setTaskColor(Color myTaskColor) {
        this.myTaskColor = myTaskColor;
    }
    
    public Color getResourceColor() {
        return myResColor;
    }

    public void setResourceColor(Color myResColor) {
        this.myResColor = myResColor;
    }
    
    
    public Color getResourceOverloadColor() {
        return myResOverColor;
    }

    public void setResourceOverloadColor(Color myResOverColor) {
        this.myResOverColor = myResOverColor;		
    }

    public boolean isRedlineOn() {
        return isRedlineOn;
    }

    public void setRedlineOn(boolean redlineOn) {
        isRedlineOn = redlineOn;
    }


	/** This method check if the value has changed, and assk for commit changes. */
		public boolean applyChanges(boolean askForApply)
		{
			if(getAutomatic() == appli.getOptions().getAutomatic() && 
			   getRedLine() == appli.getUIConfiguration().isRedlineOn() &&
			   getDragTime() == appli.getOptions().getDragTime() && 
			   getLockDAVMinutes() == appli.getOptions().getLockDAVMinutes() && 
			   (getTaskNamePrefix()==null || getTaskNamePrefix().equals(appli.getOptions().getTrueTaskNamePrefix())))
			{
				bHasChange = false;
			}
			else 
			{
				bHasChange = true;
				if(!askForApply || (askForApply && askForApplyChanges()))
				{			
					appli.getOptions().setAutomatic(getAutomatic());
					appli.getUIConfiguration().setRedlineOn(getRedLine());				
					appli.getOptions().setDragTime(getDragTime());
					appli.getOptions().setTaskNamePrefix(getTaskNamePrefix());
					
	//				WebDAV Locking
					appli.getOptions().setLockDAVMinutes(getLockDAVMinutes());
					HttpDocument.setLockDAVMinutes(getLockDAVMinutes());				
				}
			}
			
			return bHasChange;
		}


	/** Initialize the component. */
	public void initialize()
	{
		cbAutomatic.setSelected(appli.getOptions().getAutomatic());
		cbRedLine.setSelected(appli.getUIConfiguration().isRedlineOn());
		cbDrag.setSelected(appli.getOptions().getDragTime());
		tfTaskPrefix.setText(appli.getOptions().getTaskNamePrefix());
		spLockDAV.setValue(new Integer(appli.getOptions().getLockDAVMinutes()));
	}


	/** Draw a monther task */
	  public void paintATaskFather(Graphics g, int x1, int x2, int y, Task task) {
	    int d = y;
	    y = y * 20 + 35 - margY;
	
	    if (y < 20 || y > getHeight()) {
	      return; //Not draw if the task is not on the area
	    }
	    if ( (x1 > getWidth() && x2 > getWidth()) || (x1 < 0 && x2 < 0)) {
	      return;
	    }
	
	    //Black rectangle
	    if (drag == d - 1) {
	      g.setColor(arrayColor[4]);
	    }
	    else {
	      if (task.getColor().equals(myUIConfiguration.getTaskColor())) {
	        g.setColor(Color.black);
	      }
	      else {
	        g.setColor( /*Color.black*/task.getColor());
	      }
	    }
	    g.fillRect(x1, y, x2 - x1, 2);
	
	    //Little triangle at begin and end
	    int xPoints[] = new int[3];
	    int yPoints[] = new int[3];
	    xPoints[0] = x1;
	    xPoints[1] = x1 + 5;
	    xPoints[2] = x1;
	    yPoints[0] = y + 2;
	    yPoints[1] = y + 2;
	    yPoints[2] = y + 6;
	    g.fillPolygon(xPoints, yPoints, 3);
	    xPoints[0] = x2;
	    xPoints[1] = x2 - 5;
	    xPoints[2] = x2;
	    g.fillPolygon(xPoints, yPoints, 3);
	
	    //Draw the resource list after the task
			paintResources (x2+40, y+9, task, g);
	
	  }


	/** Paint all tasks  */
	  public void paintTasks(Graphics g) {
	      int sizex = getWidth();
	      int sizey = getHeight();
	      int headery = 45;
	      float fgra = (float) sizex / (float) getGranit(true);
	
	      g.setFont(myUIConfiguration.getChartMainFont());
	
	      //Get all task
	
	      //Probably optimised on next release
	      listOfParam.clear();
	
	      int y = 0;
	
	      for (Iterator tasks = listOfTask.iterator(); tasks.hasNext();) {
	          DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode) tasks.next();
	          GanttTask task = (GanttTask) treeNode.getUserObject();
	
	//Is the task is visible, the task could be draw
	          if (isVisible(task)) {
	              int x1 = -10, x2 = sizex + 10;
	              int e1; //ecart entre la date de debut de la tache et la date du debut du calendrier
	              int fois;
	              int type = 2;
	              y++;
	
	//difference between the start date of the task and the end
	              e1 = date.diff(task.getStart());
	
	//Calcul start and end pixel of each task
	              float fx1, fx2;
	
	              if (task.isMilestone()) {
	                  fx1 = (float) e1 * fgra *
	                          ((date.compareTo(task.getStart()) == 1) ? -1 : 1);
	                  x1 = (int) fx1;
	              } else {
	                  fx1 = (float) e1 * fgra *
	                          ((date.compareTo(task.getStart()) == 1) ? -1 : 1);
	                  fx2 = fx1 + (float) task.getLength() * fgra;
	                  x1 = (int) fx1;
	                  x2 = (int) fx2;
	              }
	
	              int percent = 0;
	
	//Meeting task
	              if (task.isMilestone()) {
	                  paintATaskBilan(g, x1, y, task);
	                  x2 = x1 + (int) fgra;
	                  type = 0;
	              }
	//A mother task
	              else if (tree.getAllChildTask(treeNode).size() != 0) {
	
	                  //Compute percent-complete
	                  tree.computePercentComplete(treeNode);
	
	                  paintATaskFather(g, x1, x2, y, task);
	                  if (drawPercent) {
	                      percent = paintAdvancement(g, x1, x2, y, task.getCompletionPercentage(), task.getShape(),
	                              task.getColor(), true);
	                  }
	                  type = 1;
	              }
	//A normal task
	              else {
	                  paintATaskChild(g, x1, x2, y, task);
	                  if (drawPercent) {
	
	                      percent = paintAdvancement(g, x1, x2, y, task.getCompletionPercentage(), task.getShape(),
	                              task.getColor(), false);
	                  }
	                  type = 2;
	              }
	
	//Add parameters on the array
	              listOfParam.add(new GanttPaintParam(task.getName(), task.getTaskID(),
	                      x1, x2, percent, y, type));
	          }
	      }
	
	  }


	/** Print the list of tasks */
	private void printTasks(Graphics g){
		g.setColor(Color.white);
		g.fillRect(0, 0, getWidth(), getHeight());
	
		g.setColor(Color.black);
		g.setFont(myUIConfiguration.getChartMainFont());
		
		printTask(g,5,42,getTree().getAllChildTask(getTree().getRoot()));
		
	}


	/** Draw a normal task */
	  public void paintATaskChild(Graphics g, int x1, int x2, int y, Task task) {
	    int d = y;
	    y = y * 20 + 27 - margY;
	
	    if (y < 20 || y > getHeight()) {
	      return; //Not draw if the task is not on the area
	    }
	    if ( (x1 > getWidth() && x2 > getWidth()) || (x1 < 0 && x2 < 0)) {
	      return;
	    }
	
	    //Blue rectangle
	      Color c = ((GanttTask)task).colorDefined() ? task.getColor() :myUIConfiguration.getTaskColor();
	    g.setColor(c);
	    g.fillRect(x1, y, (x2 - x1 - 1), 12);
	
	    //Draw nice border
	    //if(draw3dBorders)
	    {	
	    	if (drag == d - 1) {
	    		g.setColor(arrayColor[0]);
	    	}
	    	else {
	    		g.setColor(Color.black);
	    	}
	    	g.drawRect(x1, y, x2 - x1 - 1, 12);
	    	
	    	//AT
	    	//This code print a gray border around the task
	    	//BTW I've comment it for several reason
	    	//- It' increase the time of rendering
	    	//- when printing the char, this border isn't good
	    	//- for the rendering, it's only beautiful with the default color, but not with another one
	    	//- finally I found it nicer now :)
	    	/*g.setColor(arrayColor[7]);
	    	g.drawLine(x1 + 1, y + 1, (x2 - 1) - 1, y + 1);
	    	g.drawLine(x1 + 1, y + 1, x1 + 1, y + 11);
	    	
	    	g.setColor(arrayColor[8]);
	    	g.drawLine(x1 + 2, y + 11, (x2 - 1) - 2, y + 11);
	    	g.drawLine(x2 - 2, y + 2, x2 - 2, y + 11);*/
	  	}
	    
		//Draw the resource list after the task
		paintResources (x2+40, y+10, task, g);
	
	  }

}
