/* Generated By:JJTree: Do not edit this line. ASTClassOrInterfaceDeclaration.java */

package net.sourceforge.pmd.ast;

public class ASTClassOrInterfaceDeclaration extends AccessNode {
    public ASTClassOrInterfaceDeclaration(int id) {
        super(id);
    }

    public ASTClassOrInterfaceDeclaration(JavaParser p, int id) {
        super(p, id);
    }

    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(JavaParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    public boolean isNested() {
        return jjtGetParent() instanceof ASTClassOrInterfaceBodyDeclaration;
    }

    private boolean isInterface;

    public boolean isInterface() {
        return this.isInterface;
    }

    public void setInterface() {
        this.isInterface = true;
    }

    public void dump(String prefix) {
        String interfaceStr = isInterface ? "interface" : "class";
        String innerStr = isNested() ? "(nested)" : "";
        System.out.println(toString(prefix) + "(" + getImage() + ")(" + interfaceStr + ")" + innerStr);
        dumpChildren(prefix);
    }

	private Object checkNames(ASTFieldDeclaration node, Object data) {
	    ASTType childNodeType = (ASTType) node.jjtGetChild(0);
	    String varType = "";
	    if (childNodeType.jjtGetChild(0) instanceof ASTName) {
	        varType = ((ASTName) childNodeType.jjtGetChild(0)).getImage();
	    } else if (childNodeType.jjtGetChild(0) instanceof ASTPrimitiveType) {
	        varType = ((ASTPrimitiveType) childNodeType.jjtGetChild(0)).getImage();
	    }
	    if (varType != null && varType.length() > 0) {
	        //Get the variable name
	        ASTVariableDeclarator childNodeName = (ASTVariableDeclarator) node.jjtGetChild(1);
	        ASTVariableDeclaratorId childNodeId = (ASTVariableDeclaratorId) childNodeName.jjtGetChild(0);
	        String varName = childNodeId.getImage();
	
	        if (varName.equals("serialVersionUID") || (node.isFinal() && !node.isStatic() && !node.isInterfaceMember())) {
	            return data;
	        }
	
	        // static finals (and interface fields, which are implicitly static and final) are
	        // checked for uppercase
	        if ((node.isStatic() && node.isFinal()) || (node.jjtGetParent().jjtGetParent().jjtGetParent() instanceof ASTClassOrInterfaceDeclaration && ((ASTClassOrInterfaceDeclaration) node.jjtGetParent().jjtGetParent().jjtGetParent()).isInterface())) {
	            if (!varName.equals(varName.toUpperCase())) {
	                addViolationWithMessage(data, childNodeName, "Variables that are final and static should be in all caps.");
	            }
	            return data;
	        }
	
	        String strippedVarName = null;
	        if (node.isStatic()) {
	            strippedVarName = normalizeStaticVariableName(varName);
	        } else {
	            strippedVarName = normalizeMemberVariableName(varName);
	        }
	
	        if (strippedVarName.indexOf('_') >= 0) {
	            addViolationWithMessage(data, childNodeName, "Variables that are not final should not contain underscores (except for underscores in standard prefix/suffix).");
	        }
	        if (Character.isUpperCase(varName.charAt(0))) {
	            addViolationWithMessage(data, childNodeName, "Variables should start with a lowercase character");
	        }
	    }
	    return data;
	}

}
